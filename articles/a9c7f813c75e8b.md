---
title: "Aptosä¸Šã«NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã‚’ä½œã£ã¦ã¿ã‚ˆã†ï¼ï¼"
emoji: "ğŸ“–"
type: "tech" 
topics: ["Move", "Aptos", "Blockchain", "Web3", "NFT"]
published: true
---

![](/images/a9c7f813c75e8b/0.jpeg)

# ã¯ã˜ã‚ã«

çš†ã•ã‚“ã€ã“ã‚“ã«ã¡ã¯ï¼

ä»Šå›ã¯ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã®ä¸€ã¤ã§ã‚ã‚‹Aptosã‚’ãƒ†ãƒ¼ãƒã«ã—ãŸè¨˜äº‹ã«ãªã‚Šã¾ã™ï¼

2024å¹´ç¾åœ¨ ãƒãƒƒã‚«ã‚½ãƒ³ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ Akindoã¨Aptosã®ãƒãƒ¼ãƒ ãŒã‚¿ãƒƒã‚°çµ„ã‚“ã§WaveHackã¨ã„ã†ã‚°ãƒ©ãƒ³ãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿæ–½ä¸­ã§ã™ï¼

ã‚°ãƒ©ãƒ³ãƒˆã«ã¯2ã¤ã®éƒ¨é–€ãŒã‚ã‚‹ã®ã§ã™ãŒã€ä»Šå›ã¯ãã®ã†ã¡ã®ä¸€ã¤ã§ã‚ã‚‹

**Create Aptos Move Contents** 

éƒ¨é–€ã¸ã®å¿œå‹Ÿã‚‚å…¼ã­ãŸè¨˜äº‹ã«ãªã£ã¦ã„ã¾ã™ï¼ï¼

å¯¾è±¡ã¨ãªã£ã¦ã„ã‚‹Aptosã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¿»è¨³ã™ã‚‹ã ã‘ã§ã‚°ãƒ©ãƒ³ãƒˆã‚’å–å¾—ã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã‚‚ã‚°ãƒ©ãƒ³ãƒˆã‚’ç²å¾—ã§ãã‚‹éå¸¸ã«è²´é‡ãªæ©Ÿä¼šã¨ãªã£ã¦ã„ã¾ã™ã®ã§çš†ã•ã‚“ã‚‚ãœã²æŒ‘æˆ¦ã—ã¦ã¿ã¦ãã ã•ã„ã­ï¼ï¼

è©³ç´°ã¯ä¸‹è¨˜ã‚µã‚¤ãƒˆã«ã¦ç´¹ä»‹ã•ã‚Œã¦ã„ã¾ã™ï¼

https://app.akindo.io/wave-hacks/Nmqgo639ai9ZQMB1


https://app.akindo.io/wave-hacks/Z47L4rwQmI774vRpr


https://lu.ma/aptos-wavehack

# ä»Šå›ç¿»è¨³ã«æŒ‘æˆ¦ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

Aptosãƒãƒ¼ãƒ ãŒå‡ºã—ã¦ã„ã‚‹ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ã‚µã‚¤ãƒˆã®ä»¥ä¸‹ã®è¨˜äº‹ã®ç¿»è¨³ã«æŒ‘æˆ¦ã—ã¾ã™ï¼ï¼

https://learn.aptoslabs.com/example/nft-marketplace

Aptosä¸Šã§ãŸã¾ã”ã£ã¡ãƒ©ã‚¤ã‚¯ãªã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å£²è²·ã§ãã‚‹NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ãŒæ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã§ã™ï¼ï¼

https://marketplace-example-rho.vercel.app/

![](/images/a9c7f813c75e8b/1.png)

å‰å›ã®è¨˜äº‹ãŒè¦‹ã¦ã¿ãŸã„ã¨ã„ã†æ–¹ã¯ãœã²ä¸‹è¨˜ã‚‚ãƒã‚§ãƒƒã‚¯ã—ã¦ã¿ã¦ãã ã•ã„ï¼ï¼

https://zenn.dev/mashharuki/articles/f6deb29bb67cd3

ä»Šå›ãŠæ‰‹æœ¬ã¨ãªã‚‹GitHubã®ãƒªãƒã‚¸ãƒˆãƒªã¯ä¸‹è¨˜ã§ã™ï¼

https://github.com/aptos-labs/marketplace-example

ç§ã¯ä¸Šè¨˜ã®ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒ™ãƒ¼ã‚¹ã«ã‚³ãƒ¡ãƒ³ãƒˆãªã©ã‚’è¿½è¨˜ã—ã¦ã„ã¾ã™ï¼ï¼

https://github.com/mashharuki/marketplace-example

ã“ã®å­¦ç¿’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ã¯æ¬¡ã®ã“ã¨ãŒå­¦ã¹ã¾ã™ï¼ï¼

:::message
1. Moveè¨€èªã«ã‚ˆã‚‹å¿œç”¨çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®å®Ÿè£…æ–¹æ³•

    NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®æ©Ÿèƒ½ã‚’å®Ÿç¾ã•ã›ã‚‹ãŸã‚ã«ã¯è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ Moveè¨€èªã§ãã‚Œã‚’å®Ÿç¾ã•ã›ã‚‹æ–¹æ³•ã‚’å­¦ã¹ã¾ã™ã€‚

2. entryãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…æ–¹æ³•

    NFTã®è³¼å…¥ã‚„ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ãªã©ã€ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã«æœ€ä½é™å¿…è¦ãªæ©Ÿèƒ½ã‚’Moveè¨€èªã§å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’å­¦ã¹ã¾ã™ã€‚

3. Moveè¨€èªã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å®Ÿè£…æ–¹æ³•

    Moveè¨€èªã§é–‹ç™ºã—ãŸã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å®Ÿè£…æ–¹æ³•ã‚’å­¦ã¹ã¾ã™ã€‚
:::


ã“ã®å­¦ç¿’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§é–‹ç™ºã™ã‚‹NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®æ¦‚è¦

:::message
å‰å›ã®è¨˜äº‹ã¾ã§ã§é–‹ç™ºã—ã¦ã„ãŸAptogochiNFTç”¨ã®NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã‚’é–‹ç™ºã—ã¾ã™ã€‚

ã‚ˆã‚Šä½¿ã„ã‚„ã™ã„ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã‚’é–‹ç™ºã™ã‚‹ã¨ãªã‚‹ã¨ã‚ªãƒ¼ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ãŒã‚ã£ãŸã‚Šã—ãŸæ–¹ãŒè‰¯ã„ã§ã™ãŒã€ä»Šå›ã¯åŸºæœ¬çš„ãªæ©Ÿèƒ½ã®å®Ÿè£…ãŒãƒ¡ã‚¤ãƒ³ã¨ãªã‚Šã¾ã™ã€‚

- NFTã‚’ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã•ã›ã‚‹æ©Ÿèƒ½  
  è‡ªåˆ†ãŒä¿æœ‰ã™ã‚‹NFTã‚’å£²ã‚Šã«å‡ºã™æ©Ÿèƒ½
- NFTã‚’è³¼å…¥ã™ã‚‹æ©Ÿèƒ½  
  å£²ã‚Šã«å‡ºã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¨­å®šã—ãŸé‡‘é¡ã§NFTã‚’è³¼å…¥ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹æ©Ÿèƒ½
- NFTã‚’ãƒŸãƒ³ãƒˆã™ã‚‹æ©Ÿèƒ½  
  ãƒ‡ãƒ¢ç”¨ã«NFTãƒŸãƒ³ãƒˆã™ã‚‹æ©Ÿèƒ½
:::

# Moveè¨€èªã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®è€ƒãˆæ–¹

ãƒ‡ãƒ¼ã‚¿ã‚’æ°¸ç¶šçš„ã«ä¿ç®¡ã™ã‚‹æ–¹æ³•ã¨ã—ã¦ä»¥ä¸‹ã®3ã¤ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚

- ã‚¢ã‚«ã‚¦ãƒ³ãƒˆå†…ã®ãƒªã‚½ãƒ¼ã‚¹  

  ã‚¢ã‚«ã‚¦ãƒ³ãƒˆå†…ã®ãƒªã‚½ãƒ¼ã‚¹ã§ã¯ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚„ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ç›´æ¥çµã³ã¤ã„ãŸMoveã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ©Ÿèƒ½ã‚’åˆ©ç”¨ã§ãã¾ã™ã€‚ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã”ã¨ã«ä¸€æ„ã«ä¿å­˜ã•ã‚Œã€ä¿å­˜ã«ã¯move_toã€å–å¾—ã«ã¯borrow_globalã¨ã„ã£ãŸç‰¹å®šã®é–¢æ•°ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚  
  
  æ§‹é€ ä½“ã¯ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ã‚¹ãƒ†ãƒ¼ãƒˆã‚’ã‚¢ã‚¿ãƒƒãƒã™ã‚‹ç°¡å˜ãªæ–¹æ³•ã‚’æä¾›ã—ã¾ã™ãŒã€ã‚¬ã‚¹ã‚³ã‚¹ãƒˆã¨å˜ä¸€ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºåˆ¶ç´„ã«ã‚ˆã‚Šã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®åˆ¶é™ã‚’å›é¿ã™ã‚‹ãŸã‚ã«ã€æ§‹é€ ä½“ã«ã¯ä»–ã®æ§‹é€ ä½“ã‚„ãƒ™ã‚¯ãƒˆãƒ«ã‚’å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€ãã®ä»£ã‚ã‚Šè¤‡é›‘ã«ãªã‚Šã¾ã™ã€‚

- ãƒ†ãƒ¼ãƒ–ãƒ«  

  Moveã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã¯ã€æŸ”è»Ÿãªã‚­ãƒ¼ã¨ãƒãƒªãƒ¥ãƒ¼ã‚’ç®¡ç†ã§ãã¾ã™ã€‚åŒã˜æ§‹é€ ä½“ã‚¿ã‚¤ãƒ—ã®è¤‡æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¡çªãƒªã‚¹ã‚¯ãªã—ã«ä½¿ç”¨ã§ãã‚‹ãŸã‚ã€ãƒªã‚½ãƒ¼ã‚¹ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€å¤§è¦æ¨¡ãªãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¸ã®åŠ¹ç‡çš„ã§æ±ºå®šè«–çš„ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’å¿…è¦ã¨ã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ç‰¹ã«å½¹ç«‹ã¡ã¾ã™ã€‚  
  
  Aptosã§ã¯ã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚’å®Ÿç¾ã™ã‚‹BigVectorã‚„SmartVectorã€å‡ç¸®ã•ã‚ŒãŸã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’å®Ÿç¾ã™ã‚‹SmartTableãªã©ã®æ§‹é€ ä½“ã§ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å¼·åŒ–ã—ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ã‚¹ãƒšãƒ¼ã‚¹ã¨ã‚¢ã‚¯ã‚»ã‚¹åŠ¹ç‡ã‚’æœ€é©åŒ–ã—ã¦ã„ã¾ã™ã€‚

- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ  

  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«å¯¾ã™ã‚‹å¾®å¦™ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æä¾›ã—ã€ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚„ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ˆã£ã¦æ‰€æœ‰ãƒ»ç®¡ç†ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã€ã‚ªãƒ³ãƒã‚§ãƒ¼ãƒ³ãƒ»ãƒ‡ãƒ¼ã‚¿ã®æ§‹æˆèƒ½åŠ›ã‚’é«˜ã‚ã¾ã™ã€‚
  
  ã“ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€1ã¤ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚„å¥‘ç´„ã®ä¸‹ã§è¤‡æ•°ã®ãƒªã‚½ãƒ¼ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç®¡ç†ã™ã‚‹ã“ã¨ã‚’å®¹æ˜“ã«ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ‰€æœ‰æ¨©ã¨è»¢é€æ€§ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ã•ã¾ã–ã¾ãªãƒ‰ãƒ¡ã‚¤ãƒ³ã«ã‚ãŸã‚‹è¤‡é›‘ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–‹ç™ºã‚’åˆç†åŒ–ã—ã¾ã™ã€‚

# ä»Šå›å®Ÿè£…ã™ã‚‹ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ãƒã‚¤ãƒ³ãƒˆ

NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’è¨­è¨ˆã™ã‚‹éš›ã«ã¯ã€å‡ºå“ã¨å–å¼•ã‚’è‡ªå¾‹çš„ã«ç®¡ç†ã™ã‚‹æ–¹æ³•ãŒå¿…è¦ã§ã™ã€‚

ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¿ƒé€²ã™ã‚‹ãŸã‚ã«ã¯ã€ä¾¡æ ¼ã€å£²ã‚Šæ‰‹ã®è©³ç´°ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã„ã£ãŸé‡è¦ãªæƒ…å ±ã‚’ã‚ªãƒ³ãƒã‚§ãƒ¼ãƒ³ã«ä¿å­˜ã™ã‚‹ã“ã¨ãŒå¿…é ˆã§ã™ã€‚

ä¾‹ãˆã°ä¸‹è¨˜ã®ã‚ˆã†ãªç‚¹ã§ã™ã­ã€‚

1. å£²ã‚Šæ‰‹ã”ã¨ã«è¤‡æ•°ã®ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚’ä¿å­˜ã™ã‚‹  

   å£²ã‚Šæ‰‹ã¯ç•°ãªã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã«ã¤ã„ã¦è¤‡æ•°ã®ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚’ä½œæˆã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚

   ä¾‹ãˆã°ã€Alice ã¯è¤‡æ•°ã® Aptogotchi ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒªã‚¹ãƒˆã—ã€ãã‚Œãã‚Œã«å›ºæœ‰ã®ãƒªã‚¹ãƒˆæƒ…å ±ã‚’æŒã¤ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

   ãã®ãŸã‚ã«ã¯ã€ä¸€ã¤ã®å£²ã‚Šæ‰‹ã«é–¢é€£ã™ã‚‹ã€åŒã˜å‹ã®è¤‡æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒå¿…è¦ã§ã™ã€‚

2. ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã®ç®¡ç†  

   ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã«ã¯ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãŒã‚ã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³ã®è²©å£²ã§çµ‚äº†ã—ã¾ã™ã€‚

   è³¼å…¥å¾Œã€ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®æ•´åˆæ€§ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«ã€ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’åŠ¹ç‡çš„ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¦å‰Šé™¤ã™ã‚‹ã“ã¨ãŒé‡è¦ã«ãªã£ã¦ãã¾ã™ã€‚


ã“ã‚Œã‚‰ã®è¦ä»¶ã‚’å®Ÿç¾ã•ã›ã‚‹ãŸã‚ã«ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã”ã¨ã«ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’1ã¤ã ã‘ä¿å­˜ã™ã‚‹ã¨ã„ã†åˆ¶é™ã‚’å…‹æœã™ã‚‹ãŸã‚ã«ã€ãƒªã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚

ã“ã®æ–¹æ³•ã¯ã€å£²ã‚Šæ‰‹ã”ã¨ã«è¤‡æ•°ã®å‡ºå“ã‚’å¯èƒ½ã«ã™ã‚‹ã ã‘ã§ãªãã€ãƒ‡ã‚¸ã‚¿ãƒ«è³‡ç”£æ¨™æº–ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹æ™‚ã¨åŒã˜ã§ã™ã€‚

Aptosã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«ã«ã¤ã„ã¦ã•ã‚‰ã«çŸ¥ã‚ŠãŸã„ã¨ã„ã†æ–¹ã¯ä¸‹è¨˜ãƒªãƒ³ã‚¯ã‚’å‚è€ƒã«ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

https://aptos.dev/standards/aptos-object/

# ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚½ãƒ¼ã‚¹ã®å®šç¾©

Moveã§ã¯ã€æ§‹é€ ä½“ã«ã‚­ãƒ¼ã®èƒ½åŠ›ã‚’ãƒãƒ¼ã‚¯ã—ã€`resource_group_member`ã¨ã„ã†ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ»ãƒªã‚½ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªã‚¹ãƒˆã”ã¨ã«å€‹åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã€é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®ãƒªã‚¹ãƒˆæƒ…å ±ã‚’ãã®ä¸­ã«ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã“ã§ã¯ã€2ã¤ã®ä¸»è¦ãªæ§‹é€ ä½“ã‚’ä¸­å¿ƒã«ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã‚’è¨­è¨ˆã—ã¾ã™

- `Listing`
- `FixedPriceListing`

ã®2ã¤ã§ã™ã€‚

ã“ã®ã‚ˆã†ã«åˆ†é›¢ã™ã‚‹ã“ã¨ã§ã€ã‚ªãƒ¼ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚ˆã†ãªå‹•çš„ãªä¾¡æ ¼ãƒ¢ãƒ‡ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãªã©ã€å°†æ¥ã®æ‹¡å¼µæ€§ã‚’ç¢ºä¿ã§ãã¾ã™ã€‚
å„ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã¯ç‹¬è‡ªã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã€Listingã¯ãƒˆãƒ¼ã‚¯ãƒ³ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å£²ã‚Šæ‰‹æƒ…å ±ã‚’ä¿æŒã—ã€FixedPriceListingã¯é¸æŠã—ãŸCoinTypeã§ä¾¡æ ¼ã‚’æŒ‡å®šã—ã¾ã™ï¼ˆCoinTypeã¯ä¸€èˆ¬çš„ãªå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦æŒ‡å®šã•ã‚Œã¾ã™ï¼‰ã€‚

## Listing ãƒªã‚½ãƒ¼ã‚¹

ä»Šå›ã®ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã‚¢ãƒ—ãƒªã§ã¯ä¸‹è¨˜ã®æ§˜ã«å®Ÿè£…ã—ã¾ã™ã€‚

```rs
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Listing has key {
  /// The item owned by this listing, transferred to the new owner at the end.
	object: Object<ObjectCore>,
  /// The seller of the object.
	seller: address,
  /// Used to clean-up at the end.
	delete_ref: DeleteRef,
  /// Used to restore the object signer for transferring the escrowed object to the buyer.
	extend_ref: ExtendRef,
}

```

- objectï¼š   
  ãƒªã‚¹ãƒˆã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚ã“ã“ã§ã¯ã€token v2ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‚ç…§ï¼ˆã¾ãŸã¯ãƒã‚¤ãƒ³ã‚¿ï¼‰ã§ã™ã€‚
- sellerï¼š   
  å£²ã‚Šæ‰‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- delete_ref:   
  è³¼å…¥å¾Œã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚
- extend_refï¼š  
  ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°å¾Œã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¨ã‚¹ã‚¯ãƒ­ãƒ¼ã—ã¾ã™ï¼ˆãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç½²åè€…ãŒãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿æŒã—ã¾ã™ï¼‰ã®ã§ã€è²·ã„æ‰‹ãŒè³¼å…¥ã—ãŸã„ã¨ãã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç½²åè€…ã‚’å¾©å…ƒã—ã€object::transferã‚’å‘¼ã³å‡ºã™ãŸã‚ã«ExtendRefãŒå¿…è¦ã§ã™ã€‚

## FixedPriceListing ãƒªã‚½ãƒ¼ã‚¹

ä»Šå›ã®ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã‚¢ãƒ—ãƒªã§ã¯ä¸‹è¨˜ã®æ§˜ã«å®Ÿè£…ã—ã¾ã™ã€‚

```rs
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FixedPriceListing<phantom CoinType> has key {
  /// The price to purchase the item up for listing.
	price: u64,
}
```

- price:   
 ã€€ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã—ãŸNFTã®ä¾¡æ ¼ã§ã™ã€‚

# ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…

å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹éƒ¨åˆ†ã®å®Ÿè£…ãŒå®Œäº†ã—ãŸã®ã§æ¬¡ã«å¿…è¦ãªæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

ã“ã“ã§ã¯2ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚


- `list_with_fixed_price`  
  å£²ã‚Šæ‰‹ãŒãƒˆãƒ¼ã‚¯ãƒ³ã‚’å£²ã‚Šã«å‡ºã™é–¢æ•°
- `purchase`  
  è²·ã„æ‰‹ãŒãƒªã‚¹ãƒˆã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’è³¼å…¥ã™ã‚‹é–¢æ•°

## list_with_fixed_price

ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§NFTã‚’ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã®é–¢æ•°ã§ã¯ã€å£²ã‚Šæ‰‹ãŒæ‰€æœ‰ã™ã‚‹æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€Listingãƒªã‚½ãƒ¼ã‚¹ã¨FixedPriceListingãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç§»å‹•ã—ã¾ã™ã€‚ã¾ãŸã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç½²åè€…ã«è»¢é€ã—ã€ã‚¨ã‚¹ã‚¯ãƒ­ãƒ¼å£åº§ã¨ã—ã¦æ©Ÿèƒ½ã•ã›ã¾ã™ã€‚

objectãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰`create_object`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€å£²ã‚Šæ‰‹ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«Listingã¨FixedPriceListingã®ãƒªã‚½ãƒ¼ã‚¹ã‚’æ ¼ç´ã—ã¾ã™ã€‚

å…·ä½“çš„ã«ã¯ä¸‹è¨˜ã®æ§˜ãªå®Ÿè£…ã¨ãªã‚Šã¾ã™ã€‚

```rs
/// List an time for sale at a fixed price.
public entry fun list_with_fixed_price<CoinType>(
    seller: &signer,
    object: Object<ObjectCore>,
    price: u64,
) {
    let constructor_ref = object::create_object(signer::address_of(seller));
    let transfer_ref = object::generate_transfer_ref(&constructor_ref);
    object::disable_ungated_transfer(&transfer_ref);

    let listing_signer = object::generate_signer(&constructor_ref);
    let listing = Listing {
        object,
        seller: signer::address_of(seller),
        delete_ref: object::generate_delete_ref(&constructor_ref),
        extend_ref: object::generate_extend_ref(&constructor_ref),
    };
    let fixed_price_listing = FixedPriceListing<CoinType> {
        price,
    };
    move_to(&listing_signer, listing);
    move_to(&listing_signer, fixed_price_listing);

    object::transfer(seller, object, signer::address_of(&listing_signer));
}
```

é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’è§£èª¬ã—ã¦ã„ãã¾ã™ã€‚

```rs
object::disable_ungated_transfer(&transfer_ref);
```

ã“ã“ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚ã‚‹`disable_ungated_transfer`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚²ãƒ¼ãƒˆãªã—è»¢é€ã‚’ä¸å¯ã«ã—ã¾ã™ã€‚

```rs
let listing_signer = object::generate_signer(&constructor_ref);
let listing = Listing {
    object,
    seller: signer::address_of(seller),
    delete_ref: object::generate_delete_ref(&constructor_ref),
    extend_ref: object::generate_extend_ref(&constructor_ref),
};
let fixed_price_listing = FixedPriceListing<CoinType> {
    price,
};
move_to(&listing_signer, listing);
move_to(&listing_signer, fixed_price_listing);
```

æ–°ã—ã„Listingã¨FixedPriceListingãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç½²åè€…(ã“ã“ã§ã¯ã“ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆ)ã«ç§»å‹•ã—ã¾ã™ã€‚

```rs
object::transfer(seller, object, signer::address_of(&listing_signer));
```

æœ€å¾Œã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç½²åè€…ã«è»¢é€ã—ã¦ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ãŒå®Œäº†ã—ã¾ã™ã€‚

## purchase

è³¼å…¥è€…ã¯ã€å›ºå®šä¾¡æ ¼ãƒªã‚¹ãƒˆã‹ã‚‰ NFT ã‚’è³¼å…¥ã™ã‚‹éš›ã«ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

ã“ã®é–¢æ•°ã¯ã€NFT ã‚’è²·ã„æ‰‹ã«è­²æ¸¡ã—ã€ä»£é‡‘ã‚’å£²ã‚Šæ‰‹ã«è­²æ¸¡ã—ã¾ã™ã€‚ã¾ãŸã€Listing ãŠã‚ˆã³ FixedPriceListing ãƒªã‚½ãƒ¼ã‚¹ã‚’å«ã‚€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚

å…·ä½“çš„ã«ã¯ä¸‹è¨˜ã®æ§˜ã«å®Ÿè£…ã—ã¾ã™ã€‚

```rs
/// Purchase outright an item from a fixed price listing.
public entry fun purchase<CoinType>(
  purchaser: &signer,
  object: Object<ObjectCore>,
) acquires FixedPriceListing, Listing {
  let listing_addr = object::object_address(&object);
  assert!(exists<Listing>(listing_addr), error::not_found(ENO_LISTING));
  assert!(exists<FixedPriceListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));

  let FixedPriceListing {
      price,
  } = move_from<FixedPriceListing<CoinType>>(listing_addr);

  // The listing has concluded, transfer the asset and delete the listing. Returns the seller
  // for depositing any profit.
  let coins = coin::withdraw<CoinType>(purchaser, price);

  let Listing {
      object,
      seller, // get seller from Listing object
      delete_ref,
      extend_ref,
  } = move_from<Listing>(listing_addr);

  let obj_signer = object::generate_signer_for_extending(&extend_ref);
  object::transfer(&obj_signer, object, signer::address_of(purchaser));
  object::delete(delete_ref); // Clean-up the listing object.

  aptos_account::deposit_coins(seller, coins);
}
```

é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’è§£èª¬ã—ã¦ã„ãã¾ã™ã€‚

```rs
assert!(exists<Listing>(listing_addr), error::not_found(ENO_LISTING));
assert!(exists<FixedPriceListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));
```

ã“ã“ã§ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ»ã‚¢ãƒ‰ãƒ¬ã‚¹ã« Listing ãŠã‚ˆã³ FixedPriceListing ãƒªã‚½ãƒ¼ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’ã€å­˜åœ¨ã™ã‚‹ãƒã‚¤ãƒ†ã‚£ãƒ–é–¢æ•°ã‚’ä½¿ã£ã¦ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚

```rs
let FixedPriceListing {
    price,
} = move_from<FixedPriceListing<CoinType>>(listing_addr);

// The listing has concluded, transfer the asset and delete the listing. Returns the seller
// for depositing any profit.
let coins = coin::withdraw<CoinType>(purchaser, price);
```

ã“ã“ã§ã¯ã€FixedPriceListingãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ä¸‹ï¼‰ã‹ã‚‰ç§»å‹•ã—ã€NFTã®ä¾¡æ ¼ã‚’æŠ½å‡ºã—ã¾ã™ã€‚æ¬¡ã«ã€coin::withdraw é–¢æ•°ã‚’ä½¿ã£ã¦è³¼å…¥è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä»£é‡‘åˆ†ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å¼•ãå‡ºã—ã¾ã™ã€‚

```rs
let Listing {
    object,
    seller, // get seller from Listing object
    delete_ref,
    extend_ref,
} = move_from<Listing>(listing_addr);
```

ã“ã“ã§ã¯ã€ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ãƒ»ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ»ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ä¸‹ï¼‰ã‹ã‚‰ç§»å‹•ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã‚»ãƒ©ãƒ¼ã€delete_refã€extend_refãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½å‡ºã—ã¦ã„ã¾ã™ã€‚æ¬¡ã®å‡¦ç†ã«å‚™ãˆã‚‹ãŸã‚ã§ã™ã­ã€‚

```rs
let obj_signer = object::generate_signer_for_extending(&extend_ref);
object::transfer(&obj_signer, object, signer::address_of(purchaser));
object::delete(delete_ref); // Clean-up the listing object.
```

ã“ã“ã§ã¯ã€NFTã‚’è²·ã„æ‰‹ã«è­²æ¸¡ã—ã€Listingã¨FixedPriceListingãƒªã‚½ãƒ¼ã‚¹ã‚’å«ã‚€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€extend_refã‚’ä½¿ç”¨ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç½²åè€…ã‚’ç”Ÿæˆã—ã€ã‚¨ã‚¹ã‚¯ãƒ­ãƒ¼ã•ã‚ŒãŸNFTã‚’è²·ã„æ‰‹ã«è­²æ¸¡ã—ã¦ã„ã¾ã™ã€‚

```rs
aptos_account::deposit_coins(seller, coins);
```

æœ€å¾Œã«aptos_account::deposit_coinsé–¢æ•°ã‚’ä½¿ç”¨ã—ã¦NFTã®è²©å£²è€…ã«æ”¯æ‰•ã„ã‚’é€é‡‘ã—ã¾ã™ã€‚

Moveè¨€èªã«ã‚ˆã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…æ–¹æ³•ã«ã¤ã„ã¦ã•ã‚‰ã«çŸ¥ã‚ŠãŸã„äººã¯ä¸‹è¨˜ãƒªãƒ³ã‚¯ã‚’å‚ç…§ã—ã¦ãã ã•ã„ï¼ï¼

https://aptos.dev/move/book/functions/

ã“ã“ã¾ã§ã§ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯å…¨ä½“ã§ä»¥ä¸‹ã®æ§˜ãªå®Ÿè£…ã«ãªã‚Šã¾ã™ã€‚

```rs
module marketplace::list_and_purchase {
    use std::error;
    use std::signer;
    use std::option::{Self, Option};
    use aptos_std::smart_vector;
    use aptos_std::smart_vector::SmartVector;

    use aptos_framework::aptos_account;
    use aptos_framework::coin;
    use aptos_framework::object::{Self, DeleteRef, ExtendRef, Object, ObjectCore};

    #[test_only]
    friend marketplace::test_list_and_purchase;

    const APP_OBJECT_SEED: vector<u8> = b"MARKETPLACE";

    /// There exists no listing.
    const ENO_LISTING: u64 = 1;
    /// There exists no seller.
    const ENO_SELLER: u64 = 2;

    // Core data structures

    struct MarketplaceSigner has key {
        extend_ref: ExtendRef,
    }

    // In production we should use off-chain indexer to store all sellers instead of storing them on-chain.
    // Storing it on-chain is costly since it's O(N) to remove a seller.
    struct Sellers has key {
        /// All addresses of sellers.
        addresses: SmartVector<address>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Listing has key {
        /// The item owned by this listing, transferred to the new owner at the end.
        object: Object<ObjectCore>,
        /// The seller of the object.
        seller: address,
        /// Used to clean-up at the end.
        delete_ref: DeleteRef,
        /// Used to create a signer to transfer the listed item, ideally the TransferRef would support this.
        extend_ref: ExtendRef,
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FixedPriceListing<phantom CoinType> has key {
        /// The price to purchase the item up for listing.
        price: u64,
    }

    // In production we should use off-chain indexer to store the listings of a seller instead of storing it on-chain.
    // Storing it on-chain is costly since it's O(N) to remove a listing.
    struct SellerListings has key {
        /// All object addresses of listings the user has created.
        listings: SmartVector<address>
    }

    // Functions

    // This function is only called once when the module is published for the first time.
    fun init_module(deployer: &signer) {
        let constructor_ref = object::create_named_object(
            deployer,
            APP_OBJECT_SEED,
        );
        let extend_ref = object::generate_extend_ref(&constructor_ref);
        let marketplace_signer = &object::generate_signer(&constructor_ref);

        move_to(marketplace_signer, MarketplaceSigner {
            extend_ref,
        });
    }

    public fun get_marketplace_signer_addr(): address {
        object::create_object_address(&@marketplace, APP_OBJECT_SEED)
    }

    public fun get_marketplace_signer(marketplace_signer_addr: address): signer acquires MarketplaceSigner {
        object::generate_signer_for_extending(&borrow_global<MarketplaceSigner>(marketplace_signer_addr).extend_ref)
    }

    /// List an time for sale at a fixed price.
    public entry fun list_with_fixed_price<CoinType>(
        seller: &signer,
        object: Object<ObjectCore>,
        price: u64,
    ) acquires SellerListings, Sellers, MarketplaceSigner {
        list_with_fixed_price_internal<CoinType>(seller, object, price);
    }

    public(friend) fun list_with_fixed_price_internal<CoinType>(
        seller: &signer,
        object: Object<ObjectCore>,
        price: u64,        
    ): Object<Listing> acquires SellerListings, Sellers, MarketplaceSigner {
        let constructor_ref = object::create_object(signer::address_of(seller));

        let transfer_ref = object::generate_transfer_ref(&constructor_ref);
        object::disable_ungated_transfer(&transfer_ref);

        let listing_signer = object::generate_signer(&constructor_ref);

        let listing = Listing {
            object,
            seller: signer::address_of(seller),
            delete_ref: object::generate_delete_ref(&constructor_ref),
            extend_ref: object::generate_extend_ref(&constructor_ref),
        };
        let fixed_price_listing = FixedPriceListing<CoinType> {
            price,
        };
        move_to(&listing_signer, listing);
        move_to(&listing_signer, fixed_price_listing);

        object::transfer(seller, object, signer::address_of(&listing_signer));

        let listing = object::object_from_constructor_ref(&constructor_ref);

        if (exists<SellerListings>(signer::address_of(seller))) {
            let seller_listings = borrow_global_mut<SellerListings>(signer::address_of(seller));
            smart_vector::push_back(&mut seller_listings.listings, object::object_address(&listing));
        } else {
            let seller_listings = SellerListings {
                listings: smart_vector::new(),
            };
            smart_vector::push_back(&mut seller_listings.listings, object::object_address(&listing));
            move_to(seller, seller_listings);
        };
        if (exists<Sellers>(get_marketplace_signer_addr())) {
            let sellers = borrow_global_mut<Sellers>(get_marketplace_signer_addr());
            if (!smart_vector::contains(&sellers.addresses, &signer::address_of(seller))) {
                smart_vector::push_back(&mut sellers.addresses, signer::address_of(seller));
            }
        } else {
            let sellers = Sellers {
                addresses: smart_vector::new(),
            };
            smart_vector::push_back(&mut sellers.addresses, signer::address_of(seller));
            move_to(&get_marketplace_signer(get_marketplace_signer_addr()), sellers);
        };

        listing
    }

    /// Purchase outright an item from a fixed price listing.
    public entry fun purchase<CoinType>(
        purchaser: &signer,
        object: Object<ObjectCore>,
    ) acquires FixedPriceListing, Listing, SellerListings, Sellers {
        let listing_addr = object::object_address(&object);
        
        assert!(exists<Listing>(listing_addr), error::not_found(ENO_LISTING));
        assert!(exists<FixedPriceListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));

        let FixedPriceListing {
            price,
        } = move_from<FixedPriceListing<CoinType>>(listing_addr);

        // The listing has concluded, transfer the asset and delete the listing. Returns the seller
        // for depositing any profit.

        let coins = coin::withdraw<CoinType>(purchaser, price);

        let Listing {
            object,
            seller, // get seller from Listing object
            delete_ref,
            extend_ref,
        } = move_from<Listing>(listing_addr);

        let obj_signer = object::generate_signer_for_extending(&extend_ref);
        object::transfer(&obj_signer, object, signer::address_of(purchaser));
        object::delete(delete_ref); // Clean-up the listing object.

        // Note this step of removing the listing from the seller's listings will be costly since it's O(N).
        // Ideally you don't store the listings in a vector but in an off-chain indexer
        let seller_listings = borrow_global_mut<SellerListings>(seller);
        let (exist, idx) = smart_vector::index_of(&seller_listings.listings, &listing_addr);
        assert!(exist, error::not_found(ENO_LISTING));
        smart_vector::remove(&mut seller_listings.listings, idx);

        if (smart_vector::length(&seller_listings.listings) == 0) {
            // If the seller has no more listings, remove the seller from the marketplace.
            let sellers = borrow_global_mut<Sellers>(get_marketplace_signer_addr());
            let (exist, idx) = smart_vector::index_of(&sellers.addresses, &seller);
            assert!(exist, error::not_found(ENO_SELLER));
            smart_vector::remove(&mut sellers.addresses, idx);
        };

        aptos_account::deposit_coins(seller, coins);
    }
}

```

# ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…ã—ã‚ˆã†ï¼ï¼

ã•ãã“ã“ã¾ã§ã§ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®å®Ÿè£…ãŒå®Œäº†ã—ã¾ã—ãŸï¼ï¼

ã“ã“ã‹ã‚‰ã¯ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒæƒ³å®šã—ãŸé€šã‚Šã«æŒ™å‹•ã™ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ï¼ï¼

## å‰æº–å‚™

ã¾ãšãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã™ã‚‹å‰ã«ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚„Viewãƒ¡ã‚½ãƒƒãƒ‰ãªã©ã‚’ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«è¿½åŠ ã—ã¦ã„ãã¾ã™ï¼

è¿½åŠ ã™ã‚‹ã®ã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚

- ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰  
  - borrow_listing

    ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

    ```rs
    inline fun borrow_listing(object: Object<Listing>): &Listing acquires Listing {
	      let obj_addr = object::object_address(&object);
				assert!(exists<Listing>(obj_addr), error::not_found(ENO_LISTING));
	      borrow_global<Listing>(obj_addr)
    }
    ```

    ã“ã‚Œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã® Listing ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å€Ÿç”¨ã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã§ã™ã€‚ã¾ãŸã€æä¾›ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹å†…ã«ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ãƒªã‚½ãƒ¼ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚‚ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚

- Viewãƒ¡ã‚½ãƒƒãƒ‰  
  - price  

    ä»¥ä¸‹ã‚’è¿½åŠ ã—ã¾ã™ã€‚

    ```rs
    #[view]
    public fun price<CoinType>(
        object: Object<Listing>,
    ): Option<u64> acquires FixedPriceListing {
        let listing_addr = object::object_address(&object);
        if (exists<FixedPriceListing<CoinType>>(listing_addr)) {
            let fixed_price = borrow_global<FixedPriceListing<CoinType>>(listing_addr);
            option::some(fixed_price.price)
        } else {
            // This should just be an abort but the compiler errors.
            assert!(false, error::not_found(ENO_LISTING));
            option::none()
        }
    }
    ```

    ã“ã‚Œã¯ã€Listingã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ FixedPriceListing ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹priceã®å€¤ã‚’èª­ã¿å–ã‚‹é–¢æ•°ã§ã™ã€‚

  - listed_object  

    ä»¥ä¸‹ã‚’è¿½åŠ ã—ã¾ã™ã€‚

    ```rs
    #[view]
    public fun listed_object(object: Object<Listing>): Object<ObjectCore> acquires Listing {
        let listing = borrow_listing(object);
        listing.object
    }
    ```

    ã“ã‚Œã¯ã€Listingã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã€ãƒªã‚¹ãƒˆã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã™ã‚‹é–¢æ•°ã§ã™ã€‚


- ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰  
  - fixed_price_listing  

    ä»¥ä¸‹ã‚’è¿½åŠ ã—ã¾ã™ã€‚

    ```rs
    inline fun fixed_price_listing(
        seller: &signer,
        price: u64
    ): (Object<Token>, Object<Listing>) {
        let token = test_utils::mint_tokenv2(seller);
        fixed_price_listing_with_token(seller, token, price)
    }
    ```

  - fixed_price_listing_with_token  

    ä»¥ä¸‹ã‚’è¿½åŠ ã—ã¾ã™ã€‚

    ```rs
    inline fun fixed_price_listing_with_token(
        seller: &signer,
        token: Object<Token>,
        price: u64
    ): (Object<Token>, Object<Listing>) {
        let listing = list_and_purchase::list_with_fixed_price_internal<AptosCoin>(
            seller,
            object::convert(token), // Object<Token> -> Object<ObjectCore>
            price,
        );
        (token, listing)
    }
    ```

    ã“ã®é–¢æ•°ã¯ list_with_fixed_price ã‚¨ãƒ³ãƒˆãƒªãƒ¼é–¢æ•°ã®å¾Œã‚ã«ä½ç½®ã—ã€ãƒªã‚¹ãƒ†ã‚£ãƒ³ã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è©•ä¾¡ã¨ãƒ†ã‚¹ãƒˆã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚

    test_utils::mint_tokenv2ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã“ã®å¾Œå®Ÿè£…ã—ã¾ã™ã€‚

## ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰å®Ÿè£…

è¿½åŠ ã§å®Ÿè£…ãŒå¿…è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãŸã®ã§ã„ã‚ˆã„ã‚ˆãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚

ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’æ›¸ã„ã¦ã„ãå‰ã«ãƒ†ã‚¹ãƒˆå°‚ç”¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

`test_utils.move`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚

ã¾ãšã¯å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨setUpãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚

```rs
#[test_only]
module marketplace::test_utils {
	use std::signer;
	use std::string;
	use std::vector;
	use aptos_framework::account;
	use aptos_framework::aptos_coin::{Self, AptosCoin};
	use aptos_framework::coin;
	use aptos_framework::object::{Self, Object};
	use aptos_token_objects::token::Token;
	use aptos_token_objects::aptos_token;
	use aptos_token_objects::collection::Collection;

	public inline fun setup(
    aptos_framework: &signer,
    marketplace: &signer,
    seller: &signer,
    purchaser: &signer,
	): (address, address, address) {
    let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);

    let marketplace_addr = signer::address_of(marketplace);
    account::create_account_for_test(marketplace_addr);
    coin::register<AptosCoin>(marketplace);

    let seller_addr = signer::address_of(seller);
    account::create_account_for_test(seller_addr);
    coin::register<AptosCoin>(seller);

    let purchaser_addr = signer::address_of(purchaser);
    account::create_account_for_test(purchaser_addr);
    coin::register<AptosCoin>(purchaser);

    let coins = coin::mint(10000, &mint_cap);
    coin::deposit(seller_addr, coins);
    let coins = coin::mint(10000, &mint_cap);
    coin::deposit(purchaser_addr, coins);

    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);

    (marketplace_addr, seller_addr, purchaser_addr)
  }
}
```

ã“ã®setUpãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ãƒ†ã‚¹ãƒˆã«å¿…è¦ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚„ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®è¨­å®šã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚


æ¬¡ã«ãƒ†ã‚¹ãƒˆç”¨ã®NFTã‚’ç”Ÿæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¦ã„ãã¾ã™ï¼ï¼

```rs
public fun mint_tokenv2_with_collection(seller: &signer): (Object<Collection>, Object<Token>) {
    let collection_name = string::utf8(b"collection_name");

    let collection_object = aptos_token::create_collection_object(
        seller,
        string::utf8(b"collection description"),
        2,
        collection_name,
        string::utf8(b"collection uri"),
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        1,
        100,
    );

    let aptos_token = aptos_token::mint_token_object(
        seller,
        collection_name,
        string::utf8(b"description"),
        string::utf8(b"token_name"),
        string::utf8(b"uri"),
        vector::empty(),
        vector::empty(),
        vector::empty(),
    );
    (object::convert(collection_object), object::convert(aptos_token))
}

public fun mint_tokenv2(seller: &signer): Object<Token> {
    let (_collection, token) = mint_tokenv2_with_collection(seller);
    token
}
```

ã“ã“ã¾ã§ã§ `test_utils.move`ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä»¥ä¸‹ã®æ§˜ã«ãªã£ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚

```rs
#[test_only]
module marketplace::test_utils {
    use std::signer;
    use std::string;
    use std::vector;

    use aptos_framework::account;
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::coin;
    use aptos_framework::object::{Self, Object};

    use aptos_token_objects::token::Token;
    use aptos_token_objects::aptos_token;
    use aptos_token_objects::collection::Collection;
    use marketplace::list_and_purchase;

    public inline fun setup(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ): (address, address, address) {
        list_and_purchase::setup_test(marketplace);
        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);

        let marketplace_addr = signer::address_of(marketplace);
        account::create_account_for_test(marketplace_addr);
        coin::register<AptosCoin>(marketplace);

        let seller_addr = signer::address_of(seller);
        account::create_account_for_test(seller_addr);
        coin::register<AptosCoin>(seller);

        let purchaser_addr = signer::address_of(purchaser);
        account::create_account_for_test(purchaser_addr);
        coin::register<AptosCoin>(purchaser);

        let coins = coin::mint(10000, &mint_cap);
        coin::deposit(seller_addr, coins);
        let coins = coin::mint(10000, &mint_cap);
        coin::deposit(purchaser_addr, coins);

        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);

        (marketplace_addr, seller_addr, purchaser_addr)
    }

    public fun mint_tokenv2_with_collection(seller: &signer): (Object<Collection>, Object<Token>) {
        let collection_name = string::utf8(b"collection_name");

        let collection_object = aptos_token::create_collection_object(
            seller,
            string::utf8(b"collection description"),
            2,
            collection_name,
            string::utf8(b"collection uri"),
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            1,
            100,
        );

        let aptos_token = aptos_token::mint_token_object(
            seller,
            collection_name,
            string::utf8(b"description"),
            string::utf8(b"token_name"),
            string::utf8(b"uri"),
            vector::empty(),
            vector::empty(),
            vector::empty(),
        );
        (object::convert(collection_object), object::convert(aptos_token))
    }

    public fun mint_tokenv2(seller: &signer): Object<Token> {
        let (_collection, token) = mint_tokenv2_with_collection(seller);
        token
    }
}
```

ãƒ†ã‚¹ãƒˆã®ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ãŸã®ã§ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚

```rs
#[test_only]
module marketplace::test_list_and_purchase {
  use std::option;
  use aptos_framework::aptos_coin::AptosCoin;
  use aptos_framework::coin;
  use aptos_framework::object::{Self, Object, ObjectCore};
  use aptos_token_objects::token::Token;
  use marketplace::list_and_purchase::{Self, Listing};
  use marketplace::test_utils;

  // Test that a fixed price listing can be created and purchased.
  #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
  fun test_fixed_price(
      aptos_framework: &signer,
      marketplace: &signer,
      seller: &signer,
      purchaser: &signer,
  ) {
      let (_marketplace_addr, seller_addr, purchaser_addr) =
          test_utils::setup(aptos_framework, marketplace, seller, purchaser);

      let (token, listing) = fixed_price_listing(seller, 500); // price: 500

      assert!(list_and_purchase::listed_object(listing) == object::convert(token), 0); // The token is listed.
      assert!(list_and_purchase::price<AptosCoin>(listing) == option::some(500), 0); // The price is 500.
      assert!(object::owner(token) == object::object_address(&listing), 0); // The token is owned by the listing object. (escrowed)

      list_and_purchase::purchase<AptosCoin>(purchaser, object::convert(listing));

      assert!(object::owner(token) == purchaser_addr, 0); // The token has been transferred to the purchaser.
      assert!(coin::balance<AptosCoin>(seller_addr) == 10500, 0); // The seller has been paid.
      assert!(coin::balance<AptosCoin>(purchaser_addr) == 9500, 0); // The purchaser has paid.
  }
}
```

ã“ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã§ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ãŒæ­£ã—ãå–å¼•ã•ã‚Œã¦æƒ³å®šã—ãŸé€šã‚Šã«ownerã‚„æ®‹é«˜ãŒå¤‰ã‚ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚

```rs
// Test that the purchase fails if the purchaser does not have enough coin.
#[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
#[expected_failure(abort_code = 0x10006, location = aptos_framework::coin)]
fun test_not_enough_coin_fixed_price(
    aptos_framework: &signer,
    marketplace: &signer,
    seller: &signer,
    purchaser: &signer,
) {
    test_utils::setup(aptos_framework, marketplace, seller, purchaser);

    let (_token, listing) = fixed_price_listing(seller, 100000); // price: 100000

    list_and_purchase::purchase<AptosCoin>(purchaser, object::convert(listing));
}
```

è³¼å…¥ã™ã‚‹ãŸã‚ã«ååˆ†ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŒã£ã¦ã„ãªã‹ã£ãŸå ´åˆã«å¤±æ•—ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚

```rs
// Test that the purchase fails if the listing object does not exist.
#[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
#[expected_failure(abort_code = 0x60001, location = marketplace::list_and_purchase)]
fun test_no_listing(
  aptos_framework: &signer,
  marketplace: &signer,
  seller: &signer,
  purchaser: &signer,
) {
  let (_, seller_addr, _) = test_utils::setup(aptos_framework, marketplace, seller, purchaser);

  let dummy_constructor_ref = object::create_object(seller_addr);
  let dummy_object = object::object_from_constructor_ref<ObjectCore>(&dummy_constructor_ref);

  list_and_purchase::purchase<AptosCoin>(purchaser, object::convert(dummy_object));
}
```

å­˜åœ¨ã—ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¼•ã—ã‚ˆã†ã¨ã—ãŸã¨ãã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚

ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®å®Ÿè£…ã¯ã“ã“ã¾ã§ã§ã™ï¼ï¼

æœ€çµ‚çš„ã«ã¯ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼ï¼

```rs
module marketplace::list_and_purchase {
    use std::error;
    use std::signer;
    use std::option::{Self, Option};
    use aptos_std::smart_vector;
    use aptos_std::smart_vector::SmartVector;

    use aptos_framework::aptos_account;
    use aptos_framework::coin;
    use aptos_framework::object::{Self, DeleteRef, ExtendRef, Object, ObjectCore};

    #[test_only]
    friend marketplace::test_list_and_purchase;

    const APP_OBJECT_SEED: vector<u8> = b"MARKETPLACE";

    /// There exists no listing.
    const ENO_LISTING: u64 = 1;
    /// There exists no seller.
    const ENO_SELLER: u64 = 2;

    // Core data structures

    struct MarketplaceSigner has key {
        extend_ref: ExtendRef,
    }

    // In production we should use off-chain indexer to store all sellers instead of storing them on-chain.
    // Storing it on-chain is costly since it's O(N) to remove a seller.
    struct Sellers has key {
        /// All addresses of sellers.
        addresses: SmartVector<address>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Listing has key {
        /// The item owned by this listing, transferred to the new owner at the end.
        object: Object<ObjectCore>,
        /// The seller of the object.
        seller: address,
        /// Used to clean-up at the end.
        delete_ref: DeleteRef,
        /// Used to create a signer to transfer the listed item, ideally the TransferRef would support this.
        extend_ref: ExtendRef,
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FixedPriceListing<phantom CoinType> has key {
        /// The price to purchase the item up for listing.
        price: u64,
    }

    // In production we should use off-chain indexer to store the listings of a seller instead of storing it on-chain.
    // Storing it on-chain is costly since it's O(N) to remove a listing.
    struct SellerListings has key {
        /// All object addresses of listings the user has created.
        listings: SmartVector<address>
    }

    // Functions

    // This function is only called once when the module is published for the first time.
    fun init_module(deployer: &signer) {
        let constructor_ref = object::create_named_object(
            deployer,
            APP_OBJECT_SEED,
        );
        let extend_ref = object::generate_extend_ref(&constructor_ref);
        let marketplace_signer = &object::generate_signer(&constructor_ref);

        move_to(marketplace_signer, MarketplaceSigner {
            extend_ref,
        });
    }

    public fun get_marketplace_signer_addr(): address {
        object::create_object_address(&@marketplace, APP_OBJECT_SEED)
    }

    public fun get_marketplace_signer(marketplace_signer_addr: address): signer acquires MarketplaceSigner {
        object::generate_signer_for_extending(&borrow_global<MarketplaceSigner>(marketplace_signer_addr).extend_ref)
    }

    /// List an time for sale at a fixed price.
    public entry fun list_with_fixed_price<CoinType>(
        seller: &signer,
        object: Object<ObjectCore>,
        price: u64,
    ) acquires SellerListings, Sellers, MarketplaceSigner {
        list_with_fixed_price_internal<CoinType>(seller, object, price);
    }

    public(friend) fun list_with_fixed_price_internal<CoinType>(
        seller: &signer,
        object: Object<ObjectCore>,
        price: u64,        
    ): Object<Listing> acquires SellerListings, Sellers, MarketplaceSigner {
        let constructor_ref = object::create_object(signer::address_of(seller));

        let transfer_ref = object::generate_transfer_ref(&constructor_ref);
        object::disable_ungated_transfer(&transfer_ref);

        let listing_signer = object::generate_signer(&constructor_ref);

        let listing = Listing {
            object,
            seller: signer::address_of(seller),
            delete_ref: object::generate_delete_ref(&constructor_ref),
            extend_ref: object::generate_extend_ref(&constructor_ref),
        };
        let fixed_price_listing = FixedPriceListing<CoinType> {
            price,
        };
        move_to(&listing_signer, listing);
        move_to(&listing_signer, fixed_price_listing);

        object::transfer(seller, object, signer::address_of(&listing_signer));

        let listing = object::object_from_constructor_ref(&constructor_ref);

        if (exists<SellerListings>(signer::address_of(seller))) {
            let seller_listings = borrow_global_mut<SellerListings>(signer::address_of(seller));
            smart_vector::push_back(&mut seller_listings.listings, object::object_address(&listing));
        } else {
            let seller_listings = SellerListings {
                listings: smart_vector::new(),
            };
            smart_vector::push_back(&mut seller_listings.listings, object::object_address(&listing));
            move_to(seller, seller_listings);
        };
        if (exists<Sellers>(get_marketplace_signer_addr())) {
            let sellers = borrow_global_mut<Sellers>(get_marketplace_signer_addr());
            if (!smart_vector::contains(&sellers.addresses, &signer::address_of(seller))) {
                smart_vector::push_back(&mut sellers.addresses, signer::address_of(seller));
            }
        } else {
            let sellers = Sellers {
                addresses: smart_vector::new(),
            };
            smart_vector::push_back(&mut sellers.addresses, signer::address_of(seller));
            move_to(&get_marketplace_signer(get_marketplace_signer_addr()), sellers);
        };

        listing
    }

    /// Purchase outright an item from a fixed price listing.
    public entry fun purchase<CoinType>(
        purchaser: &signer,
        object: Object<ObjectCore>,
    ) acquires FixedPriceListing, Listing, SellerListings, Sellers {
        let listing_addr = object::object_address(&object);
        
        assert!(exists<Listing>(listing_addr), error::not_found(ENO_LISTING));
        assert!(exists<FixedPriceListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));

        let FixedPriceListing {
            price,
        } = move_from<FixedPriceListing<CoinType>>(listing_addr);

        // The listing has concluded, transfer the asset and delete the listing. Returns the seller
        // for depositing any profit.

        let coins = coin::withdraw<CoinType>(purchaser, price);

        let Listing {
            object,
            seller, // get seller from Listing object
            delete_ref,
            extend_ref,
        } = move_from<Listing>(listing_addr);

        let obj_signer = object::generate_signer_for_extending(&extend_ref);
        object::transfer(&obj_signer, object, signer::address_of(purchaser));
        object::delete(delete_ref); // Clean-up the listing object.

        // Note this step of removing the listing from the seller's listings will be costly since it's O(N).
        // Ideally you don't store the listings in a vector but in an off-chain indexer
        let seller_listings = borrow_global_mut<SellerListings>(seller);
        let (exist, idx) = smart_vector::index_of(&seller_listings.listings, &listing_addr);
        assert!(exist, error::not_found(ENO_LISTING));
        smart_vector::remove(&mut seller_listings.listings, idx);

        if (smart_vector::length(&seller_listings.listings) == 0) {
            // If the seller has no more listings, remove the seller from the marketplace.
            let sellers = borrow_global_mut<Sellers>(get_marketplace_signer_addr());
            let (exist, idx) = smart_vector::index_of(&sellers.addresses, &seller);
            assert!(exist, error::not_found(ENO_SELLER));
            smart_vector::remove(&mut sellers.addresses, idx);
        };

        aptos_account::deposit_coins(seller, coins);
    }

    // Helper functions

    inline fun borrow_listing(object: Object<Listing>): &Listing acquires Listing {
        let obj_addr = object::object_address(&object);
        assert!(exists<Listing>(obj_addr), error::not_found(ENO_LISTING));
        borrow_global<Listing>(obj_addr)
    }

    // View functions

    #[view]
    public fun price<CoinType>(
        object: Object<Listing>,
    ): Option<u64> acquires FixedPriceListing {
        let listing_addr = object::object_address(&object);
        if (exists<FixedPriceListing<CoinType>>(listing_addr)) {
            let fixed_price = borrow_global<FixedPriceListing<CoinType>>(listing_addr);
            option::some(fixed_price.price)
        } else {
            // This should just be an abort but the compiler errors.
            assert!(false, error::not_found(ENO_LISTING));
            option::none()
        }
    }

    #[view]
    public fun listing(object: Object<Listing>): (Object<ObjectCore>, address) acquires Listing {
        let listing = borrow_listing(object);
        (listing.object, listing.seller)
    }

    #[view]
    public fun get_seller_listings(seller: address): vector<address> acquires SellerListings {
        if (exists<SellerListings>(seller)) {
            smart_vector::to_vector(&borrow_global<SellerListings>(seller).listings)
        } else {
            vector[]
        }
    }

    #[view]
    public fun get_sellers(): vector<address> acquires Sellers {
        if (exists<Sellers>(get_marketplace_signer_addr())) {
            smart_vector::to_vector(&borrow_global<Sellers>(get_marketplace_signer_addr()).addresses)
        } else {
            vector[]
        }
    }

    #[test_only]
    public fun setup_test(marketplace: &signer) {
        init_module(marketplace);
    }
}


// Unit tests

#[test_only]
module marketplace::test_list_and_purchase {

    use std::option;

    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use aptos_framework::object::{Self, Object, ObjectCore};

    use aptos_token_objects::token::Token;

    use marketplace::list_and_purchase::{Self, Listing};
    use marketplace::test_utils;

    // Test that a fixed price listing can be created and purchased.
    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
    fun test_fixed_price(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ) {
        let (_marketplace_addr, seller_addr, purchaser_addr) =
            test_utils::setup(aptos_framework, marketplace, seller, purchaser);

        let (token, listing) = fixed_price_listing(seller, 500); // price: 500

        let (listing_obj, seller_addr2) = list_and_purchase::listing(listing);
        assert!(listing_obj == object::convert(token), 0); // The token is listed.
        assert!(seller_addr2 == seller_addr, 0); // The seller is the owner of the listing.
        assert!(list_and_purchase::price<AptosCoin>(listing) == option::some(500), 0); // The price is 500.
        assert!(object::owner(token) == object::object_address(&listing), 0); // The token is owned by the listing object. (escrowed)

        list_and_purchase::purchase<AptosCoin>(purchaser, object::convert(listing));

        assert!(object::owner(token) == purchaser_addr, 0); // The token has been transferred to the purchaser.
        assert!(coin::balance<AptosCoin>(seller_addr) == 10500, 0); // The seller has been paid.
        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9500, 0); // The purchaser has paid.
    }

    // Test that the purchase fails if the purchaser does not have enough coin.
    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
    #[expected_failure(abort_code = 0x10006, location = aptos_framework::coin)]
    fun test_not_enough_coin_fixed_price(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ) {
        test_utils::setup(aptos_framework, marketplace, seller, purchaser);

        let (_token, listing) = fixed_price_listing(seller, 100000); // price: 100000

        list_and_purchase::purchase<AptosCoin>(purchaser, object::convert(listing));
    }

    // Test that the purchase fails if the listing object does not exist.
    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
    #[expected_failure(abort_code = 0x60001, location = marketplace::list_and_purchase)]
    fun test_no_listing(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ) {
        let (_, seller_addr, _) = test_utils::setup(aptos_framework, marketplace, seller, purchaser);

        let dummy_constructor_ref = object::create_object(seller_addr);
        let dummy_object = object::object_from_constructor_ref<ObjectCore>(&dummy_constructor_ref);

        list_and_purchase::purchase<AptosCoin>(purchaser, object::convert(dummy_object));
    }


    inline fun fixed_price_listing(
        seller: &signer,
        price: u64
    ): (Object<Token>, Object<Listing>) {
        let token = test_utils::mint_tokenv2(seller);
        fixed_price_listing_with_token(seller, token, price)
    }

    inline fun fixed_price_listing_with_token(
        seller: &signer,
        token: Object<Token>,
        price: u64
    ): (Object<Token>, Object<Listing>) {
        let listing = list_and_purchase::list_with_fixed_price_internal<AptosCoin>(
            seller,
            object::convert(token), // Object<Token> -> Object<ObjectCore>
            price,
        );
        (token, listing)
    }
}
``` 

å®Ÿè£…ã¯ã“ã“ã¾ã§ã§ã™ï¼ï¼

## ãƒ“ãƒ«ãƒ‰ï¼†ãƒ‡ãƒ—ãƒ­ã‚¤

ã§ã¯ã“ã“ã‹ã‚‰ã¯å®Ÿéš›ã«å‹•ã‹ã—ãŸæ™‚ã®è¨˜éŒ²ã‚’ã¾ã¨ã‚ã¦ã„ãã¾ã™ï¼ï¼

ã¾ãšåˆæœŸåŒ–ã—ã¾ã™ã€‚

```bash
aptos init --profile mashharuki
```

Move.tomlãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¬¡ã®ã‚ˆã†ã«è¨­å®šã—ã¾ã™ã€‚

[addresses]ã¨[dev-addresses]ã«è¨­å®šã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ãŒã€åˆæœŸåŒ–ã—ãŸéš›ã«ç”Ÿæˆã•ã‚Œã‚‹`.aptos`ãƒ•ã‚©ãƒ«ãƒ€é…ä¸‹ã®`config.yaml`ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹å€¤ã‚’ã‚»ãƒƒãƒˆã—ã¾ã™ï¼ï¼

```toml
[package]
name = "marketplace"
version = "1.0.0"
authors = []

[addresses]
marketplace = "0x9324da379576a6210929ee2611cd1995a21451d0be44ec92a92d17cae1d665ee"

[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"

[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"


[dev-dependencies]
```

æº–å‚™ãŒæ•´ã£ãŸã®ã§ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã¾ã™ï¼ï¼

```bash
aptos move compile --named-addresses marketplace=mashharuki
```

ä»¥ä¸‹ã®æ§˜ã«ãªã‚Œã°ãƒ“ãƒ«ãƒ‰æˆåŠŸã§ã™ï¼ï¼

```bash 
Compiling, may take a little while to download git dependencies...
FETCHING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY AptosTokenObjects
INCLUDING DEPENDENCY MoveStdlib
BUILDING marketplace
{
  "Result": [
    "9324da379576a6210929ee2611cd1995a21451d0be44ec92a92d17cae1d665ee::list_and_purchase"
  ]
}
```

ã§ã¯ãƒ†ã‚¹ãƒˆã‚‚å®Ÿè¡Œã—ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã™ï¼ï¼ï¼

```bash
aptos move test
```

å…¨ã¦PASSã™ã‚Œã°æˆåŠŸãªã®ã§ã™ãŒã€2024å¹´3æœˆ24æ—¥æ™‚ç‚¹ã§ã¯ãƒ†ã‚¹ãƒˆå°‚ç”¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ã£ã¦ã„ã‚‹ä¸€éƒ¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒã‚°ãŒèµ·ãã‚‹ã¿ãŸã„ã§ã™ã€‚

é–¢é€£ã™ã‚‹GitHubã®Issueã‚’å…±æœ‰ã—ã¾ã™ã€‚

https://github.com/aptos-labs/aptos-core/issues/12505

ãƒ†ã‚¹ãƒˆãŒçµ‚ã‚ã£ãŸã‚‰ã„ã‚ˆã„ã‚ˆãƒ‡ãƒ—ãƒ­ã‚¤ã§ã™ï¼ï¼

```bash
aptos move publish --named-addresses marketplace=mashharuki --profile=mashharuki
```

ä»¥ä¸‹ã®æ§˜ã«ãªã‚Œã°æˆåŠŸã§ã™ï¼ï¼

```bash
Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY AptosTokenObjects
INCLUDING DEPENDENCY MoveStdlib
BUILDING marketplace
package size 6151 bytes
Do you want to submit a transaction for a range of [388400 - 582600] Octas at a gas unit price of 100 Octas? [yes/no] >
yes
{
  "Result": {
    "transaction_hash": "0x4daf30d0e1d785e4ca490d044c852655509875e22b15ea1206ba3ed564af16c5",
    "gas_used": 3884,
    "gas_unit_price": 100,
    "sender": "9324da379576a6210929ee2611cd1995a21451d0be44ec92a92d17cae1d665ee",
    "sequence_number": 25,
    "success": true,
    "timestamp_us": 1711272405479454,
    "version": 981827343,
    "vm_status": "Executed successfully"
  }
}
```

Aptos Explorerã§ã‚‚ç¢ºèªãŒã§ãã¾ã™ï¼ï¼

https://explorer.aptoslabs.com/txn/0x4daf30d0e1d785e4ca490d044c852655509875e22b15ea1206ba3ed564af16c5?network=testnet

â†“ ã“ã¡ã‚‰ã§ã¯ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ãŒç¢ºèªã§ãã¾ã™ï¼ï¼

https://explorer.aptoslabs.com/account/0x9324da379576a6210929ee2611cd1995a21451d0be44ec92a92d17cae1d665ee/modules/code/list_and_purchase?network=testnet


ç„¡äº‹ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã¾ã§ã§ãã¾ã—ãŸï¼ï¼ï¼

# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®å®Ÿè£…

ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒç„¡äº‹ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã§ããŸã“ã¨ã‚’ç¢ºèªã§ããŸã‚‰æ¬¡ã«ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®å®Ÿè£…ã‚’ã¿ã¦ã„ãã¾ã—ã‚‡ã†ï¼ï¼

`Next.js`ã§æ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã™ã€‚å‰å›ã®è¨˜äº‹ã§å–ã‚Šä¸Šã’ã¦ã„ãŸãƒ•ãƒ­ãƒ³ãƒˆã®å®Ÿè£…ã¨ãƒ™ãƒ¼ã‚¹ã¯åŒã˜ã‚ˆã†ã§ã™ã­ã€‚

```bash
.
â”œâ”€â”€ README.md
â”œâ”€â”€ next.config.mjs
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ next.svg
â”‚Â Â  â”œâ”€â”€ pet-parts
â”‚Â Â  â””â”€â”€ vercel.svg
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app
â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â””â”€â”€ utils
â””â”€â”€ tsconfig.json
```

ãƒã‚¤ãƒ³ãƒˆã«ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸­å¿ƒã«ç¢ºèªã—ã¦ã„ãã¾ã™ã€‚

ã¾ãšã€`utils`é…ä¸‹ã®`aptos.ts`ã‹ã‚‰

```ts
import { Aptos, AptosConfig, Network, Account } from "@aptos-labs/ts-sdk";
import { Aptogotchi, AptogotchiTraits } from "./types";

export const APTOGOTCHI_CONTRACT_ADDRESS =
  "0x497c93ccd5d3c3e24a8226d320ecc9c69697c0dad5e1f195553d7eaa1140e91f";
export const COLLECTION_ID =
  "0xfce62045f3ac19160c1e88662682ccb6ef1173eba82638b8bae172cc83d8e8b8";
export const COLLECTION_CREATOR_ADDRESS =
  "0x714319fa1946db285254e3c7c75a9aac05277200e59429dd1f80f25272910d9c";
export const COLLECTION_NAME = "Aptogotchi Collection";
export const MARKETPLACE_CONTRACT_ADDRESS =
  "0xbf60e962f7e34a0c317cbcd9454a7125a1c3c3d15ec620688e0f357100284605";
export const APT = "0x1::aptos_coin::AptosCoin";
export const APT_UNIT = 100_000_000;

const config = new AptosConfig({
  network: Network.TESTNET,
});
export const aptos = new Aptos(config);

export const getAptogotchi = async (
  aptogotchiObjectAddr: string
): Promise<[string, AptogotchiTraits]> => {
  console.log("aptogotchiObjectAddr", aptogotchiObjectAddr);
  const aptogotchi = await aptos.view({
    payload: {
      function: `${APTOGOTCHI_CONTRACT_ADDRESS}::main::get_aptogotchi`,
      typeArguments: [],
      functionArguments: [aptogotchiObjectAddr],
    },
  });
  console.log(aptogotchi);
  return [aptogotchi[0] as string, aptogotchi[1] as AptogotchiTraits];
};

export const mintAptogotchi = async (
  sender: Account,
  name: string,
  body: number,
  ear: number,
  face: number
) => {
  const rawTxn = await aptos.transaction.build.simple({
    sender: sender.accountAddress,
    data: {
      function: `${APTOGOTCHI_CONTRACT_ADDRESS}::main::create_aptogotchi`,
      functionArguments: [name, body, ear, face],
    },
  });
  const pendingTxn = await aptos.signAndSubmitTransaction({
    signer: sender,
    transaction: rawTxn,
  });
  const response = await aptos.waitForTransaction({
    transactionHash: pendingTxn.hash,
  });
  console.log("minted aptogotchi. - ", response.hash);
};

export const getAptBalance = async (addr: string) => {
  const result = await aptos.getAccountCoinAmount({
    accountAddress: addr,
    coinType: APT,
  });

  console.log("APT balance", result);
  return result;
};

export const getCollection = async () => {
  // const collection = await aptos.getCollectionDataByCollectionId({
  //   collectionId: COLLECTION_ID,
  // });
  const collection = await aptos.getCollectionData({
    collectionName: COLLECTION_NAME,
    creatorAddress: COLLECTION_CREATOR_ADDRESS,
  });
  console.log("collection", collection);
  return collection;
};

export const getUserOwnedAptogotchis = async (ownerAddr: string) => {
  const result = await aptos.getAccountOwnedTokensFromCollectionAddress({
    accountAddress: ownerAddr,
    collectionAddress: COLLECTION_ID,
  });

  console.log("my aptogotchis", result);
  return result;
};

export const getAllAptogotchis = async () => {
  const result: {
    current_token_datas_v2: Aptogotchi[];
  } = await aptos.queryIndexer({
    query: {
      query: `
        query MyQuery($collectionId: String) {
          current_token_datas_v2(
            where: {collection_id: {_eq: $collectionId}}
          ) {
            name: token_name
            address: token_data_id
          }
        }
      `,
      variables: { collectionId: COLLECTION_ID },
    },
  });

  console.log("all aptogotchis", result.current_token_datas_v2);
  return result.current_token_datas_v2;
};

export const listAptogotchi = async (
  sender: Account,
  aptogotchiObjectAddr: string
) => {
  const rawTxn = await aptos.transaction.build.simple({
    sender: sender.accountAddress,
    data: {
      function: `${MARKETPLACE_CONTRACT_ADDRESS}::list_and_purchase::list_with_fixed_price`,
      typeArguments: [APT],
      functionArguments: [aptogotchiObjectAddr, 10],
    },
  });
  const pendingTxn = await aptos.signAndSubmitTransaction({
    signer: sender,
    transaction: rawTxn,
  });
  const response = await aptos.waitForTransaction({
    transactionHash: pendingTxn.hash,
  });
  console.log("listed aptogotchi. - ", response.hash);
};

export const buyAptogotchi = async (
  sender: Account,
  listingObjectAddr: string
) => {
  const rawTxn = await aptos.transaction.build.simple({
    sender: sender.accountAddress,
    data: {
      function: `${MARKETPLACE_CONTRACT_ADDRESS}::list_and_purchase::purchase`,
      typeArguments: [APT],
      functionArguments: [listingObjectAddr],
    },
  });
  const pendingTxn = await aptos.signAndSubmitTransaction({
    signer: sender,
    transaction: rawTxn,
  });
  const response = await aptos.waitForTransaction({
    transactionHash: pendingTxn.hash,
  });
  console.log("bought aptogotchi. - ", response.hash);
};

export const getAllListingObjectAddresses = async (sellerAddr: string) => {
  const allListings: [string[]] = await aptos.view({
    payload: {
      function: `${MARKETPLACE_CONTRACT_ADDRESS}::list_and_purchase::get_seller_listings`,
      typeArguments: [],
      functionArguments: [sellerAddr],
    },
  });
  console.log("all listings", allListings);
  return allListings[0];
};

export const getAllSellers = async () => {
  const allSellers: [string[]] = await aptos.view({
    payload: {
      function: `${MARKETPLACE_CONTRACT_ADDRESS}::list_and_purchase::get_sellers`,
      typeArguments: [],
      functionArguments: [],
    },
  });
  console.log("all sellers", allSellers);
  return allSellers[0];
};

export const getListingObjectAndSeller = async (
  listingObjectAddr: string
): Promise<[string, string]> => {
  const listingObjectAndSeller = await aptos.view({
    payload: {
      function: `${MARKETPLACE_CONTRACT_ADDRESS}::list_and_purchase::listing`,
      typeArguments: [],
      functionArguments: [listingObjectAddr],
    },
  });
  console.log("listing object and seller", listingObjectAndSeller);
  return [
    // @ts-ignore
    listingObjectAndSeller[0]["inner"] as string,
    listingObjectAndSeller[1] as string,
  ];
};

export const getListingObjectPrice = async (
  listingObjectAddr: string
): Promise<number> => {
  const listingObjectPrice = await aptos.view({
    payload: {
      function: `${MARKETPLACE_CONTRACT_ADDRESS}::list_and_purchase::price`,
      typeArguments: [APT],
      functionArguments: [listingObjectAddr],
    },
  });
  console.log("listing object price", JSON.stringify(listingObjectPrice));
  // @ts-ignore
  return (listingObjectPrice[0]["vec"] as number) / APT_UNIT;
};
```

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚„ã€Aptosã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€NFTã®ãƒŸãƒ³ãƒˆæ©Ÿèƒ½ã‚„NFTä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãªã©ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æ©Ÿèƒ½ã¨ç›´çµã—ãŸéƒ¨åˆ†ã®å®Ÿè£…ãŒã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å›ºã¾ã£ã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°ã€NFTã‚’ãƒŸãƒ³ãƒˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ `mintAptogotchi`ãƒ¡ã‚½ãƒƒãƒ‰ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

```ts
export const mintAptogotchi = async (
  sender: Account,
  name: string,
  body: number,
  ear: number,
  face: number
) => {
  const rawTxn = await aptos.transaction.build.simple({
    sender: sender.accountAddress,
    data: {
      function: `${APTOGOTCHI_CONTRACT_ADDRESS}::main::create_aptogotchi`,
      functionArguments: [name, body, ear, face],
    },
  });
  const pendingTxn = await aptos.signAndSubmitTransaction({
    signer: sender,
    transaction: rawTxn,
  });
  const response = await aptos.waitForTransaction({
    transactionHash: pendingTxn.hash,
  });
  console.log("minted aptogotchi. - ", response.hash);
};
```

ä»–ã«ã¯æ®‹é«˜ã‚’å–å¾—ã™ã‚‹`getAptBalance`ã‚„NFTä¸€è¦§ã‚’å–å¾—ã™ã‚‹`getCollection`ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚

```ts
export const getAptBalance = async (addr: string) => {
  const result = await aptos.getAccountCoinAmount({
    accountAddress: addr,
    coinType: APT,
  });

  console.log("APT balance", result);
  return result;
};
```

```ts
export const getCollection = async () => {
  // const collection = await aptos.getCollectionDataByCollectionId({
  //   collectionId: COLLECTION_ID,
  // });
  const collection = await aptos.getCollectionData({
    collectionName: COLLECTION_NAME,
    creatorAddress: COLLECTION_CREATOR_ADDRESS,
  });
  console.log("collection", collection);
  return collection;
};
```

ãƒ•ãƒ­ãƒ³ãƒˆã¨ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’æ¥ç¶šã™ã‚‹ãŸã‚ã®è¨­å®šã¯`WalletProvider.tsx`ã«ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ï¼ï¼

ã“ã“ã¯å‰å›ã¨åŒã˜ã§ã™ã­ï¼ï¼

```ts
"use client";

import { AptosWalletAdapterProvider } from "@aptos-labs/wallet-adapter-react";
import { PetraWallet } from "petra-plugin-wallet-adapter";
import { ReactNode } from "react";

const wallets = [new PetraWallet()];

export function WalletProvider({ children }: { children: ReactNode }) {
  return (
    <AptosWalletAdapterProvider plugins={wallets} autoConnect={true}>
      {children}
    </AptosWalletAdapterProvider>
  );
}
```

å®Ÿéš›ã«ãƒ•ãƒ­ãƒ³ãƒˆã¨ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã¨æ¥ç¶šã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯`WalletButton.tsx`ãƒ•ã‚¡ã‚¤ãƒ«ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã€‚

`@aptos-labs/wallet-adapter-react`ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

```ts
"use client";

import {
  useWallet,
  WalletReadyState,
  Wallet,
  isRedirectable,
  WalletName,
} from "@aptos-labs/wallet-adapter-react";
import { Button, Text } from "@chakra-ui/react";

export const WalletButtons = () => {
  const { wallets, connected, disconnect, isLoading } = useWallet();

  if (connected) {
    return <Button onClick={disconnect}>Disconnect</Button>;
  }

  if (isLoading || !wallets[0]) {
    return <Text>Loading...</Text>;
  }

  return <WalletView wallet={wallets[0]} />;
};

const WalletView = ({ wallet }: { wallet: Wallet }) => {
  const { connect } = useWallet();
  const isWalletReady =
    wallet.readyState === WalletReadyState.Installed ||
    wallet.readyState === WalletReadyState.Loadable;
  const mobileSupport = wallet.deeplinkProvider;

  const onWalletConnectRequest = async (walletName: WalletName) => {
    try {
      connect(walletName);
    } catch (error) {
      console.warn(error);
      window.alert("Failed to connect wallet");
    }
  };

  /**
   * If we are on a mobile browser, adapter checks whether a wallet has a `deeplinkProvider` property
   * a. If it does, on connect it should redirect the user to the app by using the wallet's deeplink url
   * b. If it does not, up to the dapp to choose on the UI, but can simply disable the button
   * c. If we are already in a in-app browser, we don't want to redirect anywhere, so connect should work as expected in the mobile app.
   *
   * !isWalletReady - ignore installed/sdk wallets that don't rely on window injection
   * isRedirectable() - are we on mobile AND not in an in-app browser
   * mobileSupport - does wallet have deeplinkProvider property? i.e does it support a mobile app
   */
  if (!isWalletReady && isRedirectable()) {
    // wallet has mobile app
    if (mobileSupport) {
      return (
        // <button
        //   className={cn(buttonStyles, "hover:bg-blue-700")}
        //   disabled={false}
        //   key={wallet.name}
        //   onClick={() => onWalletConnectRequest(wallet.name)}
        //   style={{ maxWidth: "300px" }}
        // >
        //   Connect Wallet
        // </button>
        <Button onClick={() => onWalletConnectRequest(wallet.name)}>
          Connect Wallet
        </Button>
      );
    }
    // wallet does not have mobile app
    return (
      // <button
      //   className={cn(buttonStyles, "opacity-50 cursor-not-allowed")}
      //   disabled={true}
      //   key={wallet.name}
      //   style={{ maxWidth: "300px" }}
      // >
      //   Connect Wallet - Desktop Only
      // </button>
      <Button isDisabled={true}>Connect Wallet - Desktop Only</Button>
    );
  } else {
    // desktop
    return (
      // <button
      //   className={cn(
      //     buttonStyles,
      //     isWalletReady ? "hover:bg-blue-700" : "opacity-50 cursor-not-allowed"
      //   )}
      //   disabled={!isWalletReady}
      //   key={wallet.name}
      //   onClick={() => onWalletConnectRequest(wallet.name)}
      //   style={{ maxWidth: "300px" }}
      // >
      //   Connect Wallet
      // </button>
      <Button
        isDisabled={!isWalletReady}
        onClick={() => onWalletConnectRequest(wallet.name)}
      >
        Connect Wallet
      </Button>
    );
  }
};
```

getterç³»ã®å‡¦ç†ã¯ä¸€éƒ¨hooksã—ã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°NFTã‚’ä¸€è¦§ã§å–å¾—ã™ã‚‹hookã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå®Ÿè£…ã«ãªã£ã¦ã„ã¾ã™ã€‚

```ts
import { getAllAptogotchis, getAptogotchi } from "@/utils/aptos";
import { AptogotchiWithTraits } from "@/utils/types";
import { useEffect, useState } from "react";

export const useGetAllNfts = () => {
  const [nfts, setNfts] = useState<AptogotchiWithTraits[]>();
  useEffect(() => {
    getAllAptogotchis().then(async (res) => {
      const aptogotchiWithTraits = [];
      for (const aptogotchi of res) {
        const [_, traits] = await getAptogotchi(aptogotchi.address);
        aptogotchiWithTraits.push({
          ...aptogotchi,
          ...traits,
        });
      }
      setNfts(aptogotchiWithTraits);
    });
  }, []);
  return nfts;
};
```

å£²ã‚Šã«å‡ºã—ãŸNFTã‚’å–å¾—ã™ã‚‹ãŸã‚ã®hookã®å®Ÿè£…ã¯ä»¥ä¸‹ã®æ§˜ã«ãªã£ã¦ã„ã¾ã™ã€‚

```ts
import {
  getAllListingObjectAddresses,
  getAptogotchi,
  getListingObjectAndSeller,
  getListingObjectPrice,
} from "@/utils/aptos";
import { ListedAptogotchiWithTraits } from "@/utils/types";
import { useEffect, useState } from "react";

export const useGetListedNftsBySeller = (sellerAddr: string) => {
  const [nfts, setNfts] = useState<ListedAptogotchiWithTraits[]>();
  useEffect(() => {
    getAllListingObjectAddresses(sellerAddr).then(
      async (listingObjectAddresses) => {
        const aptogotchiWithTraits = [];
        for (const listingObjectAddress of listingObjectAddresses) {
          const [nftAddress, sellerAddress] = await getListingObjectAndSeller(
            listingObjectAddress
          );
          const price = await getListingObjectPrice(listingObjectAddress);
          const [name, traits] = await getAptogotchi(nftAddress);
          aptogotchiWithTraits.push({
            name,
            address: nftAddress,
            ...traits,
            listing_object_address: listingObjectAddress,
            seller_address: sellerAddress,
            price,
          });
        }
        setNfts(aptogotchiWithTraits);
      }
    );
  }, [sellerAddr]);
  return nfts;
};
```

é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã¯ç¢ºèªã§ãã¾ã—ãŸï¼

ä»¥ä¸‹ã‚³ãƒãƒ³ãƒ‰ã§ãƒ“ãƒ«ãƒ‰ã—ã¾ã—ã‚‡ã†ï¼

```bash
pnpm run build
```

ãƒ“ãƒ«ãƒ‰ã§ããŸã‚‰ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã—ã¾ã™ã€‚

```bash
pnpm run dev
```

ã§ã¯æ“ä½œç”»é¢ã®ç¢ºèªã§ã™ã€‚

ã¾ãšã¯Homeç”»é¢ã§ã™ã€‚

![](/images/a9c7f813c75e8b/2.png)

ã“ã®ç”»é¢ã§ã¯å…¨ã¦ã®NFTã€å£²ã‚Šã«å‡ºã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®NFTãŒç¢ºèªã§ãã¾ã™ã€‚

å£²ã‚Šã«å‡ºã•ã‚Œã¦ã„ã‚‹NFTã¯è³¼å…¥ã™ã‚‹ã“ã¨ã§ãã¾ã™ã€‚

Mintç”»é¢ã§ã¯ã€NFTã‚’ãƒŸãƒ³ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ï¼

![](/images/a9c7f813c75e8b/3.png)

Mintã•ã‚ŒãŸNFTã¯MyPortfolioç”»é¢ã§ç¢ºèªã§ãã¾ã™ï¼ï¼

![](/images/a9c7f813c75e8b/4.png)

è‡ªåˆ†ã®NFTã¯ä»»æ„ã®ä¾¡æ ¼ã§NFTã‚’å£²ã‚Šã«å‡ºã™ã“ã¨ãŒã§ãã¾ã™ï¼ï¼

![](/images/a9c7f813c75e8b/5.png)

ç¢ºã‹ã«å£²ã‚Šã«å‡ºã•ã‚Œã¦ã„ã¾ã™ï¼ï¼

![](/images/a9c7f813c75e8b/6.png)

ä»Šåº¦ã¯å£²ã‚Šã«å‡ºã•ã‚Œã¦ã„ã‚‹NFTã‚’è³¼å…¥ã—ã¦ã¿ã¾ã™ï¼ï¼

![](/images/a9c7f813c75e8b/2.png)

è³¼å…¥ã—ã¦ã‚‚ã†ä¸€åº¦ MyPortfolioç”»é¢ã‚’ç¢ºèªã™ã‚‹ã¨NFTãŒå¢—ãˆã¦ã„ã¾ã™ï¼ï¼

![](/images/a9c7f813c75e8b/7.png)

NFTãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã®ä¸€é€šã‚Šã®æ©Ÿèƒ½ã®è§£èª¬ã¯ä»¥ä¸Šã§ã™ï¼ï¼

ä»Šå›ã¯ã“ã“ã¾ã§ã«ãªã‚Šã¾ã™ï¼ï¼

çš†ã•ã‚“ã‚‚Aptosã¨Moveã‚’ä½¿ã£ã¦ä½•ã‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ“ãƒ«ãƒ‰ã—ã¦ã¿ã¦ã¯ã„ã‹ãŒã§ã—ã‚‡ã†ã‹ï¼Ÿï¼Ÿ

èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼ï¼