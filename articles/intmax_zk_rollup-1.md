---
title: "ã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ å‰µå§‹è€…ã‚‚æ³¨ç›®ï¼ï¼Ÿ Plasmaã‚’å†ç™ºæ˜ã—ãŸINTMAXã‚’å¾¹åº•è§£å‰–"
emoji: "ğŸ§®"
type: "tech" 
topics: ["ethereum", "layer2", "zkrollup", "plasma", "intmax"]
published: false
---

![](/images/intmax_zk_rollup-1/0.jpeg)

## ç‰©èªã®å§‹ã¾ã‚Šï¼šã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å•é¡Œã¨L2ã®å¤œæ˜ã‘

ã‹ã¤ã¦ã€ã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ã¯å¤¢ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãƒ»ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã¨ã—ã¦è¼ã‹ã—ã„ãƒ‡ãƒ“ãƒ¥ãƒ¼ã‚’é£¾ã‚Šã¾ã—ãŸã€‚ã—ã‹ã—ã€ãã®äººæ°—ã¯è«¸åˆƒã®å‰£ã€‚åˆ©ç”¨è€…ãŒå¢—ãˆã‚‹ã»ã©ã«ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯è©°ã¾ã‚Šã€ã‚¬ã‚¹ä»£ã¯é«˜é¨°ã€‚ã€Œãƒ¯ãƒ¼ãƒ«ãƒ‰ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã€ã¯ã€ãã®æ€§èƒ½ã®é™ç•Œã¨ã„ã†å¤§ããªå£ã«ã¶ã¤ã‹ã‚Šã¾ã—ãŸã€‚

ã“ã®ã€Œã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å•é¡Œã€ã‚’è§£æ±ºã™ã¹ãã€æ•°ã€…ã®ãƒ’ãƒ¼ãƒ­ãƒ¼ãŸã¡ãŒç«‹ã¡ä¸ŠãŒã‚Šã¾ã—ãŸã€‚ãã‚ŒãŒ**ãƒ¬ã‚¤ãƒ¤ãƒ¼2ï¼ˆL2ï¼‰**ã¨å‘¼ã°ã‚Œã‚‹æŠ€è¡“ç¾¤ã§ã™ã€‚ä¸­ã§ã‚‚è¿‘å¹´ã€çµ¶å¤§ãªæ”¯æŒã‚’é›†ã‚ã¦ã„ã‚‹ã®ãŒ**Rollupï¼ˆãƒ­ãƒ¼ãƒ«ã‚¢ãƒƒãƒ—ï¼‰**ã§ã™ã€‚ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚ªãƒ•ãƒã‚§ãƒ¼ãƒ³ã§å®Ÿè¡Œã—ã€ãã®çµæœã ã‘ã‚’ã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ æœ¬ä½“ï¼ˆL1ï¼‰ã«æ›¸ãè¾¼ã‚€ã“ã¨ã§ã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ä¸¡ç«‹ã‚’ç›®æŒ‡ã—ã¾ã—ãŸã€‚

ã—ã‹ã—ã€RollupãŒä¸»æµã¨ãªã‚‹å°‘ã—å‰ã€ã‚‚ã†ä¸€ã¤ã®ä¼èª¬çš„ãªã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æŠ€è¡“ãŒã‚ã£ãŸã“ã¨ã‚’è¦šãˆã¦ã„ã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ ãã®åã¯**Plasmaï¼ˆãƒ—ãƒ©ã‚ºãƒï¼‰**ã€‚

ã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ã®å…±åŒå‰µè¨­è€…ã§ã‚ã‚‹Vitalik Buterinæ°è‡ªèº«ã‚‚æå”±ã—ãŸã“ã®æŠ€è¡“ã¯ã€ä¸€æ™‚æœŸã€ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å•é¡Œã®æœ€çµ‚å…µå™¨ã¨ã—ã¦å¤§ããªæœŸå¾…ã‚’é›†ã‚ã¾ã—ãŸã€‚

> "Intmax is the next great thing, Intmax is the Plasma." - **Vitalik Buterin, Founder, Ethereum**

ã—ã‹ã—ã€Plasmaã¯ã€Œãƒ‡ãƒ¼ã‚¿å¯ç”¨æ€§ï¼ˆDAï¼‰å•é¡Œã€ãªã©ã®è¤‡é›‘ãªèª²é¡Œã‚’å…‹æœã§ããšã€ã„ã¤ã—ã‹ã€Œå¤±æ•—ã—ãŸæŠ€è¡“ã€ã¨ã—ã¦èªã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã€æ­´å²ã®å½±ã«è¿½ã„ã‚„ã‚‰ã‚Œã¦ã„ãã¾ã—ãŸã€‚

â€¦ã ãŒã€ç‰©èªã¯ã¾ã çµ‚ã‚ã£ã¦ã„ãªã‹ã£ãŸã®ã§ã™ã€‚

ä»Šæ—¥ã€ã”ç´¹ä»‹ã™ã‚‹**INTMAX**ã¯ã€ã¾ã•ã«ãã®"å¤±æ•—ã—ãŸã¯ãš"ã®Plasmaã®é­‚ã‚’å—ã‘ç¶™ãã€zkRollupã®æŠ€è¡“ã¨èåˆã•ã›ã‚‹ã“ã¨ã§ã€å…¨ãæ–°ã—ã„åœ°å¹³ã‚’åˆ‡ã‚Šæ‹“ã“ã†ã¨ã—ã¦ã„ã¾ã™ã€‚Vitalikæ°ã‚„Justin Drakeæ°ã¨ã„ã£ãŸã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ è²¡å›£ã®é‡é®ãŸã¡ãŒæ³¨ç›®ã™ã‚‹ç†ç”±ã‚‚ã€ã¾ã•ã«ã“ã“ã«ã‚ã‚Šã¾ã™ã€‚

https://intmax.io/

ã“ã®è¨˜äº‹ã§ã¯ã€INTMAXãŒã©ã®ã‚ˆã†ã«ã—ã¦Plasmaã‚’"å†ç™ºæ˜"ã—ã€æ—¢å­˜ã®L2ãŒæŠ±ãˆã‚‹èª²é¡Œã‚’è§£æ±ºã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã€ãã®é©æ–°çš„ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å¿ƒè‡“éƒ¨ã«è¿«ã£ã¦ã„ãã¾ã™ã€‚

## ç¬¬ä¸€ç« ï¼šPlasmaã®æ „å…‰ã¨æŒ«æŠ˜

INTMAXã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã€ã¾ãšã¯PlasmaãŒä½•ã§ã‚ã‚Šã€ãªãœä¸€åº¦ã¯è¡¨èˆå°ã‹ã‚‰å§¿ã‚’æ¶ˆã—ãŸã®ã‹ã‚’æŒ¯ã‚Šè¿”ã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### Plasmaã¨ã¯ä½•ã ã£ãŸã®ã‹ï¼Ÿ

Plasmaã®åŸºæœ¬æ€æƒ³ã¯éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã€‚

> **ã€Œæœ¬å½“ã«å¤§äº‹ãªã“ã¨ã ã‘ã‚’L1ï¼ˆã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ï¼‰ã«å ±å‘Šã—ã€æ®‹ã‚Šã¯ã‚ªãƒ•ãƒã‚§ãƒ¼ãƒ³ï¼ˆL1ã®å¤–ï¼‰ã§ã‚„ã‚ã†ã€**

å…·ä½“çš„ã«ã¯ã€å¤§é‡ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚ªãƒ•ãƒã‚§ãƒ¼ãƒ³ã§å‡¦ç†ã—ã€ãã®æœ€çµ‚çµæœã‚’è¨¼æ˜ã™ã‚‹ã€Œãƒãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆã€ã¨ã„ã†å°ã•ãªãƒ‡ãƒ¼ã‚¿ã ã‘ã‚’L1ã«åˆ»ã¿ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€L1ã®è² æ‹…ã‚’æœ€å°é™ã«æŠ‘ãˆã¤ã¤ã€çµ¶å¤§ãªã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’å®Ÿç¾ã—ã‚ˆã†ã¨ã—ã¾ã—ãŸã€‚

```mermaid
graph TD
    subgraph offChain ["Off-Chain (Plasma Chain)"]
        T1(Tx 1) --> M1
        T2(Tx 2) --> M1
        T3(Tx 3) --> M2
        T4(Tx 4) --> M2
        M1 --> Root
        M2 --> Root
    end

    subgraph onChain ["On-Chain (Ethereum)"]
        Root(Merkle Root) --> L1_Contract(Plasma Contract)
    end

    style L1_Contract fill:#f9f,stroke:#333,stroke-width:2px
    style Root fill:#bbf,stroke:#333,stroke-width:2px
```

### ãªãœPlasmaã¯ã€Œå¤±æ•—ã€ã—ãŸã®ã‹ï¼Ÿ

Plasmaã®æœ€å¤§ã®å¼±ç‚¹ã€ãã‚ŒãŒ**ã€Œãƒ‡ãƒ¼ã‚¿å¯ç”¨æ€§ï¼ˆData Availabilityï¼‰å•é¡Œã€**ã§ã™ã€‚

ã‚ªãƒ•ãƒã‚§ãƒ¼ãƒ³ã§å‡¦ç†ã•ã‚Œã‚‹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã¯ã€èª°ãŒã€ã©ã“ã§ã€ã©ã®ã‚ˆã†ã«ä¿æŒã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ ã‚‚ã—ã€Plasmaãƒã‚§ãƒ¼ãƒ³ã‚’ç®¡ç†ã™ã‚‹æ‚ªæ„ã®ã‚ã‚‹ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’éš è”½ã—ã¦ã—ã¾ã£ãŸã‚‰ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®è³‡ç”£ãŒæ­£ã—ãå‡¦ç†ã•ã‚ŒãŸã“ã¨ã‚’è¨¼æ˜ã§ããšã€è³‡é‡‘ã‚’å¼•ãå‡ºã™ã“ã¨ã•ãˆã§ããªããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚

ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«è¤‡é›‘ãªä»•çµ„ã¿ï¼ˆExit Gameãªã©ï¼‰ãŒè€ƒæ¡ˆã•ã‚Œã¾ã—ãŸãŒã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã¯è‘—ã—ãæ‚ªåŒ–ã—ã¾ã—ãŸã€‚çµæœã¨ã—ã¦ã€ã‚ˆã‚Šã‚·ãƒ³ãƒ—ãƒ«ã§å®‰å…¨ãª**Rollup**ï¼ˆç‰¹ã«ã€å…¨ã¦ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’L1ã«æ›¸ãè¾¼ã‚€Optimistic Rollupã‚„zkRollupï¼‰ãŒL2ã®ä¸»æµã¨ãªã£ã¦ã„ã£ãŸã®ã§ã™ã€‚

## ç¬¬äºŒç« ï¼šINTMAXã®ç™»å ´ - ã€Œã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ã€ã¨ã„ã†é©å‘½

PlasmaãŒæ­´å²ã®é—‡ã«æ¶ˆãˆã‚ˆã†ã¨ã—ã¦ã„ãŸãã®æ™‚ã€INTMAXã¯å…¨ãæ–°ã—ã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ãã®é­‚ã‚’ç¾ä»£ã«è˜‡ã‚‰ã›ã¾ã—ãŸã€‚ãã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒ**ã€Œã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ï¼ˆStatelessï¼‰ã€**ã§ã™ã€‚

### ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨ã¯ï¼Ÿ

å¾“æ¥ã®Rollupï¼ˆStateful Rollupï¼‰ã§ã¯ã€L2ã®ã€ŒçŠ¶æ…‹ï¼ˆStateï¼‰ã€ã€ã¤ã¾ã‚Šã€Œèª°ãŒã©ã®è³‡ç”£ã‚’ã©ã‚Œã ã‘æŒã£ã¦ã„ã‚‹ã‹ã€ã¨ã„ã†æœ€æ–°ã®å°å¸³ã‚’ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ã¨å‘¼ã°ã‚Œã‚‹ä¸­å¤®é›†æ¨©çš„ãªç®¡ç†è€…ãŒä¿æŒãƒ»æ›´æ–°ã—ã¦ã„ã¾ã—ãŸã€‚

```mermaid
graph TD
    subgraph stateful ["Stateful Rollup (å¾“æ¥å‹)"]
        User1 --> Sequencer
        User2 --> Sequencer
        Sequencer(ğŸ‘¤ Sequencer<br/>- Txã‚’é †åºä»˜ã‘<br/>- L2ã®çŠ¶æ…‹ã‚’ç®¡ç†ãƒ»æ›´æ–°) -- "çŠ¶æ…‹ã‚’æ›´æ–°" --> StateDB[(L2 State<br/>å°å¸³ãƒ‡ãƒ¼ã‚¿)]
        Sequencer -- "Txãƒ‡ãƒ¼ã‚¿ã¨è¨¼æ˜ã‚’L1ã«é€ä¿¡" --> Ethereum
    end
```

ã“ã‚Œã«å¯¾ã—ã€INTMAXã®**ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**ã§ã¯ã€L2å…¨ä½“ã§å…±æœ‰ã™ã‚‹å˜ä¸€ã®çŠ¶æ…‹ï¼ˆå°å¸³ï¼‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€**å„ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªåˆ†è‡ªèº«ã®çŠ¶æ…‹ï¼ˆæ®‹é«˜ãªã©ï¼‰ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ï¼ˆè‡ªåˆ†ã®ãƒ‡ãƒã‚¤ã‚¹ï¼‰ã§ç®¡ç†**ã—ã¾ã™ã€‚

```mermaid
graph TD
    subgraph stateless ["Stateless Rollup (INTMAX)"]
        User1 -- "è‡ªåˆ†ã®çŠ¶æ…‹ã¯è‡ªåˆ†ã§ç®¡ç†" --> U1_State[(User1 State)]
        User2 -- "è‡ªåˆ†ã®çŠ¶æ…‹ã¯è‡ªåˆ†ã§ç®¡ç†" --> U2_State[(User2 State)]

        User1 -- "Txãƒãƒƒã‚·ãƒ¥ã‚’é€ä¿¡" --> Aggregator
        User2 -- "Txãƒãƒƒã‚·ãƒ¥ã‚’é€ä¿¡" --> Aggregator

        Aggregator(ğŸ¤– Aggregator<br/>- Txãƒãƒƒã‚·ãƒ¥ã‚’æŸã­ã‚‹ã ã‘<br/>- çŠ¶æ…‹ã¯ç®¡ç†ã—ãªã„) -- "ãƒãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆã®ã¿L1ã«é€ä¿¡" --> Ethereum

        User1 -- "è¨¼æ˜ã‚’P2Pã§ç›´æ¥é€ä¿¡" --> User3(Recipient)
    end
```

é©šãã¹ãã“ã¨ã«ã€INTMAXã§ã¯ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŸã­ã‚‹**ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ï¼ˆAggregatorï¼‰**ã§ã•ãˆã€èª°ãŒèª°ã«ã„ãã‚‰é€ã£ãŸã®ã‹ã¨ã„ã†ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸­èº«ã‚’ä¸€åˆ‡çŸ¥ã‚Šã¾ã›ã‚“ã€‚å½¼ã‚‰ã®ä»•äº‹ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰é€ã‚‰ã‚Œã¦ããŸãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ã€Œãƒãƒƒã‚·ãƒ¥å€¤ã€ã‚’å˜ç´”ã«é›†ã‚ã¦ã€ãƒãƒ¼ã‚¯ãƒ«ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰ã—ã€ãã®ãƒ«ãƒ¼ãƒˆã‚’L1ã«å ±å‘Šã™ã‚‹ã ã‘ã€‚ã¾ã•ã«ã€Œã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãªãƒ‡ãƒ¼ã‚¿ãƒãƒ³ãƒ€ãƒ©ãƒ¼ã€ãªã®ã§ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®é©å‘½çš„ãªåˆ©ç‚¹ãŒç”Ÿã¾ã‚Œã¾ã™ã€‚

1.  **é©šç•°çš„ãªã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**: L1ã«æ›¸ãè¾¼ã‚€ãƒ‡ãƒ¼ã‚¿ã¯ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ•°ã«é–¢ã‚ã‚‰ãšã€å‚åŠ ã—ãŸ**é€ä¿¡è€…ã®æ•°ã«å¿œã˜ãŸç´„5ãƒã‚¤ãƒˆ**ã¨ã„ã†æ¥µå°ã‚µã‚¤ã‚ºã€‚ã“ã‚Œã«ã‚ˆã‚Šã€EIP-4844é©ç”¨å¾Œã«ã¯**320,000 TPS**ä»¥ä¸Šã¨ã„ã†ã€ä»–ã®L2ã‚’åœ§å€’ã™ã‚‹ç†è«–å€¤ã‚’å©ãå‡ºã—ã¾ã™ã€‚
2.  **ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã®ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸­èº«ï¼ˆé€é‡‘å…ˆã€é‡‘é¡ï¼‰ã¯L1ã«ã‚‚ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã«ã‚‚æ¸¡ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ¼ã‚¿ã¯é€ä¿¡è€…ã¨å—ä¿¡è€…ã®é–“ã§ã®ã¿P2Pã§ç›´æ¥å…±æœ‰ã•ã‚Œã¾ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã¯ãªãã€æ¨™æº–æ©Ÿèƒ½ãªã®ã§ã™ã€‚
3.  **æ¤œé–²è€æ€§ã¨ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒ¬ã‚¹æ€§**: ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã¯ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸­èº«ã‚’çŸ¥ã‚‰ãªã„ãŸã‚ã€ç‰¹å®šã®å–å¼•ã‚’æ¤œé–²ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã¾ãŸã€èª°ã§ã‚‚ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã«ãªã‚‹ã“ã¨ãŒã§ãã‚‹ãŸã‚ã€ä¸­å¤®é›†æ¨©çš„ãªå˜ä¸€éšœå®³ç‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚

### Plasmaã®èª²é¡Œã‚’ã©ã†å…‹æœã—ãŸã‹ï¼Ÿ

ã§ã¯ã€INTMAXã¯ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§Plasmaã®ã€Œãƒ‡ãƒ¼ã‚¿å¯ç”¨æ€§å•é¡Œã€ã‚’ã©ã†è§£æ±ºã—ãŸã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

ç­”ãˆã¯ã€**ã‚¼ãƒ­çŸ¥è­˜è¨¼æ˜ï¼ˆZKPï¼‰**ã¨**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**ã®çµ„ã¿åˆã‚ã›ã«ã‚ã‚Šã¾ã™ã€‚

- **ãƒ‡ãƒ¼ã‚¿ã®ä¿æŒ**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒ¼ã‚¿ãã®ã‚‚ã®ã¯ã€é€ä¿¡è€…ã¨å—ä¿¡è€…ãŒP2Pã§ç›´æ¥äº¤æ›ã—ã¾ã™ã€‚
- **æ­£å½“æ€§ã®è¨¼æ˜**: é€ä¿¡è€…ã¯ã€è‡ªåˆ†ãŒæ­£å½“ãªæ®‹é«˜ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ZKãƒ—ãƒ«ãƒ¼ãƒ•ã‚’ç”Ÿæˆã—ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã¨å…±ã«å—ä¿¡è€…ã«æ¸¡ã—ã¾ã™ã€‚
- **L1ã«ã‚ˆã‚‹ä¿è¨¼**: L1ã«ã¯ã€ã©ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¤ºã™ãƒãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚å—ä¿¡è€…ã¯ã€å—ã‘å–ã£ãŸãƒ‡ãƒ¼ã‚¿ã¨ZKãƒ—ãƒ«ãƒ¼ãƒ•ã€ãã—ã¦L1ä¸Šã®ãƒãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆã‚’ç…§åˆã™ã‚‹ã“ã¨ã§ã€ãã®å–å¼•ãŒæ­£å½“ãªã‚‚ã®ã§ã‚ã‚‹ã“ã¨ã‚’èª°ã«ã‚‚é ¼ã‚‹ã“ã¨ãªãæ¤œè¨¼ã§ãã¾ã™ã€‚

ã¤ã¾ã‚Šã€æ‚ªæ„ã®ã‚ã‚‹ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒãƒ‡ãƒ¼ã‚¿ã‚’éš è”½ã—ã‚ˆã†ã¨ã—ã¦ã‚‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®æ‰‹å…ƒã«ã‚ã‚‹è¨¼æ˜ã‚’ä½¿ã£ã¦è³‡ç”£ã®æ‰€æœ‰æ¨©ã‚’ä¸»å¼µã§ãã‚‹ã®ã§ã™ã€‚ã“ã‚Œã¯ã€PlasmaãŒç›®æŒ‡ã—ãŸç†æƒ³ã‚’ã€ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸå½¢ã§å®Ÿç¾ã—ãŸå§¿ã¨è¨€ãˆã‚‹ã§ã—ã‚‡ã†ã€‚

## ç¬¬ä¸‰ç« ï¼šINTMAXã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ”¯ãˆã‚‹ç™»å ´äººç‰©ã¨ç‰©èª

INTMAXã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ã¾ã‚‹ã§å£®å¤§ãªç‰©èªã®ã‚ˆã†ã«ã€ã„ãã¤ã‹ã®ç™»å ´äººç‰©ã¨ãƒ•ã‚§ãƒ¼ã‚ºã‚’çµŒã¦å®Œæˆã—ã¾ã™ã€‚

### ç™»å ´äººç‰©

- **ãƒ¦ãƒ¼ã‚¶ãƒ¼ (Users)**: ç‰©èªã®ä¸»äººå…¬ã€‚è‡ªåˆ†è‡ªèº«ã®çŠ¶æ…‹ã‚’ç®¡ç†ã—ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
- **ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ (Aggregators)**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒãƒƒã‚·ãƒ¥ã‚’æŸã­ã‚‹ä¼æ›¸é³©ã€‚ä¸­èº«ã¯çŸ¥ã‚Šã¾ã›ã‚“ã€‚
- **å—ä¿¡è€… (Recipients)**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ZKãƒ—ãƒ«ãƒ¼ãƒ•ã¨ãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥å—ã‘å–ã‚Šã€è‡ªèº«ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚

### ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«

```mermaid
sequenceDiagram
    participant User as ãƒ¦ãƒ¼ã‚¶ãƒ¼ (é€ä¿¡è€…)
    participant Aggregator as ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼
    participant Ethereum as L1 (Ethereum)
    participant Recipient as ãƒ¦ãƒ¼ã‚¶ãƒ¼ (å—ä¿¡è€…)

    User->>User: 1. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§ä½œæˆ
    User->>Aggregator: 2. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒãƒƒã‚·ãƒ¥ã‚’é€ä¿¡
    Aggregator->>Aggregator: 3. ãƒãƒƒã‚·ãƒ¥ã‹ã‚‰ãƒãƒ¼ã‚¯ãƒ«ãƒ„ãƒªãƒ¼ã‚’æ§‹ç¯‰
    Aggregator-->>User: 4. ãƒãƒ¼ã‚¯ãƒ«åŒ…å«è¨¼æ˜ã‚’è¿”å´
    User->>User: 5. ãƒãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆã«ç½²å
    User->>Aggregator: 6. ç½²åã‚’é€ä¿¡
    Aggregator->>Aggregator: 7. å…¨å“¡ã®ç½²åã‚’æŸã­ã‚‹
    Aggregator->>Ethereum: 8. ãƒãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆã¨é›†ç´„ç½²åã‚’L1ã«é€ä¿¡

    Note right of Aggregator: ã“ã®æ™‚ç‚¹ã§L1ã¯TxãŒ<br>å­˜åœ¨ã—ãŸã“ã¨ã‚’èªè­˜ã™ã‚‹ãŒ<br>ä¸­èº«ã¯çŸ¥ã‚‰ãªã„

    User->>Recipient: 9. ZKãƒ—ãƒ«ãƒ¼ãƒ•ã¨Txãƒ‡ãƒ¼ã‚¿ã‚’P2Pã§ç›´æ¥é€ä¿¡
    Recipient->>Recipient: 10. å—ã‘å–ã£ãŸè¨¼æ˜ã‚’æ¤œè¨¼ã—ã€<br>è‡ªèº«ã®ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’æ›´æ–°
```

ã“ã®æµã‚Œã‚’è¦‹ã‚Œã°ã€ã„ã‹ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ªãƒ•ãƒã‚§ãƒ¼ãƒ³ã€ç‰¹ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼é–“ã§å®Œçµã—ã¦ã„ã‚‹ã‹ãŒã‚ã‹ã‚‹ã§ã—ã‚‡ã†ã€‚L1ã¯ã‚ãã¾ã§ã€Œå…¬è¨¼å½¹å ´ã€ã¨ã—ã¦æ©Ÿèƒ½ã—ã€ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã¯ã€Œæ›¸é¡ã‚’æŸã­ã‚‹äº‹å‹™å“¡ã€ã«éãã¾ã›ã‚“ã€‚çœŸã®ä¸»å½¹ã¯ã€è‡ªã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¸»æ¨©çš„ã«ç®¡ç†ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ãªã®ã§ã™ã€‚

## ç¬¬å››ç« ï¼šINTMAXãŒæ‹“ãæœªæ¥

ã“ã®é©æ–°çš„ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€ä¸€ä½“ã©ã‚“ãªæœªæ¥ã‚’ç§ãŸã¡ã«ã‚‚ãŸã‚‰ã™ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

- **çœŸã®ãƒã‚¤ã‚¯ãƒ­ãƒšã‚¤ãƒ¡ãƒ³ãƒˆ**: 1å††ä»¥ä¸‹ã®æ±ºæ¸ˆãŒã€ã‚¬ã‚¹ä»£ã‚’æ°—ã«ã™ã‚‹ã“ã¨ãªãã€ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã‚’å®ˆã‚ŠãªãŒã‚‰å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç§’å˜ä½èª²é‡‘ã€IoTãƒ‡ãƒã‚¤ã‚¹é–“ã®è‡ªå‹•æ±ºæ¸ˆãªã©ã€ã“ã‚Œã¾ã§å¤¢ç‰©èªã ã£ãŸãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ãŒç¾å®Ÿã®ã‚‚ã®ã¨ãªã‚Šã¾ã™ã€‚
- **ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªB2Bæ±ºæ¸ˆ**: ä¼æ¥­é–“ã®å–å¼•æƒ…å ±ã‚’ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã«è¼‰ã›ã‚‹ã“ã¨ãªãã€é«˜é€Ÿã‹ã¤ä½ã‚³ã‚¹ãƒˆãªæ±ºæ¸ˆãŒå®Ÿç¾ã—ã¾ã™ã€‚
- **æ¤œé–²è€æ€§ã®ã‚ã‚‹é€é‡‘**: ã„ã‹ãªã‚‹ä¸­å¤®é›†æ¨©çš„ãªä¸»ä½“ã«ã‚‚å–å¼•ã‚’æ­¢ã‚ã‚‰ã‚Œã‚‹ã“ã¨ã®ãªã„ã€çœŸã«è‡ªç”±ãªä¾¡å€¤äº¤æ›ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

INTMAXã¯ã™ã§ã«ã€èª°ã§ã‚‚ä½¿ãˆã‚‹ã‚¦ã‚©ãƒ¬ãƒƒãƒˆ`INTMAX Wallet`ã‚„ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒˆãƒ¼ã‚¯ãƒ³`ITX`ã‚’ç²å¾—ã§ãã‚‹`Privacy Mining`ãªã©ã€ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰ã‚‚é€²ã‚ã¦ã„ã¾ã™ã€‚

## ãƒãƒ³ã‚ºã‚ªãƒ³ï¼ Block Builderã‚’å‹•ã‹ã—ã¦ã¿ãŸï¼

ç†è«–ã‚’å­¦ã‚“ã ã¨ã“ã‚ã§ã€ã„ã–å®Ÿè·µï¼

ä»¥ä¸‹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚è€ƒã«**INTMAX**ã®**Block Builder**ã‚’å‹•ã‹ã—ã¦ã¿ã¾ã—ãŸï¼

https://docs.network.intmax.io/developers-hub/intmax-block-builder

### ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

ã¾ãšã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ï¼

ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç”¨ã®ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã‚ã‚‹ã®ã§ã¾ãšã¯ãã‚Œã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã¾ã™ï¼

ä»Šå›ã¯ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆç”¨ã®ã‚‚ã®ã‚’ä½¿ã£ã¦ã¿ã¾ã—ãŸï¼

```bash
curl -o builder.sh https://raw.githubusercontent.com/InternetMaximalism/intmax2/refs/heads/main/scripts/block-builder-testnet.sh
chmod +x builder.sh
```

::::details buider.shã®è©³ç´°

```bash
#!/bin/bash

#################################################################################
# INTMAX2 Block Builder ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ»ç®¡ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
#
# ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ INTMAX2 ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ãƒ–ãƒ­ãƒƒã‚¯ãƒ“ãƒ«ãƒ€ãƒ¼ã‚’
# ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ»ç®¡ç†ã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚
#
# ä¸»ãªæ©Ÿèƒ½:
# - åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆï¼‰
# - ç’°å¢ƒè¨­å®šï¼ˆRPC URLã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚­ãƒ¼è¨­å®šï¼‰
# - ã‚µãƒ¼ãƒ“ã‚¹ã®èµ·å‹•ãƒ»åœæ­¢ãƒ»ç›£è¦–
# - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½
# - è¨­å®šæ¤œè¨¼æ©Ÿèƒ½
# - ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æ©Ÿèƒ½
#
# ä½¿ç”¨æ–¹æ³•: ./builder.sh [ã‚³ãƒãƒ³ãƒ‰]
# è©³ç´°ãªãƒ˜ãƒ«ãƒ—: ./builder.sh help
#################################################################################

# ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’çµ‚äº†
set -e

# API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨URLè¨­å®š
API_ENDPOINT="https://stage.api.indexer.intmax.io/v1/proxy/meta"
INDEXER_API_ENDPOINT="https://stage.api.indexer.intmax.io"
BUILDER_SCRIPT_URL="https://raw.githubusercontent.com/InternetMaximalism/intmax2/refs/heads/main/scripts/block-builder-testnet.sh"

# æœŸå¾…ã•ã‚Œã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®š
EXPECTED_NETWORK_ID="534351"
EXPECTED_NETWORK_NAME="Scroll Sepolia Testnet"
ENVIRONMENT="testnet"

# è¨±å¯ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ã®ãƒªã‚¹ãƒˆï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ï¼‰
ALLOWED_DOMAINS="intmax.io,raw.githubusercontent.com"

# ç’°å¢ƒå¤‰æ•°ç”¨ã®è¨­å®šå€¤
REGISTRATION_FEE=0:2500000000000
NON_REGISTRATION_FEE=0:2000000000000
STORE_VAULT_SERVER_BASE_URL=https://stage.api.node.intmax.io/store-vault-server
VALIDITY_PROVER_BASE_URL=https://stage.api.node.intmax.io/validity-prover
ROLLUP_CONTRACT_ADDRESS=0xcEC03800074d0ac0854bF1f34153cc4c8bAEeB1E
BLOCK_BUILDER_REGISTRY_CONTRACT_ADDRESS=0x93a41F47ed161AB2bc58801F07055f2f05dfc74E

# API ã‹ã‚‰å–å¾—ã™ã‚‹å¤‰æ•°ï¼ˆåˆæœŸå€¤ã¯ç©ºï¼‰
INTMAX2_VERSION=""
PROXY_DOMAIN=""
FRP_TOKEN=""

# ç’°å¢ƒåã‹ã‚‰å†…éƒ¨ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã™ã‚‹é–¢æ•°
set_env_from_environment() {
    case "$ENVIRONMENT" in
        "devnet")
            ENV="dev"
            ;;
        "testnet")
            ENV="staging"
            ;;
        "mainnet")
            ENV="prod"
            ;;
        *)
            echo "âŒ Unknown ENVIRONMENT: $ENVIRONMENT"
            echo "ğŸ’¡ Supported values: devnet, testnet, mainnet"
            return 1
            ;;
    esac

    return 0
}

if set_env_from_environment; then
    :
else
    echo "âŒ Failed to set ENV"
    exit 1
fi

# ç¾åœ¨ã®ç’°å¢ƒè¨­å®šã‚’è‰²ä»˜ãã§è¡¨ç¤ºã™ã‚‹é–¢æ•°
show_current_environment() {
    if set_env_from_environment; then
        local env_color=""
        local env_label=""
        # ç’°å¢ƒã«å¿œã˜ã¦è¡¨ç¤ºè‰²ã‚’è¨­å®š
        case "$ENVIRONMENT" in
            "devnet")
                env_color="\033[1;36m"  # ã‚·ã‚¢ãƒ³è‰²
                env_label="ğŸ”§ DEVELOPMENT"
                ;;
            "testnet")
                env_color="\033[1;33m"  # é»„è‰²
                env_label="ğŸ§ª TESTNET"
                ;;
            "mainnet")
                env_color="\033[1;32m"  # ç·‘è‰²
                env_label="ğŸš€ MAINNET"
                ;;
        esac
        local reset_color="\033[0m"  # è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ

        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸŒ ENVIRONMENT CONFIGURATION"
        echo -e "   ENVIRONMENT: ${env_color}${ENVIRONMENT}${reset_color}"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
    else
        echo "   âŒ INVALID ENVIRONMENT: $ENVIRONMENT"
        echo "   ğŸ’¡ Supported values: devnet, testnet, mainnet"
        echo ""
        return 1
    fi
}

# API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼ã‚’è¡Œã†é–¢æ•°
validate_api_endpoint() {
    local endpoint="$1"

    # HTTPSå¿…é ˆãƒã‚§ãƒƒã‚¯
    if ! echo "$endpoint" | grep -q "^https://"; then
        echo "âŒ API endpoint must use HTTPS"
        return 1
    fi

    # ãƒ‰ãƒ¡ã‚¤ãƒ³éƒ¨åˆ†ã‚’æŠ½å‡º
    local domain=$(echo "$endpoint" | sed 's|https://||' | cut -d'/' -f1)

    # è¨±å¯ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ãƒªã‚¹ãƒˆã‚’é…åˆ—ã«å¤‰æ›
    IFS=',' read -ra allowed_domains_array <<< "$ALLOWED_DOMAINS"

    # ãƒ‰ãƒ¡ã‚¤ãƒ³ã®è¨±å¯ãƒã‚§ãƒƒã‚¯
    local domain_allowed=false
    for allowed_domain in "${allowed_domains_array[@]}"; do
        # å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤
        allowed_domain=$(echo "$allowed_domain" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒå®Œå…¨ä¸€è‡´ã¾ãŸã¯ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if [ "$domain" = "$allowed_domain" ] || echo "$domain" | grep -q "\\.${allowed_domain}$"; then
            domain_allowed=true
            break
        fi
    done

    # çµæœã‚’è¿”ã™
    if [ "$domain_allowed" = true ]; then
        return 0
    else
        echo "âŒ Unauthorized API domain: $domain"
        echo "   Allowed domains: $ALLOWED_DOMAINS"
        return 1
    fi
}

# API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å¦¥å½“æ€§ã‚’æ¤œè¨¼ã™ã‚‹é–¢æ•°
validate_api_response() {
    local response="$1"

    # ç©ºã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯
    if [ -z "$response" ]; then
        echo "âŒ Empty API response"
        return 1
    fi

    # JSONãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
    if ! echo "$response" | jq empty 2>/dev/null; then
        echo "âŒ Invalid JSON response from API"
        return 1
    fi

    # å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½å‡º
    local domain=$(echo "$response" | jq -r '.domain // empty')
    local token=$(echo "$response" | jq -r '.token // empty')
    local version=$(echo "$response" | jq -r '.version // empty')

    # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    if [ -z "$domain" ] || [ -z "$token" ] || [ -z "$version" ]; then
        echo "âŒ Missing required fields in API response"
        return 1
    fi

    # ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
    if ! echo "$domain" | grep -E '^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' >/dev/null; then
        echo "âŒ Invalid domain format: $domain"
        return 1
    fi

    # ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ï¼‰
    if ! echo "$version" | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' >/dev/null; then
        echo "âŒ Invalid version format: $version"
        return 1
    fi

    # ãƒˆãƒ¼ã‚¯ãƒ³ã«å±é™ºãªæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
    if echo "$token" | grep -E '[[:space:]<>"\|&;`$()]' >/dev/null; then
        echo "âŒ Token contains invalid characters"
        return 1
    fi

    return 0
}

# API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰å¿…è¦ãªå€¤ã‚’è§£æã—ã¦å¤‰æ•°ã«è¨­å®šã™ã‚‹é–¢æ•°
parse_api_response() {
    local response="$1"

    # jq ã‚³ãƒãƒ³ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯é«˜å“è³ªãªJSONãƒ‘ãƒ¼ã‚¹ã‚’ä½¿ç”¨
    if command -v jq >/dev/null 2>&1; then
        PROXY_DOMAIN=$(echo "$response" | jq -r '.domain // empty')
        FRP_TOKEN=$(echo "$response" | jq -r '.token // empty')
        local api_version=$(echo "$response" | jq -r '.version // empty')

        # ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‹ã‚‰å…ˆé ­ã®'v'ã‚’å‰Šé™¤
        if [ -n "$api_version" ]; then
            INTMAX2_VERSION=$(echo "$api_version" | sed 's/^v//')
        fi
    else
        # jq ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯åŸºæœ¬çš„ãªæ–‡å­—åˆ—æ“ä½œã§ãƒ‘ãƒ¼ã‚¹
        echo "âš ï¸  jq not found, using basic parsing"
        PROXY_DOMAIN=$(echo "$response" | grep -o '"domain":"[^"]*"' | cut -d':' -f2 | tr -d '"')
        FRP_TOKEN=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d':' -f2 | tr -d '"')
        local api_version=$(echo "$response" | grep -o '"version":"[^"]*"' | cut -d':' -f2 | tr -d '"')

        # ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‹ã‚‰å…ˆé ­ã®'v'ã‚’å‰Šé™¤
        if [ -n "$api_version" ]; then
            INTMAX2_VERSION=$(echo "$api_version" | sed 's/^v//')
        fi
    fi

    # å¿…è¦ãªå€¤ãŒã™ã¹ã¦å–å¾—ã§ããŸã‹ãƒã‚§ãƒƒã‚¯
    if [ -z "$PROXY_DOMAIN" ] || [ -z "$FRP_TOKEN" ] || [ -z "$INTMAX2_VERSION" ]; then
        echo "âŒ Failed to parse required values from API response"
        return 1
    fi

    return 0
}

# è¨­å®šå€¤ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚ºã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼ã‚’è¡Œã†é–¢æ•°
sanitize_config_values() {
    # ãƒ—ãƒ­ã‚­ã‚·ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚º
    if [ -n "$PROXY_DOMAIN" ]; then
        # è‹±æ•°å­—ã€ãƒ‰ãƒƒãƒˆã€ãƒã‚¤ãƒ•ãƒ³ä»¥å¤–ã®æ–‡å­—ã‚’é™¤å»
        local sanitized_domain=$(echo "$PROXY_DOMAIN" | sed 's/[^a-zA-Z0-9.-]//g')

        # ãƒ‰ãƒ¡ã‚¤ãƒ³åã®æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        if echo "$sanitized_domain" | grep -qE '^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'; then
            # è¨±å¯ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ãƒªã‚¹ãƒˆã‚’é…åˆ—ã«å¤‰æ›
            IFS=',' read -ra allowed_domains_array <<< "$ALLOWED_DOMAINS"

            # ãƒ‰ãƒ¡ã‚¤ãƒ³ãŒè¨±å¯ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            local domain_allowed=false
            for allowed_domain in "${allowed_domains_array[@]}"; do
                allowed_domain=$(echo "$allowed_domain" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

                if [ "$sanitized_domain" = "$allowed_domain" ] || echo "$sanitized_domain" | grep -qE "\\.${allowed_domain}$"; then
                    domain_allowed=true
                    break
                fi
            done

            if [ "$domain_allowed" = true ]; then
                PROXY_DOMAIN="$sanitized_domain"
            else
                echo "âŒ PROXY_DOMAIN contains unauthorized domain: $sanitized_domain"
                echo "   Allowed domains: $ALLOWED_DOMAINS"
                return 1
            fi
        else
            echo "âŒ PROXY_DOMAIN has invalid format after sanitization: $sanitized_domain"
            return 1
        fi
    else
        echo "âŒ PROXY_DOMAIN is empty"
        return 1
    fi

    # FRPãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚º
    if [ -n "$FRP_TOKEN" ]; then
        # è‹±æ•°å­—ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã€ãƒã‚¤ãƒ•ãƒ³ä»¥å¤–ã®æ–‡å­—ã‚’é™¤å»
        local sanitized_token=$(echo "$FRP_TOKEN" | sed 's/[^a-zA-Z0-9_-]//g')

        # ãƒˆãƒ¼ã‚¯ãƒ³é•·ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ32ã€œ128æ–‡å­—ï¼‰
        local token_length=$(echo -n "$sanitized_token" | wc -c)
        if [ "$token_length" -ge 32 ] && [ "$token_length" -le 128 ]; then
            # ãƒˆãƒ¼ã‚¯ãƒ³ã®é–‹å§‹ãƒ»çµ‚äº†æ–‡å­—ãŒè‹±æ•°å­—ã§ã‚ã‚‹ã“ã¨ã‚’ãƒã‚§ãƒƒã‚¯
            if echo "$sanitized_token" | grep -qE '^[a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9]$'; then
                FRP_TOKEN="$sanitized_token"
            else
                echo "âŒ FRP_TOKEN has invalid pattern after sanitization"
                return 1
            fi
        else
            echo "âŒ FRP_TOKEN length invalid after sanitization: $token_length (expected: 32-128)"
            return 1
        fi
    else
        echo "âŒ FRP_TOKEN is empty"
        return 1
    fi

    # ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚º
    if [ -n "$INTMAX2_VERSION" ]; then
        # è‹±æ•°å­—ã€ãƒ‰ãƒƒãƒˆã€ãƒã‚¤ãƒ•ãƒ³ä»¥å¤–ã®æ–‡å­—ã‚’é™¤å»
        local sanitized_version=$(echo "$INTMAX2_VERSION" | sed 's/[^a-zA-Z0-9.-]//g')

        # ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°å½¢å¼ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆä¾‹: 1.2.3 ã¾ãŸã¯ 1.2.3-alpha.1ï¼‰
        if echo "$sanitized_version" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$'; then
            # ãƒ¡ã‚¸ãƒ£ãƒ¼ã€ãƒã‚¤ãƒŠãƒ¼ã€ãƒ‘ãƒƒãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æŠ½å‡º
            local major=$(echo "$sanitized_version" | cut -d'.' -f1)
            local minor=$(echo "$sanitized_version" | cut -d'.' -f2)
            local patch=$(echo "$sanitized_version" | cut -d'.' -f3 | cut -d'-' -f1)

            # å„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ãŒæœ‰åŠ¹ç¯„å›²å†…ã§ã‚ã‚‹ã“ã¨ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆ0-999ï¼‰
            if [ "$major" -ge 0 ] && [ "$major" -le 999 ] && \
               [ "$minor" -ge 0 ] && [ "$minor" -le 999 ] && \
               [ "$patch" -ge 0 ] && [ "$patch" -le 999 ]; then
                # 0.0.0ã¯ç„¡åŠ¹ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã—ã¦æ‰±ã†
                if [ "$major" -eq 0 ] && [ "$minor" -eq 0 ] && [ "$patch" -eq 0 ]; then
                    echo "âŒ INTMAX2_VERSION cannot be 0.0.0: $sanitized_version"
                    return 1
                fi
                INTMAX2_VERSION="$sanitized_version"
            else
                echo "âŒ INTMAX2_VERSION out of valid range: $sanitized_version"
                echo "   Expected: 0.0.1 to 999.999.999 (excluding 0.0.0)"
                return 1
            fi
        else
            echo "âŒ INTMAX2_VERSION has invalid semantic version format: $sanitized_version"
            return 1
        fi
    else
        echo "âŒ INTMAX2_VERSION is empty"
        return 1
    fi

    # æœ€çµ‚çš„ã«å…¨ã¦ã®è¨­å®šå€¤ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if [ -z "$PROXY_DOMAIN" ] || [ -z "$FRP_TOKEN" ] || [ -z "$INTMAX2_VERSION" ]; then
        echo "âŒ One or more configuration values became empty after sanitization"
        echo "   PROXY_DOMAIN: ${PROXY_DOMAIN:-'<empty>'}"
        echo "   FRP_TOKEN: ${FRP_TOKEN:+<set>}${FRP_TOKEN:-'<empty>'}"
        echo "   INTMAX2_VERSION: ${INTMAX2_VERSION:-'<empty>'}"
        return 1
    fi

    return 0
}

# API ã‹ã‚‰è¨­å®šæƒ…å ±ã‚’å–å¾—ã—æ¤œè¨¼ã™ã‚‹é–¢æ•°
fetch_api_config() {
    # APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
    if ! validate_api_endpoint "$API_ENDPOINT"; then
        return 1
    fi

    # curlã‚³ãƒãƒ³ãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    if ! command -v curl >/dev/null 2>&1; then
        echo "âŒ curl not found. Please install curl to fetch API configuration."
        return 1
    fi

    local api_response
    # curlã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³: ã‚µã‚¤ãƒ¬ãƒ³ãƒˆã€10ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€HTTPã‚¨ãƒ©ãƒ¼æ™‚ã«çµ‚äº†
    local curl_options="-s --max-time 10 --fail"

    # APIã‹ã‚‰ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å–å¾—ã—ã€å„æ®µéšã§æ¤œè¨¼ã‚’å®Ÿè¡Œ
    if api_response=$(curl $curl_options "$API_ENDPOINT" 2>/dev/null); then
        if validate_api_response "$api_response"; then
            if parse_api_response "$api_response"; then
                if sanitize_config_values; then
                    return 0
                fi
            fi
        fi
    fi

    echo "âš ï¸  API fetch failed or validation failed"
    return 1
}

# è¨­å®šæƒ…å ±ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°ï¼ˆAPIã‹ã‚‰å–å¾—ã«å¤±æ•—ã—ãŸå ´åˆã¯çµ‚äº†ï¼‰
load_config() {
    if ! fetch_api_config; then
        echo "âŒ API fetch failed, cannot proceed without valid configuration"
        echo "Please check your internet connection and API endpoint:"
        echo "   $API_ENDPOINT"
        exit 1
    fi
}

# ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ¤œå‡ºã—ã¦é©åˆ‡ãªDockerã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’é¸æŠã™ã‚‹é–¢æ•°
detect_architecture() {
    local arch=$(uname -m)
    case $arch in
        aarch64|arm64)
            # ARM64ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ç”¨ã®ã‚¤ãƒ¡ãƒ¼ã‚¸
            echo "ghcr.io/internetmaximalism/intmax2:${INTMAX2_VERSION}-arm64"
            ;;
        x86_64|amd64)
            # x86_64ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ç”¨ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
            echo "ghcr.io/internetmaximalism/intmax2:${INTMAX2_VERSION}"
            ;;
        *)
            # æœªçŸ¥ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å ´åˆã¯x86_64ã‚’ä½¿ç”¨
            echo "âš ï¸  Unknown architecture: $arch. Using default x86_64 image."
            echo "ghcr.io/internetmaximalism/intmax2:${INTMAX2_VERSION}"
            ;;
    esac
}

# UUIDï¼ˆä¸€æ„è­˜åˆ¥å­ï¼‰ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
generate_uuid() {
    # uuidgenã‚³ãƒãƒ³ãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    if ! command -v uuidgen >/dev/null 2>&1; then
        echo "âŒ uuidgen is required but not found" >&2
        echo "" >&2
        echo "Please install uuidgen:" >&2
        echo "" >&2
        return 1
    fi

    # UUIDã‚’ç”Ÿæˆã—ã¦å°æ–‡å­—ã«å¤‰æ›
    uuidgen | tr '[:upper:]' '[:lower:]'
}

# å¿…è¦ãªãƒ„ãƒ¼ãƒ«ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
check_required_tools() {
    local missing_tools=()

    # å¿…é ˆãƒ„ãƒ¼ãƒ«ã®å­˜åœ¨ç¢ºèª
    if ! command -v uuidgen >/dev/null 2>&1; then
        missing_tools+=("uuidgen")
    fi

    if ! command -v curl >/dev/null 2>&1; then
        missing_tools+=("curl")
    fi

    if ! command -v docker >/dev/null 2>&1; then
        missing_tools+=("docker")
    fi

    # æ¨å¥¨ãƒ„ãƒ¼ãƒ«ã®å­˜åœ¨ç¢ºèª
    local recommended_tools=()
    if ! command -v jq >/dev/null 2>&1; then
        recommended_tools+=("jq")
    fi

    # å¿…é ˆãƒ„ãƒ¼ãƒ«ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤º
    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo "âŒ Missing required tools: ${missing_tools[*]}"
        echo ""
        echo "Installation commands:"

        for tool in "${missing_tools[@]}"; do
            echo "Missing tool: $tool"
            echo "Please install $tool using your system's package manager:"
            echo ""
        done

        return 1
    fi

    # æ¨å¥¨ãƒ„ãƒ¼ãƒ«ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã¯è­¦å‘Šã‚’è¡¨ç¤º
    if [ ${#recommended_tools[@]} -gt 0 ]; then
        echo "âš ï¸  Recommended tools not found: ${recommended_tools[*]}"
        echo "   These tools will improve the script's functionality"
        echo ""
    fi

    echo "âœ… All required tools are available"
    return 0
}

# Docker Swarm ãƒ¢ãƒ¼ãƒ‰ã®æœ‰åŠ¹æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
check_docker_swarm() {
    # Docker ã®æƒ…å ±ã‹ã‚‰SwarmãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã‚’ç¢ºèª
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        echo "âš ï¸  Docker Swarm is not active"
        echo "ğŸ’¡ To enable Docker Swarm: docker swarm init"
        echo "ğŸ”„ After running 'docker swarm init', please re-execute the command"
        return 1
    fi
    return 0
}

# Docker Secret ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
check_docker_secret() {
    # ã¾ãšDocker SwarmãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
    if ! check_docker_swarm; then
        return 1
    fi

    # ç’°å¢ƒã«å¿œã˜ãŸSecretåã‚’ç”Ÿæˆ
    local secret_name="block_builder_private_key_${ENVIRONMENT}"

    # Docker Secretã®å­˜åœ¨ç¢ºèª
    if docker secret ls 2>/dev/null | grep -q "$secret_name"; then
        echo "âœ… Docker secret '$secret_name' exists"
        return 0
    else
        echo "âŒ Docker secret '$secret_name' not found"
        echo "ğŸ’¡ Run: $0 setup-env"
        return 1
    fi
}

# ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚­ãƒ¼ã®è¨­å®šçŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
check_private_key_config() {
    local has_docker_secret=false
    local secret_name="block_builder_private_key_${ENVIRONMENT}"

    # Docker Swarmã¨Secretã®å­˜åœ¨ã‚’ç¢ºèª
    if check_docker_swarm >/dev/null 2>&1; then
        if docker secret ls 2>/dev/null | grep -q "$secret_name"; then
            has_docker_secret=true
            echo "âœ… Docker secret '$secret_name' exists"
        fi
    fi

    # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    if [ "$has_docker_secret" = false ]; then
        echo "âŒ No private key configuration found"
        echo "ğŸ’¡ Please set up environment using:"
        echo "   $0 setup-env"
        return 1
    fi

    return 0
}

check_rpc_connectivity() {
    local l2_rpc_url="$1"
    local verbose="${2:-false}"

    if [ -z "$l2_rpc_url" ]; then
        echo "âŒ RPC URL is required"
        return 1
    fi

    if ! command -v curl >/dev/null 2>&1; then
        echo "âš ï¸  curl not available, skipping connectivity test"
        return 0
    fi

    if [ "$verbose" = true ]; then
        echo "ğŸ”— Testing L2 RPC connectivity..."
        echo "   Testing: $l2_rpc_url"
    fi

    local rpc_test_payload='{"jsonrpc":"2.0","method":"net_version","params":[],"id":1}'
    local curl_start_time=$(date +%s)
    local response_body
    local http_code

    if [ "$verbose" = true ]; then
        echo "   Method: net_version"
    fi

    if response_body=$(curl -s --connect-timeout 10 --max-time 15 \
        -H "Content-Type: application/json" \
        -d "$rpc_test_payload" \
        -w "%{http_code}" \
        "$l2_rpc_url" 2>/dev/null); then

        http_code="${response_body: -3}"
        response_body="${response_body%???}"

        local curl_end_time=$(date +%s)
        local response_time=$((curl_end_time - curl_start_time))

        if [ "$http_code" -eq 200 ]; then
            if [ "$verbose" = true ]; then
                echo "   âœ… RPC connectivity test passed (HTTP $http_code, ${response_time}s)"
            fi

            if command -v jq >/dev/null 2>&1 && echo "$response_body" | jq empty 2>/dev/null; then
                local result=$(echo "$response_body" | jq -r '.result // empty')
                local error=$(echo "$response_body" | jq -r '.error.message // empty')

                if [ -n "$result" ]; then
                    if [ "$verbose" = true ]; then
                        echo "   ğŸ“Š Network ID: $result"

                        if [ "$result" = "$EXPECTED_NETWORK_ID" ]; then
                            echo "   ğŸŒ Network: $EXPECTED_NETWORK_NAME âœ…"
                        else
                            echo "   ğŸŒ Network: Chain ID $result"
                            echo "   âš ï¸  Note: Expected $EXPECTED_NETWORK_NAME ($EXPECTED_NETWORK_ID) for this setup"
                        fi
                    fi
                elif [ -n "$error" ]; then
                    if [ "$verbose" = true ]; then
                        echo "   âš ï¸  RPC returned error: $error"
                    fi
                    return 1
                else
                    if [ "$verbose" = true ]; then
                        echo "   âš ï¸  Unexpected RPC response format"
                    fi
                fi
            else
                if [ "$verbose" = true ]; then
                    echo "   ğŸ“„ Response received (jq not available for detailed parsing)"
                    echo "   Response preview: $(echo "$response_body" | cut -c1-100)..."
                fi
            fi

            if [ "$verbose" = true ]; then
                echo ""
                echo "ğŸ”— Testing latest block retrieval..."
            fi

            local block_test_payload='{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":2}'

            if response_body=$(curl -s --connect-timeout 10 --max-time 15 \
                -H "Content-Type: application/json" \
                -d "$block_test_payload" \
                -w "%{http_code}" \
                "$l2_rpc_url" 2>/dev/null); then

                http_code="${response_body: -3}"
                response_body="${response_body%???}"

                if [ "$http_code" -eq 200 ]; then
                    if [ "$verbose" = true ]; then
                        echo "   âœ… Block number retrieval passed (HTTP $http_code)"
                    fi

                    if command -v jq >/dev/null 2>&1 && echo "$response_body" | jq empty 2>/dev/null; then
                        local block_hex=$(echo "$response_body" | jq -r '.result // empty')
                        if [ -n "$block_hex" ] && [ "$block_hex" != "null" ]; then
                            if command -v printf >/dev/null 2>&1; then
                                local block_num=$(printf "%d" "$block_hex" 2>/dev/null || echo "$block_hex")
                                if [ "$verbose" = true ]; then
                                    echo "   ğŸ“Š Latest block: $block_num ($block_hex)"
                                fi
                            else
                                if [ "$verbose" = true ]; then
                                    echo "   ğŸ“Š Latest block: $block_hex"
                                fi
                            fi
                        else
                            if [ "$verbose" = true ]; then
                                echo "   âš ï¸  Could not retrieve block number"
                            fi
                        fi
                    fi
                else
                    if [ "$verbose" = true ]; then
                        echo "   âš ï¸  Block number test failed (HTTP $http_code)"
                    fi
                fi
            else
                if [ "$verbose" = true ]; then
                    echo "   âš ï¸  Block number test connection failed"
                fi
            fi

            return 0

        elif [ "$http_code" -eq 405 ]; then
            if [ "$verbose" = true ]; then
                echo "   âŒ RPC endpoint doesn't support POST method (HTTP $http_code)"
                echo "   ğŸ’¡ Check if the URL is correct and supports JSON-RPC"
            fi
            return 1
        elif [ "$http_code" -eq 404 ]; then
            if [ "$verbose" = true ]; then
                echo "   âŒ RPC endpoint not found (HTTP $http_code)"
                echo "   ğŸ’¡ Check if the URL path is correct"
            fi
            return 1
        elif [ "$http_code" -ge 500 ]; then
            if [ "$verbose" = true ]; then
                echo "   âŒ RPC server error (HTTP $http_code)"
                echo "   ğŸ’¡ The RPC server might be temporarily unavailable"
            fi
            return 1
        else
            if [ "$verbose" = true ]; then
                echo "   âŒ RPC connectivity test failed (HTTP $http_code)"
                if [ -n "$response_body" ]; then
                    echo "   Response: $(echo "$response_body" | cut -c1-200)..."
                fi
            fi
            return 1
        fi
    else
        if [ "$verbose" = true ]; then
            echo "   âŒ Cannot reach L2 RPC endpoint"
            echo "   ğŸ’¡ Check your internet connection and RPC URL"
            echo "   ğŸ’¡ If using a local node, ensure it's running and accessible"
        fi
        return 1
    fi
}

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç¢ºèªã‚’æ±‚ã‚ã‚‹é–¢æ•°
confirm_action() {
    local message="${1:-Are you sure?}"  # ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "Are you sure?"ï¼‰
    local default="${2:-N}"              # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "N"ï¼‰

    echo "â“ $message (y/n)"

    read -p "Enter your choice: " confirm

    case "$confirm" in
        [yY]|[yY][eE][sS])
            echo "âœ… Proceeding..."
            return 0
            ;;
        [nN]|[nN][oO])
            echo "âŒ Operation cancelled"
            return 1
            ;;
        "")
            if [[ "$default" == "Y" || "$default" == "y" ]]; then
                echo "âœ… Proceeding (default: Yes)..."
                return 0
            else
                echo "âŒ Operation cancelled (default: No)"
                return 1
            fi
            ;;
        *)
            echo "âŒ Invalid input. Operation cancelled"
            return 1
            ;;
    esac
}

# åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°ï¼ˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆï¼‰
setup() {
    # ç¾åœ¨ã®ç’°å¢ƒè¨­å®šã‚’è¡¨ç¤º
    show_current_environment

    # å¿…è¦ãªãƒ„ãƒ¼ãƒ«ã®å­˜åœ¨ç¢ºèª
    echo "ğŸ” Checking required tools..."
    if ! check_required_tools; then
        echo "âŒ Setup cannot continue without required tools"
        echo "Please install the missing tools and try again"
        exit 1
    fi
    echo ""

    # æ—¢å­˜ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯è­¦å‘Šã—ã¦çµ‚äº†
    if [ -f "frpc.toml" ] || [ -f "docker-compose.yml" ] || [ -f ".env.${ENVIRONMENT}" ] || [ -f "nginx.conf" ]; then
        echo "âš ï¸  Setup files already exist. The following files were found:"
        [ -f "frpc.toml" ] && echo "   - frpc.toml"
        [ -f "docker-compose.yml" ] && echo "   - docker-compose.yml"
        [ -f ".env.${ENVIRONMENT}" ] && echo "   - .env.${ENVIRONMENT}"
        [ -f "nginx.conf" ] && echo "   - nginx.conf"
        echo ""
        echo "ğŸ§¹ Please run cleanup first before setting up again:"
        echo "   $0 clean"
        echo ""
        echo "ğŸ’¡ Or if you want to start fresh automatically:"
        echo "   $0 clean && $0 setup"
        return 1
    fi
    
    # APIè¨­å®šã‚’èª­ã¿è¾¼ã¿
    load_config

    # ä¸€æ„è­˜åˆ¥å­ï¼ˆUUIDï¼‰ã‚’ç”Ÿæˆ
    uuid=$(generate_uuid)
    if [ $? -ne 0 ]; then
        echo "âŒ Failed to generate UUID"
        exit 1
    fi

    # ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«å¿œã˜ãŸDockerã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’é¸æŠ
    docker_image=$(detect_architecture)

    cat > frpc.toml << EOF
serverAddr = "$PROXY_DOMAIN"
serverPort = 7000
auth.token = "$FRP_TOKEN"

[[proxies]]
name = "$uuid-block-builder"
type = "http"
localIP = "nginx-proxy-$ENVIRONMENT"
localPort = 3000
customDomains = ["$PROXY_DOMAIN"]
locations = ["/$uuid"]
EOF

    cat > nginx.conf << EOF
events {
    worker_connections 1024;
}
http {
    upstream block_builder_${ENVIRONMENT} {
        server block-builder-${ENVIRONMENT}:8080;
    }
    server {
        listen 3000;
        location ~ "^/([^/]+)(/.*)$" {
            proxy_pass http://block_builder_${ENVIRONMENT}\$2;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Namespace \$1;
        }
        location / {
            return 404;
        }
    }
}
EOF

    cat > docker-compose.yml << 'EOF'
services:
  nginx-proxy-ENVIRONMENT:
    image: nginx:alpine
    ports:
      - "3000:3000"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - builder-network-ENVIRONMENT
    tmpfs:
      - /var/cache/nginx
      - /var/run
      - /tmp
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  block-builder-ENVIRONMENT:
    image: DOCKER_IMAGE_PLACEHOLDER
    command:
      [
        "export BLOCK_BUILDER_PRIVATE_KEY=$$(cat /run/secrets/block_builder_private_key_ENVIRONMENT | tr -d '\n') && exec /app/block-builder",
      ]
    env_file:
      - .env.ENVIRONMENT
    environment:
      - PORT=8080
      - BLOCK_BUILDER_URL=https://PROXY_DOMAIN_PLACEHOLDER/UUID_PLACEHOLDER
    secrets:
      - block_builder_private_key_ENVIRONMENT
    networks:
      - builder-network-ENVIRONMENT
    healthcheck:
      disable: true
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  frp-client-ENVIRONMENT:
    image: snowdreamtech/frpc:latest
    volumes:
      - ./frpc.toml:/etc/frp/frpc.toml:ro
    networks:
      - builder-network-ENVIRONMENT
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  builder-network-ENVIRONMENT:
    driver: overlay
    attachable: true

secrets:
  block_builder_private_key_ENVIRONMENT:
    external: true
EOF

sed -i.tmp "s|DOCKER_IMAGE_PLACEHOLDER|$docker_image|g" docker-compose.yml && rm -f docker-compose.yml.tmp
sed -i.tmp "s|PROXY_DOMAIN_PLACEHOLDER|$PROXY_DOMAIN|g" docker-compose.yml && rm -f docker-compose.yml.tmp
sed -i.tmp "s|UUID_PLACEHOLDER|$uuid|g" docker-compose.yml && rm -f docker-compose.yml.tmp
sed -i.tmp "s|ENVIRONMENT|$ENVIRONMENT|g" docker-compose.yml && rm -f docker-compose.yml.tmp

    cat > ".env.${ENVIRONMENT}" << EOF
#######
# Contents of .env.${ENVIRONMENT} for ${ENVIRONMENT}
#######

# app settings
PORT=8080

# builder settings
ETH_ALLOWANCE_FOR_BLOCK=0.001
TX_TIMEOUT=80
ACCEPTING_TX_INTERVAL=30
PROPOSING_BLOCK_INTERVAL=30
INITIAL_HEART_BEAT_DELAY=180
HEART_BEAT_INTERVAL=85800
GAS_LIMIT_FOR_BLOCK_POST=400000
CLUSTER_ID=1

# fee settings
REGISTRATION_FEE=${REGISTRATION_FEE}
NON_REGISTRATION_FEE=${NON_REGISTRATION_FEE}

# external settings
ENV=${ENV}
STORE_VAULT_SERVER_BASE_URL=${STORE_VAULT_SERVER_BASE_URL}
USE_S3=true
VALIDITY_PROVER_BASE_URL=${VALIDITY_PROVER_BASE_URL}
L2_RPC_URL=<your-rpc-url>
ROLLUP_CONTRACT_ADDRESS=${ROLLUP_CONTRACT_ADDRESS}
BLOCK_BUILDER_REGISTRY_CONTRACT_ADDRESS=${BLOCK_BUILDER_REGISTRY_CONTRACT_ADDRESS}
EOF

    echo "âœ… Configuration files created with UUID: $uuid"
    echo "ğŸ—ï¸  Architecture: $(uname -m)"
    echo "ğŸ³ Docker image: $docker_image"
    echo "ğŸŒ Proxy domain: $PROXY_DOMAIN"
    echo "ğŸ”— Block builder URL: https://$PROXY_DOMAIN/$uuid"
    echo "ğŸ“„ Files created:"
    echo "   - frpc.toml"
    echo "   - nginx.conf"
    echo "   - docker-compose.yml"
    echo "   - .env.${ENVIRONMENT}"
    echo ""
    echo "ğŸ”§ Next steps:"
    echo "   1. Set up env: $0 setup-env"
    echo "   2. Run: $0 check"
    echo "   3. Run: $0 run"
}

# ç’°å¢ƒè¨­å®šã‚’è¡Œã†é–¢æ•°ï¼ˆRPC URL ã¨ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚­ãƒ¼ã®è¨­å®šï¼‰
setup_env() {
    echo "ğŸŒ Setting up environment configuration..."

    # ç’°å¢ƒè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    local env_file=".env.${ENVIRONMENT}"

    if [ ! -f "$env_file" ]; then
        echo "âŒ $env_file file not found"
        echo "ğŸ’¡ Run: $0 setup first to create the initial $env_file file"
        return 1
    fi

    # Dockerã®çŠ¶æ…‹ç¢ºèª
    echo "ğŸ³ Checking Docker status..."
    if ! docker info >/dev/null 2>&1; then
        echo "âŒ Docker is not running or not accessible"
        echo "ğŸ’¡ Please start Docker and try again"
        return 1
    fi

    # Docker Swarmã®æœ‰åŠ¹æ€§ç¢ºèª
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        echo "âŒ Docker Swarm is not active"
        echo "ğŸ’¡ Run: docker swarm init"
        echo "ğŸ”„ After running 'docker swarm init', please re-execute the command"
        return 1
    fi

    echo ""
    echo "ğŸ”§ This command will configure:"
    echo "   1. L2_RPC_URL in .env file"
    echo "   2. Private key as Docker secret"
    echo ""

    echo "ğŸ“ L2 RPC URL configuration:"
    echo "   This should be a valid HTTP/HTTPS URL to your Scroll (Sepolia) RPC endpoint"
    echo "   Examples:"
    echo ""
    echo "Mainnet RPC URLs:"
    echo "  â€¢ https://scroll-mainnet.infura.io/v3/YOUR_PROJECT_ID"
    echo "  â€¢ https://scroll-mainnet.g.alchemy.com/v2/YOUR_API_KEY"
    echo ""
    echo "Testnet RPC URLs:"
    echo "  â€¢ https://scroll-sepolia.infura.io/v3/YOUR_PROJECT_ID"
    echo "  â€¢ https://scroll-sepolia.g.alchemy.com/v2/YOUR_API_KEY"
    echo ""

    update_rpc=true
    current_rpc_url=$(grep "^L2_RPC_URL=" "$env_file" 2>/dev/null | cut -d'=' -f2-)
    if [ -n "$current_rpc_url" ] && [ "$current_rpc_url" != "<your-rpc-url>" ]; then
        echo "ğŸ”„ Current L2_RPC_URL: $current_rpc_url"
        echo "ğŸ”„ Do you want to update the existing L2_RPC_URL? (y/n)"
        echo -n "> "
        read -r update_rpc_choice

        if [ "$update_rpc_choice" != "y" ] && [ "$update_rpc_choice" != "Y" ]; then
            echo "â„¹ï¸  Keeping existing L2_RPC_URL configuration"
            l2_rpc_url="$current_rpc_url"
            update_rpc=false
        fi
    fi

    if [ "$update_rpc" = true ]; then
        echo ""
        echo "ğŸŒ Please enter your L2 RPC URL:"
        echo -n "> "
        read -r l2_rpc_url
        echo ""

        if [ -z "$l2_rpc_url" ]; then
            echo "âŒ L2 RPC URL cannot be empty"
            return 1
        fi

        if ! echo "$l2_rpc_url" | grep -qE '^https?://[a-zA-Z0-9.-]+'; then
            echo "âŒ Invalid URL format"
            echo "   L2 RPC URL must start with http:// or https://"
            echo "   Your input: $l2_rpc_url"
            return 1
        fi

        l2_rpc_url=$(echo "$l2_rpc_url" | sed 's|/$||')
    fi

    echo ""
    echo "ğŸ” Private key configuration:"

    local secret_name="block_builder_private_key_${ENVIRONMENT}"

    update_private_key=true
    if docker secret ls | grep -q "$secret_name"; then
        echo "âš ï¸  Docker secret '$secret_name' already exists"
        echo ""
        echo "ğŸ”„ Do you want to overwrite the existing private key? (y/n)"
        echo -n "> "
        read -r overwrite_choice

        if [ "$overwrite_choice" != "y" ] && [ "$overwrite_choice" != "Y" ]; then
            echo "â„¹ï¸  Keeping existing private key configuration"
            update_private_key=false
        else
            echo "ğŸ—‘ï¸  Removing existing secret..."
            docker secret rm "$secret_name" || {
                echo "âŒ Failed to remove existing secret"
                return 1
            }
            echo "âœ… Existing secret removed"
        fi
    fi

    if [ "$update_private_key" = true ]; then
        echo ""
        echo "ğŸ“ Private key format requirements:"
        echo "   - Can be with or without '0x' prefix"
        echo "   - 64 characters (raw hex) or 66 characters (with 0x)"
        echo "   - Examples:"
        echo "     â€¢ 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        echo "     â€¢   1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        echo ""
        echo "ğŸ” Please enter your private key:"
        echo -n "> "
        read -s private_key
        echo ""

        if [ -z "$private_key" ]; then
            echo "âŒ Private key cannot be empty"
            return 1
        fi

        private_key=$(echo "$private_key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        has_0x_prefix=false
        if echo "$private_key" | grep -q "^0x"; then
            has_0x_prefix=true
            hex_part=$(echo "$private_key" | cut -c3-)
            expected_length=66
        else
            hex_part="$private_key"
            expected_length=64
        fi

        key_length=$(echo -n "$private_key" | wc -c)
        hex_length=$(echo -n "$hex_part" | wc -c)

        if [ "$key_length" -ne "$expected_length" ]; then
            echo "âŒ Invalid private key length"
            echo "   Your input length: $key_length characters"
            if [ "$has_0x_prefix" = true ]; then
                echo "   Expected: 66 characters (0x + 64 hex characters)"
            else
                echo "   Expected: 64 characters (raw hex) or 66 characters (with 0x prefix)"
            fi
            return 1
        fi

        if ! echo "$hex_part" | grep -q "^[0-9a-fA-F]\{64\}$"; then
            echo "âŒ Private key contains invalid characters"
            echo "   Only hexadecimal characters (0-9, a-f, A-F) are allowed"
            if [ "$has_0x_prefix" = true ]; then
                echo "   Invalid part: $(echo "$hex_part" | cut -c1-10)..."
            else
                echo "   Invalid part: $(echo "$private_key" | cut -c1-10)..."
            fi
            return 1
        fi

        if [ "$has_0x_prefix" = false ]; then
            echo "ğŸ’¡ Adding '0x' prefix to private key"
            private_key="0x$private_key"
            key_length=66
        fi
    fi

    echo ""
    echo "ğŸ’¾ Applying configurations..."

    if [ "$update_rpc" = true ]; then
        if grep -q "^L2_RPC_URL=" "$env_file"; then
            sed -i.tmp "s|^L2_RPC_URL=.*|L2_RPC_URL=$l2_rpc_url|" "$env_file" && rm -f "${env_file}.tmp"
            echo "âœ… Updated L2_RPC_URL in $env_file file"
        else
            echo "L2_RPC_URL=$l2_rpc_url" >> "$env_file"
            echo "âœ… Added L2_RPC_URL to $env_file file"
        fi
    else
        echo "â„¹ï¸  L2_RPC_URL unchanged"
    fi

    if [ "$update_private_key" = true ]; then
       echo "$private_key" | docker secret create "$secret_name" - 2>/dev/null || {
            echo "âŒ Failed to create Docker secret"
            echo "ğŸ’¡ Make sure Docker Swarm is properly initialized"
            return 1
        }
        echo "âœ… Private key stored as Docker secret: $secret_name"
    else
        echo "â„¹ï¸  Private key unchanged"
    fi

    echo ""
    echo "ğŸ“Š Configuration Summary:"
    echo "   L2_RPC_URL: $l2_rpc_url"

    if echo "$l2_rpc_url" | grep -q "localhost\|127.0.0.1"; then
        echo "   RPC Type: Local endpoint âš ï¸"
        echo "   Note: Make sure your local node is accessible from Docker containers"
    elif echo "$l2_rpc_url" | grep -q "^https://"; then
        echo "   RPC Type: HTTPS endpoint âœ…"
    elif echo "$l2_rpc_url" | grep -q "^http://"; then
        echo "   RPC Type: HTTP endpoint âš ï¸"
        echo "   Note: Consider using HTTPS for production"
    fi

    if [ "$update_private_key" = true ]; then
        echo "   Private key length: $key_length characters âœ…"
        if [ "$has_0x_prefix" = false ]; then
            echo "   Private key format: 0x prefix added âœ…"
        else
            echo "   Private key format: 0x prefix found âœ…"
        fi
        echo "   Hex validation: âœ…"

        start=$(echo "$private_key" | cut -c1-7)
        end=$(echo "$private_key" | cut -c62-66)
        echo "   Private key preview: ${start}...${end}"
    else
        echo "   Private key: Using existing secret âœ…"
    fi

    unset private_key
    unset l2_rpc_url
    unset hex_part
    unset start
    unset end
    unset has_0x_prefix
    unset update_rpc
    unset update_private_key

    echo ""
    echo "ğŸ‰ Environment configuration completed!"
    echo ""
    echo "ğŸ’¡ Next steps:"
    echo "   0. Verify configuration (Optional): $0 verify-env"
    echo "   1. Check overall setup: $0 check"
    echo "   2. Start services: $0 run"
}

# ç’°å¢ƒè¨­å®šã®å¦¥å½“æ€§ã‚’æ¤œè¨¼ã™ã‚‹é–¢æ•°
verify_env() {
    echo "ğŸ” Verifying environment configuration..."

    # ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    local env_file=".env.${ENVIRONMENT}"

    if [ ! -f "$env_file" ]; then
        echo "âŒ $env_file file not found"
        echo "ğŸ’¡ Run: $0 setup first to create the initial $env_file file"
        return 1
    fi

    echo "âœ… $env_file file exists"
    echo ""

    # æ¤œè¨¼çµæœã‚’è¿½è·¡ã™ã‚‹ãƒ•ãƒ©ã‚°
    local verification_passed=true
    local network_mismatch=false

    # L2_RPC_URL ã®è¨­å®šç¢ºèª
    echo "ğŸŒ Checking L2_RPC_URL configuration..."
    local l2_rpc_url=$(grep "^L2_RPC_URL=" "$env_file" 2>/dev/null | cut -d'=' -f2-)

    if [ -z "$l2_rpc_url" ]; then
        echo "âŒ L2_RPC_URL not found in $env_file file"
        verification_passed=false
    elif [ "$l2_rpc_url" = "<your-rpc-url>" ]; then
        echo "âš ï¸  L2_RPC_URL is still set to placeholder value"
        verification_passed=false
    else
        echo "âœ… L2_RPC_URL is configured: $l2_rpc_url"

        if echo "$l2_rpc_url" | grep -qE '^https?://[a-zA-Z0-9.-]+'; then
            echo "   Format: Valid URL âœ…"

            if echo "$l2_rpc_url" | grep -q "localhost\|127.0.0.1"; then
                echo "   Type: Local endpoint âš ï¸"
                echo "   Note: Ensure your local node is accessible from Docker containers"
            elif echo "$l2_rpc_url" | grep -q "^https://"; then
                echo "   Security: HTTPS âœ…"
            elif echo "$l2_rpc_url" | grep -q "^http://"; then
                echo "   Security: HTTP âš ï¸ (Consider HTTPS for production)"
            fi

            echo ""
            if check_rpc_connectivity "$l2_rpc_url" true; then
                echo "   Connectivity: âœ…"

                local network_id=$(get_network_id "$l2_rpc_url")
                local expected_network_id=""
                local expected_network_name=""

                case "${ENVIRONMENT}" in
                    "devnet"|"testnet")
                        expected_network_id="534351"
                        expected_network_name="Scroll Sepolia Testnet"
                        ;;
                    "mainnet")
                        expected_network_id="534352"
                        expected_network_name="Scroll Mainnet"
                        ;;
                    *)
                        echo "   Network: Unknown environment '$ENVIRONMENT', skipping network validation"
                        ;;
                esac

                if [ -n "$expected_network_id" ] && [ -n "$network_id" ]; then
                    if [ "$network_id" = "$expected_network_id" ]; then
                        echo "   Network: âœ… Correct network (Chain ID: $network_id - $expected_network_name)"
                    else
                        echo "   Network: âŒ NETWORK MISMATCH DETECTED!"
                        echo "   Expected: Chain ID $expected_network_id ($expected_network_name)"
                        echo "   Actual: Chain ID $network_id"
                        echo ""
                        echo "ğŸš¨ CRITICAL WARNING: NETWORK CONFIGURATION MISMATCH!"
                        echo "   Environment: $ENVIRONMENT"
                        echo "   Expected Network: $expected_network_name (Chain ID: $expected_network_id)"
                        echo "   Connected Network: Chain ID $network_id"
                        echo ""
                        echo "   This configuration mismatch could lead to:"
                        echo "   â€¢ Transactions sent to wrong network"
                        echo "   â€¢ Funds lost or stuck"
                        echo "   â€¢ Application malfunction"
                        echo ""
                        echo "   ğŸ’¡ Recommended actions:"
                        echo "   1. Verify your L2_RPC_URL in $env_file"
                        echo "   2. Ensure you're using the correct RPC endpoint for $ENVIRONMENT"
                        echo "   3. Update RPC URL to match expected network: $expected_network_name"
                        echo ""
                        network_mismatch=true
                        verification_passed=false
                    fi
                fi
            else
                echo "   Connectivity: âŒ"
                verification_passed=false
            fi
        else
            echo "   Format: Invalid URL âŒ"
            echo "   Expected: http:// or https:// URL"
            verification_passed=false
        fi
    fi

    echo ""

    echo "ğŸ” Checking private key configuration..."

    local secret_name="block_builder_private_key_${ENVIRONMENT}"

    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        echo "âŒ Docker Swarm is not active"
        echo "ğŸ’¡ Run: docker swarm init"
        verification_passed=false
    else
        if docker secret ls 2>/dev/null | grep -q "$secret_name"; then
            echo "âœ… Docker secret '$secret_name' exists"

            echo "ğŸ” Verifying private key content..."

            docker service create \
                --name temp-secret-reader \
                --secret "$secret_name" \
                --detach \
                alpine:latest \
                sleep 30 > /dev/null 2>&1

            sleep 3

            container_id=$(docker ps --filter "label=com.docker.swarm.service.name=temp-secret-reader" --format "{{.ID}}")

            if [ -n "$container_id" ]; then
                private_key_content=$(docker exec "$container_id" cat "/run/secrets/$secret_name" 2>/dev/null)

                if [ -n "$private_key_content" ]; then
                    if echo "$private_key_content" | grep -q "^0x[0-9a-fA-F]\{64\}$"; then
                        echo "   Format: Valid private key âœ…"
                        start=$(echo "$private_key_content" | cut -c1-7)
                        end=$(echo "$private_key_content" | cut -c62-66)
                        echo "   Preview: ${start}...${end}"
                    else
                        echo "   Format: Invalid private key âŒ"
                        verification_passed=false
                    fi
                else
                    echo "   Content: Empty or inaccessible âŒ"
                    verification_passed=false
                fi
            else
                echo "   Verification: Could not access secret content âš ï¸"
            fi

            docker service rm temp-secret-reader > /dev/null 2>&1

        else
            echo "âŒ Docker secret '$secret_name' not found"
            verification_passed=false
        fi
    fi

    echo ""

    echo "ğŸ“„ Environment verification summary:"
    echo "   .env file: âœ…"

    if [ "$verification_passed" = true ]; then
        echo "   L2_RPC_URL: âœ…"
        echo "   Private key: âœ…"
        echo ""
        echo "âœ… All environment configurations are valid!"

        echo ""
        echo "ğŸ’¡ Next steps:"
        echo "   1. Check overall setup: $0 check"
        echo "   2. Start services: $0 run"

        return 0
    else
        echo "   Configuration: âŒ Issues found"
        echo ""

        if [ "$network_mismatch" = true ]; then
            echo "ğŸš¨ ENVIRONMENT VERIFICATION FAILED - CRITICAL NETWORK MISMATCH!"
            echo ""
            echo "â›” DO NOT PROCEED with current configuration!"
            echo "   Continuing could result in:"
            echo "   â€¢ Transactions on wrong network"
            echo "   â€¢ Loss of funds"
            echo "   â€¢ System malfunction"
            echo ""
            echo "ğŸ”§ REQUIRED ACTION:"
            echo "   Update L2_RPC_URL in $env_file to match $ENVIRONMENT environment"
        else
            echo "âŒ Environment verification failed"
        fi

        echo "ğŸ’¡ Run: $0 setup-env to configure missing settings"
        return 1
    fi
}

get_network_id() {
    local rpc_url="$1"
    local response=$(curl -s -X POST "$rpc_url" \
        -H "Content-Type: application/json" \
        -d '{"jsonrpc":"2.0","method":"net_version","params":[],"id":1}' \
        2>/dev/null)

    if [ $? -eq 0 ] && [ -n "$response" ]; then
        echo "$response" | grep -o '"result":"[^"]*"' | cut -d'"' -f4
    fi
}

check() {
    show_current_environment

    echo "ğŸ” Checking required tools..."
    if ! check_required_tools; then
        echo ""
        echo "âŒ Required tools are missing. Please install them before proceeding."
        return 1
    fi
    echo ""

    local files_exist=true
    local config_valid=true
    local network_mismatch=false

    local env_file=".env.${ENVIRONMENT}"

    if [ -f "frpc.toml" ]; then
        echo "âœ… frpc.toml exists"
    else
        echo "âŒ frpc.toml not found"
        files_exist=false
    fi

    if [ -f "nginx.conf" ]; then
        echo "âœ… nginx.conf exists"
    else
        echo "âŒ nginx.conf not found"
        files_exist=false
    fi

    if [ -f "docker-compose.yml" ]; then
        echo "âœ… docker-compose.yml exists"
    else
        echo "âŒ docker-compose.yml not found"
        files_exist=false
    fi

    if [ -f "$env_file" ]; then
        echo "âœ… $env_file exists"
        echo ""

        echo "ğŸŒ Checking L2_RPC_URL configuration..."
        local l2_rpc_url=$(grep "^L2_RPC_URL=" "$env_file" 2>/dev/null | cut -d'=' -f2-)

        if [ -z "$l2_rpc_url" ]; then
            echo "âŒ L2_RPC_URL not found in $env_file file"
            config_valid=false
        elif [ "$l2_rpc_url" = "<your-rpc-url>" ]; then
            echo "âš ï¸  L2_RPC_URL is still set to placeholder value"
            echo "   Current value: $l2_rpc_url"
            echo "ğŸ’¡ Run: $0 setup-env to configure L2_RPC_URL"
            config_valid=false
        else
            echo "âœ… L2_RPC_URL is configured"
            echo "   Value: $l2_rpc_url"

            if echo "$l2_rpc_url" | grep -qE '^https?://[a-zA-Z0-9.-]+'; then
                echo "   Format: Valid URL âœ…"

                if echo "$l2_rpc_url" | grep -q "^https://"; then
                    echo "   Security: HTTPS âœ…"
                elif echo "$l2_rpc_url" | grep -q "^http://"; then
                    echo "   Security: HTTP âš ï¸"
                fi

                echo ""
                if check_rpc_connectivity "$l2_rpc_url" true; then
                    echo ""

                    local network_id=$(get_network_id "$l2_rpc_url")
                    local expected_network_id=""
                    local expected_network_name=""

                    case "${ENVIRONMENT}" in
                        "devnet"|"testnet")
                            expected_network_id="534351"
                            expected_network_name="Scroll Sepolia Testnet"
                            ;;
                        "mainnet")
                            expected_network_id="534352"
                            expected_network_name="Scroll Mainnet"
                            ;;
                        *)
                            echo "   Network: Unknown environment '$ENVIRONMENT', skipping network validation"
                            ;;
                    esac

                    if [ -n "$expected_network_id" ] && [ -n "$network_id" ]; then
                        if [ "$network_id" = "$expected_network_id" ]; then
                            echo "   Network: âœ… Correct network (Chain ID: $network_id - $expected_network_name)"
                        else
                            echo "   Network: âŒ NETWORK MISMATCH DETECTED!"
                            echo "   Expected: Chain ID $expected_network_id ($expected_network_name)"
                            echo "   Actual: Chain ID $network_id"
                            echo ""
                            echo "ğŸš¨ CRITICAL WARNING: NETWORK CONFIGURATION MISMATCH!"
                            echo "   Environment: $ENVIRONMENT"
                            echo "   Expected Network: $expected_network_name (Chain ID: $expected_network_id)"
                            echo "   Connected Network: Chain ID $network_id"
                            echo ""
                            echo "   This configuration mismatch could lead to:"
                            echo "   â€¢ Transactions sent to wrong network"
                            echo "   â€¢ Funds lost or stuck"
                            echo "   â€¢ Application malfunction"
                            echo ""
                            echo "   ğŸ’¡ Recommended actions:"
                            echo "   1. Verify your L2_RPC_URL in $env_file"
                            echo "   2. Ensure you're using the correct RPC endpoint for $ENVIRONMENT"
                            echo "   3. Update RPC URL to match expected network: $expected_network_name"
                            echo ""
                            network_mismatch=true
                            config_valid=false
                        fi
                    fi
                else
                    config_valid=false
                fi
            else
                echo "   Format: Invalid URL âŒ"
                echo "   Expected: http:// or https:// URL"
                config_valid=false
            fi
        fi
        echo ""
    else
        echo "âŒ $env_file not found"
        files_exist=false
    fi

    echo "ğŸ” Checking private key configuration..."
    if ! check_private_key_config; then
        config_valid=false
    fi
    echo ""

    if [ "$files_exist" = false ]; then
        echo "âŒ Missing configuration files"
        echo "ğŸ’¡ Run: $0 setup"
        return 1
    fi

    if [ "$config_valid" = false ]; then
        if [ "$network_mismatch" = true ]; then
            echo "ğŸš¨ CONFIGURATION VALIDATION FAILED - CRITICAL NETWORK MISMATCH!"
            echo ""
            echo "â›” DO NOT PROCEED with current configuration!"
            echo "   Continuing could result in:"
            echo "   â€¢ Transactions on wrong network"
            echo "   â€¢ Loss of funds"
            echo "   â€¢ System malfunction"
            echo ""
            echo "ğŸ”§ REQUIRED ACTION:"
            echo "   Update L2_RPC_URL in $env_file to match $ENVIRONMENT environment"
            echo ""
            echo "ğŸ’¡ Fix network configuration: $0 setup-env"
        else
            echo "âŒ Configuration validation failed"
            echo "ğŸ’¡ Run: $0 setup-env to fix configuration issues"
        fi
        return 1
    fi

    if [ -f "frpc.toml" ]; then
        local server_addr=$(grep "serverAddr" frpc.toml | sed 's/serverAddr = "\([^"]*\)"/\1/')
        local uuid=$(grep "locations" frpc.toml | sed 's/.*\/\([^"]*\)".*/\1/')

        if [ -n "$server_addr" ] && [ -n "$uuid" ]; then
            echo "ğŸŒ Your block builder URL: https://${server_addr}/${uuid}"
            echo ""
        fi
    fi

    echo "ğŸ“„ frpc.toml content:"
    sed 's/\(auth\.token = "\)\([^"]\{5\}\)[^"]*\([^"]\{5\}\)\(".*\)/\1\2...\3\4/' frpc.toml
    echo ""

    echo "ğŸ‰ All checks passed! Your configuration is ready:"
    echo "   âœ… Configuration files exist"
    echo "   âœ… L2 RPC URL is configured and accessible"
    echo "   âœ… Network configuration is correct"
    echo "   âœ… Private key is configured"
    echo ""
    echo "ğŸ’¡ Next step: $0 run"
}

# Docker Stackã‚µãƒ¼ãƒ“ã‚¹ã‚’èµ·å‹•ã™ã‚‹é–¢æ•°
run() {
    # ç¾åœ¨ã®ç’°å¢ƒè¨­å®šã‚’è¡¨ç¤º
    show_current_environment

    # å¿…è¦ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    if [ ! -f "frpc.toml" ] || [ ! -f "nginx.conf" ]; then
        echo "âŒ Configuration files not found"
        echo "Run: $0 setup first"
        return 1
    fi

    # Dockerã®çŠ¶æ…‹ç¢ºèª
    echo "ğŸ³ Checking Docker status..."
    if ! docker info >/dev/null 2>&1; then
        echo "âŒ Docker is not running or not accessible"
        echo "ğŸ’¡ Please start Docker and try again"
        return 1
    fi

    # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚­ãƒ¼è¨­å®šã®ç¢ºèª
    echo "ğŸ” Checking private key configuration..."
    if ! check_private_key_config; then
        echo "âŒ Cannot start without private key configuration"
        return 1
    fi
    echo ""

    echo "ğŸŒ Checking .env configuration..."
    local env_file=".env.${ENVIRONMENT}"

    if [ ! -f "$env_file" ]; then
        echo "âŒ $env_file file not found"
        echo "ğŸ’¡ Run: $0 setup first to create the initial $env_file file"
        return 1
    fi

    local l2_rpc_url=$(grep "^L2_RPC_URL=" "$env_file" 2>/dev/null | cut -d'=' -f2-)

    if [ -z "$l2_rpc_url" ]; then
        echo "âŒ L2_RPC_URL not found in $env_file file"
        echo "ğŸ’¡ Run: $0 setup-env to configure L2_RPC_URL"
        return 1
    elif [ "$l2_rpc_url" = "<your-rpc-url>" ]; then
        echo "âŒ L2_RPC_URL is still set to placeholder value"
        echo "   Current value: $l2_rpc_url"
        echo "ğŸ’¡ Run: $0 setup-env to configure L2_RPC_URL and private key"
        return 1
    else
        echo "âœ… L2_RPC_URL is configured: $l2_rpc_url"
        if ! echo "$l2_rpc_url" | grep -qE '^https?://[a-zA-Z0-9.-]+'; then
            echo "âŒ Invalid L2_RPC_URL format"
            echo "   Current value: $l2_rpc_url"
            echo "ğŸ’¡ Run: $0 setup-env to fix L2_RPC_URL configuration"
            return 1
        fi
    fi

    server_addr=$(grep "serverAddr" frpc.toml | sed 's/serverAddr = "\([^"]*\)"/\1/')
    uuid=$(grep "locations" frpc.toml | sed 's/.*\/\([^"]*\)".*/\1/')

    if [ -z "$server_addr" ] || [ -z "$uuid" ]; then
        echo "âŒ serverAddr or UUID not found in frpc.toml"
        return 1
    fi

    block_builder_url="https://${server_addr}/${uuid}"

    echo "ğŸš€ Starting Docker Stack..."
    echo "ğŸ“ BLOCK_BUILDER_URL: $block_builder_url"
    echo ""
    echo "ğŸ©º Health Check Command:"
    echo "   curl ${block_builder_url}/health-check"
    echo ""

     if ! check_docker_swarm >/dev/null 2>&1; then
        echo "âš ï¸  Docker Swarm is not active, initializing..."
        docker swarm init
        echo "âœ… Docker Swarm initialized"
    fi

    stack_name="block-builder-stack-${ENVIRONMENT}"

    BLOCK_BUILDER_URL="$block_builder_url" docker stack deploy --detach=true -c docker-compose.yml "$stack_name"
    echo "âœ… Started successfully as Docker Stack"
    echo ""
    echo "ğŸ’¡ To check health, run: $0 health"
    echo "ğŸ’¡ To monitor the services, run: $0 monitor"
}

# Docker Stackã‚µãƒ¼ãƒ“ã‚¹ã‚’åœæ­¢ã™ã‚‹é–¢æ•°
stop() {
    # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    if [ ! -f "docker-compose.yml" ]; then
        echo "âŒ docker-compose.yml not found"
        echo "Run: $0 setup first"
        return 1
    fi

    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèª
    if ! confirm_action "Are you sure you want to stop Docker Stack services?"; then
        return 0
    fi

    echo "ğŸ›‘ Stopping Docker Stack services..."

    # Dockerã®çŠ¶æ…‹ç¢ºèª
    echo "ğŸ³ Checking Docker status..."
    if ! docker info >/dev/null 2>&1; then
        echo "âŒ Docker is not running or not accessible"
        echo "ğŸ’¡ Please start Docker and try again"
        return 1
    fi

    # Docker Swarmã®çŠ¶æ…‹ç¢ºèª
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        echo "âš ï¸  Docker Swarm is not active, no stack to stop"
        return 0
    fi

    stack_name="block-builder-stack-${ENVIRONMENT}"

    if docker stack ls | grep -q "$stack_name"; then
        docker stack rm "$stack_name"
        echo "âœ… Docker Stack '$stack_name' removed successfully"

        echo "â³ Waiting for services to be completely removed..."
        sleep 5

        while docker service ls | grep -q "$stack_name"; do
            echo "   Still removing services..."
            sleep 2
        done

        echo "âœ… All stack services stopped successfully"
    else
        echo "â„¹ï¸  Stack '$stack_name' not found or already stopped"
    fi

    echo ""
    echo "ğŸ’¡ To restart, run: $0 run"
}

# ãƒ–ãƒ­ãƒƒã‚¯ãƒ“ãƒ«ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
health_check() {
    echo "ğŸ©º Testing your block builder health..."

    # curlã‚³ãƒãƒ³ãƒ‰ã®å­˜åœ¨ç¢ºèª
    if ! command -v curl >/dev/null 2>&1; then
        echo "âŒ curl not found. Cannot test health check."
        return 1
    fi

    # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    if [ ! -f "frpc.toml" ]; then
        echo "âŒ frpc.toml not found"
        echo "ğŸ’¡ Run: $0 setup first to create configuration"
        return 1
    fi

    # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨UUIDã‚’æŠ½å‡º
    local server_addr=$(grep "serverAddr" frpc.toml | sed 's/serverAddr = "\([^"]*\)"/\1/')
    local uuid=$(grep "locations" frpc.toml | sed 's/.*\/\([^"]*\)".*/\1/')

    if [ -z "$server_addr" ] || [ -z "$uuid" ]; then
        echo "âŒ Could not extract server address or UUID from frpc.toml"
        return 1
    fi

    local block_builder_url="https://${server_addr}/${uuid}"
    local health_endpoint="${block_builder_url}/health-check"
    local fee_info_endpoint="${block_builder_url}/fee-info"
    local indexer_registration_endpoint="${INDEXER_API_ENDPOINT}/v1/indexer/builders/registration"

    echo "ğŸ”— Block Builder URL: $block_builder_url"
    echo "ğŸ©º Testing endpoints..."
    echo ""

    local overall_success=true
    local block_builder_address=""

    echo "1ï¸âƒ£ Testing health-check endpoint..."
    echo "   URL: $health_endpoint"

    local http_code
    local response_body
    local curl_start_time=$(date +%s)

    if response_body=$(curl -s --connect-timeout 10 --max-time 30 -w "%{http_code}" "$health_endpoint" 2>/dev/null); then
        http_code="${response_body: -3}"
        response_body="${response_body%???}"

        local curl_end_time=$(date +%s)
        local response_time=$((curl_end_time - curl_start_time))

        if [ "$http_code" -eq 200 ]; then
            echo "   âœ… Health check passed (HTTP $http_code, ${response_time}s)"

            if [ -n "$response_body" ]; then
                echo "   ğŸ“„ Response:"
                if command -v jq >/dev/null 2>&1 && echo "$response_body" | jq empty 2>/dev/null; then
                    echo "$response_body" | jq . | sed 's/^/      /'
                else
                    echo "      $response_body"
                fi
            fi
        else
            echo "   âŒ Health check failed (HTTP $http_code)"
            if [ -n "$response_body" ]; then
                echo "   Response: $response_body"
            fi
            overall_success=false
        fi
    else
        echo "   âŒ Cannot reach health check endpoint"
        overall_success=false
    fi

    echo ""

    echo "2ï¸âƒ£ Testing fee-info endpoint..."
    echo "   URL: $fee_info_endpoint"

    curl_start_time=$(date +%s)

    if response_body=$(curl -s --connect-timeout 10 --max-time 30 -w "%{http_code}" "$fee_info_endpoint" 2>/dev/null); then
        http_code="${response_body: -3}"
        response_body="${response_body%???}"

        curl_end_time=$(date +%s)
        response_time=$((curl_end_time - curl_start_time))

        if [ "$http_code" -eq 200 ]; then
            echo "   âœ… Fee info endpoint passed (HTTP $http_code, ${response_time}s)"

            if [ -n "$response_body" ]; then
                echo "   ğŸ“„ Fee Information:"
                if command -v jq >/dev/null 2>&1 && echo "$response_body" | jq empty 2>/dev/null; then
                    echo "$response_body" | jq . | sed 's/^/      /'

                    block_builder_address=$(echo "$response_body" | jq -r '.blockBuilderAddress // empty')

                    if echo "$response_body" | jq -e '.registration_fee' >/dev/null 2>&1; then
                        local reg_fee=$(echo "$response_body" | jq -r '.registration_fee // "N/A"')
                        echo "   ğŸ’° Registration Fee: $reg_fee"
                    fi

                    if echo "$response_body" | jq -e '.non_registration_fee' >/dev/null 2>&1; then
                        local non_reg_fee=$(echo "$response_body" | jq -r '.non_registration_fee // "N/A"')
                        echo "   ğŸ’° Non-Registration Fee: $non_reg_fee"
                    fi
                else
                    echo "      $response_body"
                fi
            fi
        elif [ "$http_code" -eq 404 ]; then
            echo "   âš ï¸  Fee info endpoint not found (HTTP $http_code)"
            echo "   ğŸ’¡ This endpoint might not be implemented yet"
        elif [ "$http_code" -ge 500 ]; then
            echo "   âŒ Fee info endpoint server error (HTTP $http_code)"
            overall_success=false
        else
            echo "   âš ï¸  Unexpected response from fee info endpoint (HTTP $http_code)"
            if [ -n "$response_body" ]; then
                echo "   Response: $response_body"
            fi
        fi
    else
        echo "   âŒ Cannot reach fee info endpoint"
        overall_success=false
    fi

    echo ""

    if [ -n "$block_builder_address" ]; then
        echo "3ï¸âƒ£ Testing indexer registration endpoint..."
        local indexer_endpoint="${indexer_registration_endpoint}/${block_builder_address}"
        echo "   URL: $indexer_endpoint"
        echo "   ğŸ“ Block Builder Address: $block_builder_address"

        curl_start_time=$(date +%s)

        if response_body=$(curl -s --connect-timeout 10 --max-time 30 -w "%{http_code}" "$indexer_endpoint" 2>/dev/null); then
            http_code="${response_body: -3}"
            response_body="${response_body%???}"

            curl_end_time=$(date +%s)
            response_time=$((curl_end_time - curl_start_time))

            if [ "$http_code" -eq 200 ]; then
                echo "   âœ… Indexer registration endpoint passed (HTTP $http_code, ${response_time}s)"

                if [ -n "$response_body" ]; then
                    echo "   ğŸ“„ Registration Information:"
                    if command -v jq >/dev/null 2>&1 && echo "$response_body" | jq empty 2>/dev/null; then
                        echo "$response_body" | jq . | sed 's/^/      /'

                        if echo "$response_body" | jq -e '.isRegistered' >/dev/null 2>&1; then
                            local is_registered=$(echo "$response_body" | jq -r '.isRegistered // "N/A"')
                            echo "   ğŸ“‹ Registration Status: $is_registered"
                        fi

                        if echo "$response_body" | jq -e '.registrationDate' >/dev/null 2>&1; then
                            local reg_date=$(echo "$response_body" | jq -r '.registrationDate // "N/A"')
                            echo "   ğŸ“… Registration Date: $reg_date"
                        fi

                        if echo "$response_body" | jq -e '.status' >/dev/null 2>&1; then
                            local status=$(echo "$response_body" | jq -r '.status // "N/A"')
                            echo "   ğŸŸ¢ Status: $status"
                        fi
                    else
                        echo "      $response_body"
                    fi
                fi
            elif [ "$http_code" -eq 404 ]; then
                echo "   âš ï¸  Block builder not found in indexer (HTTP $http_code)"
                echo "   ğŸ’¡ This block builder might not be registered yet"
            elif [ "$http_code" -ge 500 ]; then
                echo "   âŒ Indexer registration endpoint server error (HTTP $http_code)"
                overall_success=false
            else
                echo "   âš ï¸  Unexpected response from indexer endpoint (HTTP $http_code)"
                if [ -n "$response_body" ]; then
                    echo "   Response: $response_body"
                fi
            fi
        else
            echo "   âŒ Cannot reach indexer registration endpoint"
            overall_success=false
        fi

        echo ""
    else
        echo "3ï¸âƒ£ Skipping indexer registration check..."
        echo "   âš ï¸  Could not extract blockBuilderAddress from fee-info response"
        echo ""
    fi

    if [ "$overall_success" = true ]; then
        echo "ğŸ‰ Your block builder is healthy and all endpoints are accessible!"
        echo ""
        if [ -n "$block_builder_address" ]; then
            echo "ğŸ—ï¸  Block Builder Address: $block_builder_address"
            echo ""
        fi
        echo "ğŸ“‹ Endpoint Summary:"
        echo "   âœ… Health Check: $health_endpoint"
        echo "   âœ… Fee Info: $fee_info_endpoint"
        if [ -n "$block_builder_address" ]; then
            echo "   âœ… Indexer Registration: ${indexer_registration_endpoint}/${block_builder_address}"
        fi
        return 0
    else
        echo "âš ï¸  Some issues detected with your block builder"
        echo ""
        if [ -n "$block_builder_address" ]; then
            echo "ğŸ—ï¸  Block Builder Address: $block_builder_address"
            echo ""
        fi
        echo "ğŸ“‹ Endpoint Summary:"
        echo "   Health Check: $health_endpoint"
        echo "   Fee Info: $fee_info_endpoint"
        if [ -n "$block_builder_address" ]; then
            echo "   Indexer Registration: ${indexer_registration_endpoint}/${block_builder_address}"
        fi
        echo ""
        echo "ğŸ”§ Debugging steps:"
        echo "   1. Check if services are running: $0 monitor"
        echo "   2. View service logs: docker service logs -f block-builder-stack-${ENVIRONMENT}_block-builder-${ENVIRONMENT}"
        echo "   3. Restart services if needed: $0 run"
        echo ""
        echo "ğŸŒ Manual testing commands:"
        echo "   curl $health_endpoint"
        echo "   curl $fee_info_endpoint"
        if [ -n "$block_builder_address" ]; then
            echo "   curl ${indexer_registration_endpoint}/${block_builder_address}"
        fi

        return 1
    fi
}

# Docker Stackã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ã‚’ç›£è¦–ã™ã‚‹é–¢æ•°
monitor() {
    # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    if [ ! -f "docker-compose.yml" ]; then
        echo "âŒ docker-compose.yml not found"
        echo "Run: $0 setup first"
        return 1
    fi

    # ã‚¹ã‚¿ãƒƒã‚¯åã‚’è¨­å®š
    stack_name="block-builder-stack-${ENVIRONMENT}"

    # Dockerã®çŠ¶æ…‹ç¢ºèª
    echo "ğŸ³ Checking Docker status..."
    if ! docker info >/dev/null 2>&1; then
        echo "âŒ Docker is not running or not accessible"
        echo "ğŸ’¡ Please start Docker and try again"
        return 1
    fi

    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        echo "âŒ Docker Swarm is not active"
        return 1
    fi

    if ! docker stack ls | grep -q "$stack_name"; then
        echo "âŒ Stack '$stack_name' not found"
        echo "ğŸ’¡ Run: $0 run to start the services"
        return 1
    fi

    echo "ğŸ“Š Monitoring Docker Stack '$stack_name'..."
    echo ""

    echo "ğŸ” Stack Services:"
    docker stack services "$stack_name"
    echo ""

    echo "ğŸ’» Container Processes:"
    for service in $(docker service ls --filter "label=com.docker.stack.namespace=$stack_name" --format "{{.Name}}"); do
        echo "--- $service ---"
        docker service ps "$service"
        echo ""
    done

    echo "ğŸ“ Recent Logs (last 5 lines):"
    echo "--- block-builder logs ---"
    docker service logs --tail 5 "${stack_name}_block-builder-${ENVIRONMENT}" 2>/dev/null || echo "No logs available"
    echo ""

    echo "--- nginx-proxy logs ---"
    docker service logs --tail 5 "${stack_name}_nginx-proxy-${ENVIRONMENT}" 2>/dev/null || echo "No logs available"
    echo ""

    echo "--- frp-client logs ---"
    docker service logs --tail 5 "${stack_name}_frp-client-${ENVIRONMENT}" 2>/dev/null || echo "No logs available"
    echo ""

    server_addr=$(grep "serverAddr" frpc.toml 2>/dev/null | sed 's/serverAddr = "\([^"]*\)"/\1/')
    uuid=$(grep "locations" frpc.toml 2>/dev/null | sed 's/.*\/\([^"]*\)".*/\1/')

    if [ -n "$server_addr" ] && [ -n "$uuid" ]; then
        echo "ğŸŒ Health Check:"
        block_builder_url="https://${server_addr}/${uuid}"
        echo "Testing: ${block_builder_url}/health-check"

        if curl -s --max-time 10 "${block_builder_url}/health-check" >/dev/null 2>&1; then
            echo "âœ… Health check passed"
        else
            echo "âŒ Health check failed"
        fi
    fi

    echo ""
    echo "ğŸ’¡ Commands:"
    echo "   View live logs: docker service logs -f builder-stack_block-builder"
    echo "   Restart service: $0 run"
    echo "   Health check: $0 health"
    echo "   Stop all: $0 stop"
}

update() {
    echo "ğŸ”„ Starting update process..."
    echo ""

    echo "âš ï¸  This will:"
    echo "   1. Stop all running services"
    echo "   2. Clean up files"
    echo "   3. Download the latest version of this script"
    echo ""

    echo "â“ Do you want to continue? (y/n)"
    echo -n "> "
    read -r continue_choice

    if [ "$continue_choice" != "y" ] && [ "$continue_choice" != "Y" ]; then
        echo "âŒ Update cancelled"
        return 1
    fi

    clean

    echo ""
    echo "ğŸ“¥ Downloading latest script..."

    if ! command -v curl >/dev/null 2>&1; then
        echo "âŒ curl not found. Please install curl to update."
        return 1
    fi

    if ! validate_api_endpoint "$BUILDER_SCRIPT_URL"; then
        echo "âŒ Builder script URL validation failed"
        return 1
    fi

    local temp_script="builder_new.sh"
    local current_script="$0"

    if curl -o "$temp_script" "$BUILDER_SCRIPT_URL" 2>/dev/null; then
        echo "âœ… Downloaded latest script"
    else
        echo "âŒ Failed to download script"
        echo "   URL: $BUILDER_SCRIPT_URL"
        echo "ğŸ’¡ Please check your internet connection and try again"
        return 1
    fi

    echo ""
    echo "ğŸ” Validating downloaded script..."

    if [ ! -f "$temp_script" ]; then
        echo "âŒ Downloaded file not found"
        return 1
    fi

    if [ ! -s "$temp_script" ]; then
        echo "âŒ Downloaded file is empty"
        rm -f "$temp_script"
        return 1
    fi

    if ! head -1 "$temp_script" | grep -q "#!/bin/bash"; then
        echo "âŒ Downloaded file doesn't appear to be a valid shell script"
        rm -f "$temp_script"
        return 1
    fi

    echo "âœ… Script validation passed"

    echo ""
    echo "ğŸ”„ Replacing current script..."

    chmod +x "$temp_script"

    if mv "$temp_script" "$current_script"; then
        echo "âœ… Script updated successfully"
    else
        echo "âŒ Failed to replace script"
        rm -f "$temp_script"
        return 1
    fi

    echo ""
    echo "ğŸ“‹ Checking preserved configuration..."

    local config_files=("frpc.toml" "nginx.conf" "docker-compose.yml" ".env")
    local found_configs=()

    for file in "${config_files[@]}"; do
        if [ -f "$file" ]; then
            found_configs+=("$file")
        fi
    done

    if [ ${#found_configs[@]} -gt 0 ]; then
        echo "âœ… Configuration files preserved:"
        for file in "${found_configs[@]}"; do
            echo "   - $file"
        done
    else
        echo "â„¹ï¸  No configuration files found"
    fi

    echo ""
    echo "ğŸ‰ Update completed successfully!"
    echo ""
    echo "ğŸ’¡ What's next:"
    if [ ${#found_configs[@]} -gt 0 ]; then
        echo "   1. Check configuration: $current_script check"
        echo "   2. Restart services: $current_script run"
        echo "   3. Monitor status: $current_script monitor"
    else
        echo "   1. Set up configuration: $current_script setup"
        echo "   2. Configure environment: $current_script setup-env"
        echo "   3. Start services: $current_script run"
    fi
    echo ""
    echo "ğŸ“– Check version: $current_script version"
}

docker_clean() {
    echo "ğŸ§¹ Starting Docker cleanup process..."

    stack_name="block-builder-stack-${ENVIRONMENT}"

    if [ -f "docker-compose.yml" ]; then
        echo "ğŸ›‘ Stopping Docker Stack services first..."

    if docker info 2>/dev/null | grep -q "Swarm: active"; then
            if docker stack ls | grep -q "$stack_name"; then
                docker stack rm "$stack_name"
                echo "âœ… Docker Stack '$stack_name' removed"

                echo "â³ Waiting for stack services to be completely removed..."
                sleep 5

                while docker service ls | grep -q "$stack_name"; do
                    echo "   Still removing stack services..."
                    sleep 2
                done
                echo "âœ… All stack services removed"
            else
                echo "â„¹ï¸  Stack '$stack_name' not found"
            fi
        else
            echo "âš ï¸  Docker Swarm not active, skipping stack cleanup"
        fi

        echo "ğŸ—‘ï¸  Removing any remaining related containers..."
        docker rm -f $(docker ps -aq --filter "name=${stack_name}_nginx-proxy-${ENVIRONMENT}" --filter "name=${stack_name}_block-builder-${ENVIRONMENT}" --filter "name=${stack_name}_frp-client-${ENVIRONMENT}") 2>/dev/null || true
        docker rm -f "nginx-proxy-${ENVIRONMENT}" "block-builder-${ENVIRONMENT}" "frp-client-${ENVIRONMENT}" 2>/dev/null || true

        echo "ğŸ—‘ï¸  Removing Docker images from docker-compose.yml..."

        if command -v docker-compose >/dev/null 2>&1; then
            IMAGES=$(docker-compose config --images 2>/dev/null | grep -v "^$" | sort -u)
        else
            IMAGES=$(grep -E "^\s*image:\s*" docker-compose.yml | sed 's/.*image:\s*//' | sed 's/["\x27]//g' | sort -u)
        fi

        if [ -n "$IMAGES" ]; then
            echo "   Found images in docker-compose.yml:"
            echo "$IMAGES" | while read -r image; do
                if [ -n "$image" ]; then
                    echo "   - $image"
                fi
            done

            echo "$IMAGES" | while read -r image; do
                if [ -n "$image" ]; then
                    if docker rmi "$image" 2>/dev/null; then
                        echo "   âœ… Removed: $image"
                    else
                        echo "   â„¹ï¸  Image not found or still in use: $image"
                    fi
                fi
            done
        else
            echo "   âš ï¸  No images found in docker-compose.yml"
        fi

    else
        echo "âš ï¸  docker-compose.yml not found, skipping cleanup"
        return 1
    fi

    echo "ğŸ” Removing Docker secrets..."
    local secret_name="block_builder_private_key_${ENVIRONMENT}"

    if docker info 2>/dev/null | grep -q "Swarm: active"; then
        if docker secret ls 2>/dev/null | grep -q "$secret_name"; then
            docker secret rm "$secret_name" 2>/dev/null && echo "   âœ… Removed: $secret_name" || echo "   âš ï¸  Failed to remove: $secret_name"
        else
            echo "   â„¹ï¸  No $secret_name secret found"
        fi
    else
        echo "   âš ï¸  Docker Swarm not active, skipping secret cleanup"
    fi

    echo "ğŸŒ Removing Docker networks..."
    docker network rm "builder-network-${ENVIRONMENT}" 2>/dev/null && echo "   âœ… Removed: builder-network-${ENVIRONMENT}" || echo "   â„¹ï¸  Network not found or still in use: builder-network-${ENVIRONMENT}"

    echo "âœ… Docker cleanup completed"
}

clean() {
    echo "ğŸ§¹ Starting cleanup process..."

    if ! confirm_action "Are you sure you want to stop Docker Stack services?"; then
        return 0
    fi

    local files_to_remove=("frpc.toml" "nginx.conf" "docker-compose.yml" ".env.${ENVIRONMENT}")
    local files_removed=0

    docker_clean

    echo "ğŸ“ Removing configuration files..."
    for file in "${files_to_remove[@]}"; do
        if [ -f "$file" ]; then
            rm -f "$file"
            echo "   âœ… Removed: $file"
            ((files_removed++))
        else
            echo "   âš ï¸  Not found: $file"
        fi
    done

    if [ $files_removed -eq 0 ]; then
        echo "â„¹ï¸  No configuration files found to remove"
    else
        echo "âœ… Removed $files_removed configuration file(s)"
    fi

    echo ""
    echo "âœ¨ Cleanup process completed!"
    echo "ğŸ’¡ To start fresh, run: $0 setup"
}

version() {
    show_current_environment

    echo "Block Builder Setup Script"

    local version_source=""
    local proxy_domain=""
    local intmax2_version=""

    if [ -f "docker-compose.yml" ]; then
        local docker_image=$(grep -E "^\s*image:\s*" docker-compose.yml | grep "ghcr.io/internetmaximalism/intmax2" | head -1 | sed 's/.*image:\s*//' | sed 's/["\x27]//g' | xargs)

        if [ -n "$docker_image" ]; then
            intmax2_version=$(echo "$docker_image" | sed 's/.*intmax2://' | sed 's/-arm64$//')

            if [ -n "$intmax2_version" ]; then
                version_source="docker-compose.yml"
            else
                echo "âš ï¸  Could not extract version from docker image"
            fi
        else
            echo "âš ï¸  Could not find intmax2 image in docker-compose.yml"
        fi

        if [ -f "frpc.toml" ]; then
            proxy_domain=$(grep "serverAddr" frpc.toml | sed 's/serverAddr = "\([^"]*\)"/\1/')
            if [ -n "$proxy_domain" ]; then
            :
            fi
        fi
    fi

    if [ -z "$intmax2_version" ]; then
        if load_config; then
            intmax2_version="$INTMAX2_VERSION"
            proxy_domain="$PROXY_DOMAIN"
        else
            echo "âŒ Failed to fetch configuration from API"
            echo "ğŸ’¡ Check your internet connection and try again"
            return 1
        fi
    fi

    echo ""
    echo "ğŸ“Š Version Information Summary:"
    echo "   INTMAX2 Version: $intmax2_version"
    echo "   Proxy Domain: ${proxy_domain:-'Not available'}"
    echo "   Architecture: $(uname -m)"
    echo "   Expected Docker Image: $(detect_architecture 2>/dev/null || echo 'ghcr.io/internetmaximalism/intmax2:${intmax2_version}')"
}

# ãƒ¡ã‚¤ãƒ³ã®å‡¦ç†åˆ†å²ï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã«åŸºã¥ã„ã¦é©åˆ‡ãªé–¢æ•°ã‚’å‘¼ã³å‡ºã—ï¼‰
case "${1:-help}" in
    setup)
        # åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆï¼‰
        setup
        ;;
    setup-env)
        # ç’°å¢ƒè¨­å®šï¼ˆRPC URL ã¨ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚­ãƒ¼è¨­å®šï¼‰
        setup_env
        ;;
    verify-env)
        # ç’°å¢ƒè¨­å®šã®æ¤œè¨¼
        verify_env
        ;;
    check)
        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèªã¨å†…å®¹è¡¨ç¤º
        check
        ;;
    run)
        # ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•
        run
        ;;
    stop)
        # ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢
        stop
        ;;
    health)
        # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
        health_check
        ;;
    monitor)
        # ã‚µãƒ¼ãƒ“ã‚¹ç›£è¦–
        monitor
        ;;
    update)
        # ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®æ›´æ–°
        update
        ;;
    docker-clean)
        # Dockerãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        docker_clean
        ;;
    clean)
        # å®Œå…¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        clean
        ;;
    version)
        version
        ;;
    *)
        echo "Usage: $0 {setup|setup-env|verify-env|check|run|stop|monitor|update|clean|docker-clean|version}"
        echo ""
        echo "Commands:"
        echo "  setup        - Create frpc.toml, nginx.conf, docker-compose.yml, and .env with unique UUID"
        echo "  setup-env    - Configure L2_RPC_URL and private key (unified environment setup)"
        echo "  verify-env   - Verify L2_RPC_URL and private key configuration"
        echo "  check        - Check if config files exist and show content"
        echo "  run          - Start Docker Stack with Nginx proxy"
        echo "  stop         - Stop all Docker Stack services"
        echo "  health       - Check health of the Block Builder service"
        echo "  monitor      - Monitor Docker Stack services status and logs"
        echo "  update       - Download and install the latest version of this script"
        echo "  docker-clean - Remove all Docker containers, images, secrets, and networks related to this setup"
        echo "  clean        - Remove all configuration files with Docker cleanup"
        echo "  version      - Show version information"
        echo ""
        echo "Quick start workflow:"
        echo "  1. $0 setup      # Create initial configuration files"
        echo "  2. $0 setup-env  # Configure L2_RPC_URL and private key"
        echo "  3. $0 check      # Verify all configurations"
        echo "  4. $0 run        # Start the services"
        echo "  5. $0 health     # Check the health status of the services"
        echo "  6. $0 monitor    # Monitor running services"
        echo ""
        echo "Maintenance:"
        echo "  $0 stop          # Stop services"
        echo "  $0 update        # Update to latest version"
        echo "  $0 clean         # Complete cleanup"
        echo ""
        ;;
esac
```

::::

ä»¥ä¸‹ã§å‹•ãã“ã¨ã‚’ç¢ºèªï¼

```bash
./builder.sh help
```

ãƒ˜ãƒ«ãƒ—ã‚³ãƒãƒ³ãƒ‰ãŒå®Ÿè¡Œã§ãã‚Œã°OKã§ã™ï¼

```bash
Commands:
  setup        - Create frpc.toml, nginx.conf, docker-compose.yml, and .env with unique UUID
  setup-env    - Configure L2_RPC_URL and private key (unified environment setup)
  verify-env   - Verify L2_RPC_URL and private key configuration
  check        - Check if config files exist and show content
  run          - Start Docker Stack with Nginx proxy
  stop         - Stop all Docker Stack services
  health       - Check health of the Block Builder service
  monitor      - Monitor Docker Stack services status and logs
  update       - Download and install the latest version of this script
  docker-clean - Remove all Docker containers, images, secrets, and networks related to this setup
  clean        - Remove all configuration files with Docker cleanup
  version      - Show version information

Quick start workflow:
  1. ./builder.sh setup      # Create initial configuration files
  2. ./builder.sh setup-env  # Configure L2_RPC_URL and private key
  3. ./builder.sh check      # Verify all configurations
  4. ./builder.sh run        # Start the services
  5. ./builder.sh health     # Check the health status of the services
  6. ./builder.sh monitor    # Monitor running services

Maintenance:
  ./builder.sh stop          # Stop services
  ./builder.sh update        # Update to latest version
  ./builder.sh clean         # Complete cleanup
```

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹

ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ããŸã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ï¼

```bash
./builder.sh setup
```

ã™ã‚‹ã¨ã‚‚ã‚ã‚‚ã‚è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã™ï¼

- **docker-compose.yaml**
  ::::details docker-compose.yamlã®è©³ç´°
  ```yaml
  services:
    nginx-proxy-testnet:
      image: nginx:alpine
      ports:
        - "3000:3000"
      volumes:
        - ./nginx.conf:/etc/nginx/nginx.conf:ro
      networks:
        - builder-network-testnet
      tmpfs:
        - /var/cache/nginx
        - /var/run
        - /tmp
      logging:
        driver: "json-file"
        options:
          max-size: "10m"
          max-file: "3"

    block-builder-testnet:
      image: ghcr.io/internetmaximalism/intmax2:0.1.33-arm64
      command:
        [
          "export BLOCK_BUILDER_PRIVATE_KEY=$$(cat /run/secrets/block_builder_private_key_testnet | tr -d '\n') && exec /app/block-builder",
        ]
      env_file:
        - .env.testnet
      environment:
        - PORT=8080
        - BLOCK_BUILDER_URL=https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33
      secrets:
        - block_builder_private_key_testnet
      networks:
        - builder-network-testnet
      healthcheck:
        disable: true
      logging:
        driver: "json-file"
        options:
          max-size: "10m"
          max-file: "3"

    frp-client-testnet:
      image: snowdreamtech/frpc:latest
      volumes:
        - ./frpc.toml:/etc/frp/frpc.toml:ro
      networks:
        - builder-network-testnet
      logging:
        driver: "json-file"
        options:
          max-size: "10m"
          max-file: "3"

  networks:
    builder-network-testnet:
      driver: overlay
      attachable: true

  secrets:
    block_builder_private_key_testnet:
      external: true
  ```
  ::::

- **frpc.toml**

  ::::details frpc.tomlã®è©³ç´°

  ```toml
  serverAddr = "stage.proxy.builder.intmax.io"
  serverPort = 7000
  auth.token = "<ã“ã“ã¯å›ºæœ‰å€¤>"

  [[proxies]]
  name = "33986a0d-4010-4950-8f7a-558edd632e33-block-builder"
  type = "http"
  localIP = "nginx-proxy-testnet"
  localPort = 3000
  customDomains = ["stage.proxy.builder.intmax.io"]
  locations = ["/33986a0d-4010-4950-8f7a-558edd632e33"]
  ```

  ::::

- **nginx.conf**

  ::::details nginx.confã®è©³ç´°
  ```conf
  events {
      worker_connections 1024;
  }
  http {
      upstream block_builder_testnet {
          server block-builder-testnet:8080;
      }
      server {
          listen 3000;
          location ~ "^/([^/]+)(/.*)$" {
              proxy_pass http://block_builder_testnet$2;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Namespace $1;
          }
          location / {
              return 404;
          }
      }
  }
  ```
  ::::



### swarm init ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ

ç”Ÿæˆã•ã‚ŒãŸDocker Composeãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ã£ã¦ã‚³ãƒ³ãƒ†ãƒŠã‚’èµ·å‹•ã—ã¾ã™ã€‚

```bash
docker swarm init
```

```bash
Swarm initialized: current node (3ryn4c1bx6c6116qr5q0i0ixo) is now a manager.
```

### ç’°å¢ƒå¤‰æ•°ç”¨ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ

```bash
./builder.sh setup-env
```

ã¡ã‚ƒã‚“ã¨ç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚ŒãŸã‹ã¯ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ï¼

```bash
./builder.sh verify-env
```

### æœ€çµ‚ãƒã‚§ãƒƒã‚¯

ç’°å¢ƒå¤‰æ•°ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚‚ã§ããŸã‚‰ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ï¼

```bash
./builder.sh check
```

ä»¥ä¸‹ã®é€šã‚Šè¡¨ç¤ºã•ã‚Œã‚Œã°OKã§ã™!

```bash
ğŸ‰ All checks passed! Your configuration is ready:
   âœ… Configuration files exist
   âœ… L2 RPC URL is configured and accessible
   âœ… Network configuration is correct
   âœ… Private key is configured

ğŸ’¡ Next step: ./builder.sh run
```

### Block Builder èµ·å‹•

ãã‚Œã§ã¯ã„ã‚ˆã„ã‚ˆ**Block Builder**ã‚’èµ·å‹•ã—ã¦ã¿ã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã¿ã¾ã™ã€‚

```bash
./builder.sh run
```

ä»¥ä¸‹ã®é€šã‚Šã«ãªã‚Œã°OKã§ã™!

```bash
Creating network block-builder-stack-testnet_builder-network-testnet
Creating service block-builder-stack-testnet_block-builder-testnet
Creating service block-builder-stack-testnet_frp-client-testnet
Creating service block-builder-stack-testnet_nginx-proxy-testnet
âœ… Started successfully as Docker Stack

ğŸ’¡ To check health, run: ./builder.sh health
ğŸ’¡ To monitor the services, run: ./builder.sh monitor
```

ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ³ãƒ†ãƒŠãŒèµ·å‹•ã—ã¦ã„ã‚‹ã¯ãšã§ã™ï¼ï¼

```bash
CONTAINER ID   IMAGE                                             COMMAND                  CREATED          STATUS          PORTS     NAMES
08102e225a98   nginx:alpine                                      "/docker-entrypoint.â€¦"   21 seconds ago   Up 20 seconds   80/tcp    block-builder-stack-testnet_nginx-proxy-testnet.1.z03bidepf0nwpnun7427xryag
496f2c681f06   snowdreamtech/frpc:latest                         "/usr/bin/frpc -c /eâ€¦"   25 seconds ago   Up 24 seconds             block-builder-stack-testnet_frp-client-testnet.1.35klexbg4sdhld7dfyw5943et
5afd44de4d83   ghcr.io/internetmaximalism/intmax2:0.1.33-arm64   "/bin/sh -c 'export â€¦"   27 seconds ago   Up 26 seconds             block-builder-stack-testnet_block-builder-testnet.1.za5ai2vc44y9hpzfyk341ybg3
```

### ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯

ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚³ãƒãƒ³ãƒ‰ã‚‚å®Ÿè¡Œã—ã¦ã¿ã¾ã™ã€‚

```bash
./builder.sh health
```

ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Œã°OKã§ã™ï¼

```bash
ğŸ©º Testing your block builder health...
ğŸ”— Block Builder URL: https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33
ğŸ©º Testing endpoints...

1ï¸âƒ£ Testing health-check endpoint...
   URL: https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33/health-check
   âœ… Health check passed (HTTP 200, 1s)
   ğŸ“„ Response:
      {
        "name": "block-builder",
        "version": "0.1.33"
      }

2ï¸âƒ£ Testing fee-info endpoint...
   URL: https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33/fee-info
   âœ… Fee info endpoint passed (HTTP 200, 1s)
   ğŸ“„ Fee Information:
      {
        "version": "0.1.33",
        "blockBuilderAddress": "0x51908f598a5e0d8f1a3babfa6df76f9704dad072",
        "beneficiary": "T6foGVBypeTVc1nCM479pb7CeT6Rb2bp1L8EVCeQR8oeLQtYhwcLRSB7ZFpkhMAxu4AqMq8udoTm84Q2qxeihoqGP8imFdm",
        "registrationFee": [
          {
            "token_index": 0,
            "amount": "2500000000000"
          }
        ],
        "nonRegistrationFee": [
          {
            "token_index": 0,
            "amount": "2000000000000"
          }
        ],
        "registrationCollateralFee": null,
        "nonRegistrationCollateralFee": null
      }

3ï¸âƒ£ Testing indexer registration endpoint...
   URL: https://stage.api.indexer.intmax.io/v1/indexer/builders/registration/0x51908f598a5e0d8f1a3babfa6df76f9704dad072
   ğŸ“ Block Builder Address: 0x51908f598a5e0d8f1a3babfa6df76f9704dad072
   âœ… Indexer registration endpoint passed (HTTP 200, 0s)
   ğŸ“„ Registration Information:
      {
        "registered": false,
        "ready": false
      }

ğŸ‰ Your block builder is healthy and all endpoints are accessible!

ğŸ—ï¸  Block Builder Address: 0x51908f598a5e0d8f1a3babfa6df76f9704dad072

ğŸ“‹ Endpoint Summary:
   âœ… Health Check: https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33/health-check
   âœ… Fee Info: https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33/fee-info
   âœ… Indexer Registration: https://stage.api.indexer.intmax.io/v1/indexer/builders/registration/0x51908f598a5e0d8f1a3babfa6df76f9704dad072
```

### ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

```bash
./builder.sh monitor
```

ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã° OK!

```bash
ğŸ³ Checking Docker status...
ğŸ“Š Monitoring Docker Stack 'block-builder-stack-testnet'...

ğŸ” Stack Services:
ID             NAME                                                MODE         REPLICAS   IMAGE                                             PORTS
8np2jy7r7oqj   block-builder-stack-testnet_block-builder-testnet   replicated   1/1        ghcr.io/internetmaximalism/intmax2:0.1.33-arm64
60fqwozp831v   block-builder-stack-testnet_frp-client-testnet      replicated   1/1        snowdreamtech/frpc:latest
n3vwa3hnb9l7   block-builder-stack-testnet_nginx-proxy-testnet     replicated   1/1        nginx:alpine                                      *:3000->3000/tcp

ğŸ’» Container Processes:
--- block-builder-stack-testnet_block-builder-testnet ---
ID             NAME                                                  IMAGE                                             NODE             DESIRED STATE   CURRENT STATE           ERROR     PORTS
za5ai2vc44y9   block-builder-stack-testnet_block-builder-testnet.1   ghcr.io/internetmaximalism/intmax2:0.1.33-arm64   docker-desktop   Running         Running 2 minutes ago

--- block-builder-stack-testnet_frp-client-testnet ---
ID             NAME                                               IMAGE                       NODE             DESIRED STATE   CURRENT STATE           ERROR     PORTS
35klexbg4sdh   block-builder-stack-testnet_frp-client-testnet.1   snowdreamtech/frpc:latest   docker-desktop   Running         Running 2 minutes ago

--- block-builder-stack-testnet_nginx-proxy-testnet ---
ID             NAME                                                IMAGE          NODE             DESIRED STATE   CURRENT STATE           ERROR     PORTS
z03bidepf0nw   block-builder-stack-testnet_nginx-proxy-testnet.1   nginx:alpine   docker-desktop   Running         Running 2 minutes ago

ğŸ“ Recent Logs (last 5 lines):
--- block-builder logs ---
block-builder-stack-testnet_block-builder-testnet.1.za5ai2vc44y9@docker-desktop    | {"timestamp":"2025-09-23T13:29:28.519080Z","level":"INFO","fields":{"message":"new"},"span":{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","name":"http-request"},"spans":[]}
block-builder-stack-testnet_block-builder-testnet.1.za5ai2vc44y9@docker-desktop    | {"timestamp":"2025-09-23T13:29:28.519343Z","level":"INFO","fields":{"message":"check_balance","log.target":"block_builder::app::block_builder","log.module_path":"block_builder::app::block_builder","log.file":"block-builder/src/app/block_builder.rs","log.line":243},"span":{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","name":"http-request"},"spans":[{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","name":"http-request"}]}
block-builder-stack-testnet_block-builder-testnet.1.za5ai2vc44y9@docker-desktop    | {"timestamp":"2025-09-23T13:29:29.183912Z","level":"INFO","fields":{"message":"block builder balance: 106319668723955262421","log.target":"block_builder::app::block_builder","log.module_path":"block_builder::app::block_builder","log.file":"block-builder/src/app/block_builder.rs","log.line":252},"span":{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","name":"http-request"},"spans":[{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","name":"http-request"}]}
block-builder-stack-testnet_block-builder-testnet.1.za5ai2vc44y9@docker-desktop    | {"timestamp":"2025-09-23T13:29:29.184196Z","level":"INFO","fields":{"message":"request-end"},"span":{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","latency":"665.209ms","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","status_code":200,"name":"http-request"},"spans":[{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","latency":"665.209ms","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","status_code":200,"name":"http-request"}]}
block-builder-stack-testnet_block-builder-testnet.1.za5ai2vc44y9@docker-desktop    | {"timestamp":"2025-09-23T13:29:29.184264Z","level":"INFO","fields":{"message":"close","time.busy":"5.38ms","time.idle":"660ms"},"span":{"http.client_ip":"10.0.1.4","http.flavor":"HTTP/1.0","http.host":"stage.proxy.builder.intmax.io","http.method":"GET","http.route":"/fee-info","http.scheme":"http","http.user_agent":"curl/8.6.0","latency":"665.209ms","otel.kind":"server","otel.name":"GET /fee-info","request_id":"bba73aee-f399-429a-b9b3-1bf50682199c","status_code":200,"name":"http-request"},"spans":[]}

--- nginx-proxy logs ---
block-builder-stack-testnet_nginx-proxy-testnet.1.z03bidepf0nw@docker-desktop    | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
block-builder-stack-testnet_nginx-proxy-testnet.1.z03bidepf0nw@docker-desktop    | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
block-builder-stack-testnet_nginx-proxy-testnet.1.z03bidepf0nw@docker-desktop    | /docker-entrypoint.sh: Configuration complete; ready for start up
block-builder-stack-testnet_nginx-proxy-testnet.1.z03bidepf0nw@docker-desktop    | 10.0.1.4 - - [23/Sep/2025:13:29:27 +0000] "GET /33986a0d-4010-4950-8f7a-558edd632e33/health-check HTTP/1.1" 200 43 "-" "curl/8.6.0"
block-builder-stack-testnet_nginx-proxy-testnet.1.z03bidepf0nw@docker-desktop    | 10.0.1.4 - - [23/Sep/2025:13:29:29 +0000] "GET /33986a0d-4010-4950-8f7a-558edd632e33/fee-info HTTP/1.1" 200 397 "-" "curl/8.6.0"

--- frp-client logs ---
block-builder-stack-testnet_frp-client-testnet.1.35klexbg4sdh@docker-desktop    | 2025-09-23 13:28:41.185 [I] [sub/root.go:149] start frpc service for config file [/etc/frp/frpc.toml]
block-builder-stack-testnet_frp-client-testnet.1.35klexbg4sdh@docker-desktop    | 2025-09-23 13:28:41.185 [I] [client/service.go:319] try to connect to server...
block-builder-stack-testnet_frp-client-testnet.1.35klexbg4sdh@docker-desktop    | 2025-09-23 13:28:41.612 [I] [client/service.go:311] [e7410396f5a510c7] login to server success, get run id [e7410396f5a510c7]
block-builder-stack-testnet_frp-client-testnet.1.35klexbg4sdh@docker-desktop    | 2025-09-23 13:28:41.612 [I] [proxy/proxy_manager.go:177] [e7410396f5a510c7] proxy added: [33986a0d-4010-4950-8f7a-558edd632e33-block-builder]
block-builder-stack-testnet_frp-client-testnet.1.35klexbg4sdh@docker-desktop    | 2025-09-23 13:28:41.747 [I] [client/control.go:172] [e7410396f5a510c7] [33986a0d-4010-4950-8f7a-558edd632e33-block-builder] start proxy success

ğŸŒ Health Check:
Testing: https://stage.proxy.builder.intmax.io/33986a0d-4010-4950-8f7a-558edd632e33/health-check
âœ… Health check passed

ğŸ’¡ Commands:
   View live logs: docker service logs -f builder-stack_block-builder
   Restart service: ./builder.sh run
   Health check: ./builder.sh health
   Stop all: ./builder.sh stop
```

ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã‹ãªã‚Šä¸å¯§ã«ä½œã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ã€ã“ã‚“ãªæ„Ÿã˜ã§ç°¡å˜ã«å‹•ã‹ã™ã“ã¨ãŒã§ãã¾ã™ï¼ï¼

## çµè«–ï¼š"å¤±æ•—"ã‹ã‚‰å­¦ã¶ã€æŠ€è¡“é€²åŒ–ã®ç¾ã—ã„ç‰©èª

INTMAXã®ç‰©èªã¯ã€å˜ãªã‚‹æ–°ã—ã„L2ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç´¹ä»‹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã¯ã€ä¸€åº¦ã¯ã€Œå¤±æ•—ã—ãŸã€ã¨è¦‹ãªã•ã‚ŒãŸã‚¢ã‚¤ãƒ‡ã‚¢ãŒã€ç•°ãªã‚‹æŠ€è¡“ï¼ˆzkRollupï¼‰ã¨å‡ºä¼šã„ã€ãã®æ ¸å¿ƒçš„ãªæ€æƒ³ã‚’æ˜‡è¯ã•ã›ã‚‹ã“ã¨ã§ã€æ™‚ä»£ãŒæ±‚ã‚ã‚‹å…¨ãæ–°ã—ã„ä¾¡å€¤ã‚’ç”Ÿã¿å‡ºã™ã¨ã„ã†ã€æŠ€è¡“é€²åŒ–ã®ç¾ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ãã®ã‚‚ã®ã§ã™ã€‚

PlasmaãŒæã„ãŸã€Œç©¶æ¥µã®ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã€ã¨ã„ã†å¤¢ã€‚INTMAXã¯ã€ãã“ã«ã€Œã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ã€ã¨ã€Œãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã€ã¨ã„ã†ç¾ä»£çš„ãªè§£é‡ˆã‚’åŠ ãˆã€è¦‹äº‹ã«å†ç™ºæ˜ã—ã¦ã¿ã›ã¾ã—ãŸã€‚

ç§ãŸã¡ãŒä»Šæ—¥ç›®æ’ƒã—ã¦ã„ã‚‹ã®ã¯ã€ã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ã®æ­´å²ã®æ–°ãŸãªä¸€ãƒšãƒ¼ã‚¸ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã•ã‚ã€é–‹ç™ºè€…ã®çš†ã•ã‚“ã€ã“ã®æ–°ã—ã„ä¸–ç•Œã§ä½•ã‚’ä½œã‚Šã¾ã™ã‹ï¼Ÿ

## å‚è€ƒè³‡æ–™
- [INTMAX å…¬å¼ã‚µã‚¤ãƒˆ](https://intmax.io/)
- [INTMAX Developer Hub](https://docs.network.intmax.io/developers-hub/)
- [INTMAX é–‹ç™ºè€…ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.network.intmax.io/)
- [INTMAX Client SDK](https://github.com/InternetMaximalism/intmax2-client-sdk)
- [INTMAX ãƒ›ãƒ¯ã‚¤ãƒˆãƒšãƒ¼ãƒ‘ãƒ¼](https://eprint.iacr.org/2023/1082.pdf)
- [INTMAX App](https://app.intmax.io/)
- [INTMAX ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ‰](https://docs.network.intmax.io/user-guides)
- [GitHub INTMAX](https://github.com/InternetMaximalism)
- [Block Builder Full Network](https://docs.network.intmax.io/developers-hub/intmax-block-builder/full-netwrok)
