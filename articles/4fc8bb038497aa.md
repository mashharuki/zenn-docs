---
title: "Hats Protocolを理解する！！"
emoji: "🐈"
type: "tech"
topics: ["TypeScript", "Solidity", "Blockchain", "Web3", "HatsProtocol"]
published: true
---

![](/images/4fc8bb038497aa/0.png)

**※随時更新していきます！※**

## はじめに

みなさん、 **Hats Protocol** というプロトコルを聞いたことがありますか？？

https://www.hatsprotocol.xyz/

**Hats Protocol**について調べる機会があったのでその結果をブログ記事にまとめました！！

## Hats Protocolとは何か？

まずは、 **Hats Protocol** がどういうプロトコルなのか解説します！

https://docs.hatsprotocol.xyz/

**Hats Protocol**とは、組織の役割(ロール)や権限をプログラム可能なデジタルグラフに変換し、オンチェーンで管理できるようにするためのプロトコルです！！

特徴は次の点ですね！

:::message
1. **役割の構成**: 
    役割（Hats）はERC-1155標準に準拠したトークンとして表現され、責任、権限、インセンティブを含む「帽子」として組織グラフのノードとなります。

2. **グラフ構造**: 
    役割間の管理や責任関係がグラフの接続として表され、組織の構造を柔軟に構築・可視化できます。

3. **権限の管理**: 
    役割に委譲された権限により、資金管理や意思決定、データアクセスなどの組織運営が効率化されます。

4. **プログラム可能な役割**: 
    Hatsはプログラム可能で、組織の指定する基準やロジックに従って役割や権限の付与・取り消しが自動化可能です。

5. **広範な統合と利用**: 
    Hatsは多様なアドレスやアカウントで使用でき、組織やスマートコントラクトにより柔軟に管理・利用されます。
:::

**AWS**の**IAMロール**の考え方に近いかもしれませんね。

サポートしているチェーン一覧は下記から確認できます。

https://docs.hatsprotocol.xyz/using-hats/hats-protocol-supported-chains

テストネットでは Sepolia と Holeskyが対応してそうです。

- **Sepoliaにデプロイされたコントラクト**

https://sepolia.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137

- **Holeskyにデプロイされたコントラクト**

https://holesky.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137

## クイックスタート

まずは、下記手順に従ってサンプル組織ツリーを作ってみます！！

https://docs.hatsprotocol.xyz/using-hats/creating-my-first-hat

#### 1. 新しいツリーを作成する

まず、以下のページにアクセスします！！

https://app.hatsprotocol.xyz/

![](/images/4fc8bb038497aa/1.png)

ロゴやTop of Hatsの名前を入力する必要があるみたいです！！

諸々必要なデータ入力します！

![](/images/4fc8bb038497aa/2.png)

今回はこんなロゴを用意しました！！

![](/images/4fc8bb038497aa/3.png)

![](/images/4fc8bb038497aa/4.png)

全部入力したら **Create**ボタンを押します！！

これで HatがNFTとしてミントされます！！

実際のトランザクションは以下から確認できます！！

https://sepolia.etherscan.io/tx/0x5917ad6d7719aa3ea87c246cda0277505b366db3b32f9425e88bae5f3d161cf1

しばらく待つと以下のような画面に遷移します！！

![](/images/4fc8bb038497aa/5.png)

これでツリーができました！！

#### 2. 最初の子Hatを作成する

続いて子Hatを作成します！！

先ほどの画面の左上の **Edit Tree** をクリックします！！

子Hatも細かく設定できるみたいですね！！

![](/images/4fc8bb038497aa/6.png)

名前や画像なども決められるみたいです！

![](/images/4fc8bb038497aa/7.png)

その他、帽子を被れるアカウント数の上限値設定、アドレスの一括登録などが可能なんですね。

![](/images/4fc8bb038497aa/8.png)

他にも細かく権限周りを設定することができるみたいです！！

![](/images/4fc8bb038497aa/9.png)

これで子Hatが作成できました！！

クイックスタートはここまでです！！

## Hats Protocolの機能を細かく確認していこう！！

### Adminにできること

**Hats Protocol**では **Admin** は特別な権限を持ちます。

子Hatの詳細や画像、最大供給量、適格アドレス、トグルアドレスを変更できます（ただし、変更可能な状態のHatに限る）。管理者Hatは、新しい着用者に対して、変更可能なHatや変更不可能なHatを発行でき、変更可能なHatを別のアドレスに移転することも可能みたいです。

各Hatは、その下に直接リンクされたすべてのHatの管理者として機能します。

そして Hatは、EOAのみならずマルチシグなどのコントラクトウォレットやスマートアカウントウォレットにも着用が可能とのことです！

これは面白いですね！！！

これなら柔軟に権限の管理ができそうです！！

### 他のプロトコルとの連携

以下のページで紹介されている通り、様々なプロトコル・アプリと連携が可能とのことです！！！

https://docs.hatsprotocol.xyz/using-hats/connecting-hats-w-permissions-and-authorities

SafeやSuperfuildなどのブロックチェーン側のプロトコルだけでなく、テレグラムやDiscord、Google Docsとも連携できるみたいですね。

HatsProtocolの機能を使って以下のようなユースケースをさらに強力にできるみたいですね！

- **アカウントとリソース**: 
  Ethereumアカウントの管理、マルチシグの署名権限、報酬管理
- **コミュニケーションチャンネル**: 
  共有コミュニケーションチャンネルやアカウントへのアクセス権や投稿権限
- **ガバナンスと投票**: 
  スマートコントラクトへのオンチェーン権限、提案作成、投票権
- **ワークスペース**: 
  ワークスペース、ファイル、ドキュメントでの読み取り、レビュー、書き込み権限

### トークンゲート機能との連携

Hatで管理できる権限には2種類の権限があります。

- **ハードパワー**:
  トークンゲートを通じて提供されるオンチェーンやオフチェーンの明確な権限

- **ソフトパワー**:
  会議の進行や特定のドメインでのプロジェクト作業、トークンゲートで管理できないアプリの管理権限

これらの権限をHatとしてブロックチェーン上で作った後にトークンゲートを通じてHatに結びつけることもできるみたいです。

- **トークンゲーティングプラットフォーム**: 
  Guild、Collab.Land、Lit Protocolなどがトークンゲーティングを提供し、以下のアプリで使用できます：

  - Guild: 
    Coordinape、
    Discord、
    Github（プライベートリポジトリのみ）、
    Google Workspace（Docs、Sheets、Slides）、
    Party.Space、
    POAP、
    Rally、
    Telegram、
    Wonderverse
  - Collab.Land: 
    Discord、
    Telegram
  - Lit Protocol: 
    Gather Town、
    Google Drive、
    Headline、
    IPFS、
    Nowhere、
    Orbis 
    Club、
    Shopify、
    WalletChat、
    Wordpress、
    Zoom

- **トークンゲーティングを統合したアプリ**: 
  Charmverse、Wonderverse、Commonwealth（近日対応予定）など、特定のチャンネルへのアクセスや読み書き権限を提供

- **ERC1155を読み込んでパラメータを変更するツール**: 
  Snapshot Strategiesを使用し、特定のHatのみがSnapshot提案で投票できるようにしたり、特定のHatに投票権の重みを与えたりする

- **HatsSignerGate**: 
  Safe multisig署名権限を特定のHatに提供するZodiacモジュール

- **ソーシャルアグリーメントや他のアカウンタビリティメカニズム**: 
  季節ごとの選挙、ステーキング要件、評判システムなど。トークンゲーティングを通じて明確に権限を付与できない場合でも、そのHatがその権限を持つことを示すためにHatを使うことができます。

  以下のサイトからそれぞれのアプリとどのように統合すれば良いのかまとめられています！！

https://docs.hatsprotocol.xyz/hats-integrations/permissions-and-authorities#guides-for-connecting-authorities-to-hats

### 承認と適格性: Hatの保持者に必要な条件について

Hatを通じてアクセスできる権限は、個人またはグループの管理者によって付与および取り消しが可能です。また、Hatsモジュールを使用することで、幅広い自動化された適格性やアカウンタビリティの基準に基づいて管理することもできるみたいです。

- **Hatsモジュール**

  Hatsモジュール は、役割のためのプログラム可能な拡張機能です。
  
  モジュールをHatに接続することで、特定の条件に基づいてHat（および関連する権限）の自動付与および取り消しが可能になります。

- **Hatの適格性モジュール**

  Hatの適格性モジュールは、どのアドレスがそのHatを着用できるかを決定するアドレスです。
  
  また、着用者がもはや適格でない場合には、そのHatを取り消すことができます。
  
  適格性モジュールは、手動で適用することもコントラクトウォレットによる自動トリガーで実行することできるみたいです。

- **適格性の基準について**

  権限の付与の基準については結構いろんなルールを決められるみたいですね。

  - **トークン、NFT、アテステーション**：
    ERC20トークンの残高、ERC721 NFTs、ERC1155 NFTのトークンID、EASアテステーションなど
  - **選挙と許可リスト**：
    JokeRace、Snapshot、Tallyからの選挙結果、自動任期制限、手動で作成された許可リスト
  - **成果と評判**：
    バッジ、オンチェーンポイント、Colinks、Gitcoinパスポートスコアなど
  - **前提条件のアクション**：
    ステーキング、契約の署名、他の役割の保持、サブスクライバーであることなど
  - **その他**：
    複数の基準をAND/ORロジックで組み合わせたり、AIエージェントを導入したり、細かなオンチェーンまたはオフチェーンのトリガーを作成したりすることができます。

  ルールについては開発者が柔軟に決められるみたいですね。
  また、Hatsモジュールを利用することもありみたいですね。

  もちろん、Appからも設定ができます。
  
  **クイックスタート**の部分で子Hatを作った時に **Revocation & Eligibility**というセクションが出てきたと思いますがそこで設定できるみたいです!!

  利用可能な適格性モジュールはいくつか種類があるみたいで以下のページでリスト化されています！！

https://docs.hatsprotocol.xyz/hats-integrations/eligibility-and-accountability-criteria

## 技術的に Hats Protocolを細かく確認していこう！！

冒頭にも説明しましたが、Hatsは **譲渡不可能なERC1155ライクなトークン**として発行されます！！

Hats Protocolの主要なロジックは、**Hatsの作成、発行、取消、管理**となっています。

特定のHatの動作を拡張し、カスタマイズすることも可能みたいです！！

具体的にどんな仕様・機能が提供されているか確認していきます！

### Hat Properties

Hatsが持つプロパティを確認していきます！！

ERC1155がベースになっているのでERC1155のNFTに似てますね。

:::message
- **id**
  Hatの整数識別子であり、ERC1155に似たトークンIDとしても機能します。
- **details**
  Hatに関する任意のメタデータ。
  名前や説明、Hatに関連する役割や責任などが含まれます。
  7,000文字を超えないようにしてください。
- **maxSupply**
  一度にそのHatを身につけることができるアドレスの最大数。
- **admin**
  Hatを発行し、そのほかのプロパティを管理できるHat。
- **eligibility**
  Hatを身につけることができる条件を管理し、その条件を満たしているかどうかを確認するアドレス。
- **toggle**
  Hatが有効かどうかを管理するアドレス。
- **mutable**
  Hatのプロパティがadminによって変更可能かどうか。
- **imageURI**
  HatのERC1155に似たトークンに使用される画像のURI。
  7,000文字を超えないようにしてください。
:::

### Wearing a Hat

Hatを着用できるかの条件は3つ

:::message
1. そのアカウントのアドレスに帽子のトークンの残高があるかどうか

2. 帽子がアクティブであるかどうか

3. そのアカウントが対象となるかどうか
:::

Hats Protocolには、`isWearerOfHat()`という便利な関数があり、これは`balanceOf()`をラップして、残高が1であるかどうかをブール値で返すみたいです。

### Hat Admins & Hatter Contracts

各帽子の管理者は別の帽子です。つまり、特定の帽子の管理機能を実行する権限は、その管理帽子を着用している人に割り当てられます。

管理帽子を着用しているアカウントは誰が帽子を着用できるか決定することが可能です。

そして管理権限は伝播します。ある帽子のすべての祖先（直接の管理者、その管理者の管理者、など）は、その帽子の管理者として機能できます。

- **帽子に対するコントロール**

  |役割|権限|
  |:---|:---|
  |管理者	|新しい帽子を作成する|
  ||着用者に帽子を発行する|
  ||帽子のプロパティを編集する（変更可能な場合）|
  ||帽子を移転する（変更可能な場合）|
  |対象条件モジュール	|対象外のアドレスが帽子を着用するのを防ぐ|
  ||特定の着用者から帽子を剥奪する|
  |トグルモジュール	|帽子をアクティブまたは非アクティブにする ⇒ 全ての着用者がその帽子を失う

- **Hatter Contracts**
  
  管理者として機能するロジックコントラクトは、Hatter Contractsと呼ばれます。これらは、特定のロジックやルールを実装するコントラクトです。Hatter Contractsの管理者は真の管理者ですが、その管理権限をハッターに埋め込まれたロジックに委任しています。

  <br/>

  Hatter Contractsのロジックは、DAOにとって広範なデザイン領域です。  

  <br/>

  以下は、Hatterロジックの例です：

  - **帽子の作成**
    特定のアドレス（DAOのメンバーなど）に、DAOが管理する帽子を作成する権限を付与します。

  - **帽子の発行**
    特定のアドレス（DAOのメンバーなど）に、帽子トークンを発行する権限を付与します。  
    上記と組み合わせることで、DAOはメンバーが特定のタイプの帽子を許可なく作成し、着用できるようにすることができます。これは、役割の明確化と理解を促進するために帽子を使用する場合に特に有効です。

- **着用者の対象条件**
  特定の帽子を着用するために、候補者が満たすべき要件を強制します。
  
  <br/>

  例えば、DAOのメンバーであることや、特定のトークンを保持していることなどです。これは、多くの場合、対象条件モジュールとして実装する方が効果的です。

- **着用者のステーキング**
  特に重要な対象条件の一つに、トークンやDAOシェア、その他の資産を担保としてステーキングすることがあります。

  <br/>
  
  これは、着用者が帽子に関連する責任を果たさなかったり、義務を遂行しなかった場合に、担保が削減されるリスクがあることを意味します。これも、多くの場合、対象条件モジュールとして実装する方が効果的です。

### Hats Trees

すべての帽子が別の帽子を管理者として持つという事実は、すべての帽子が「Hats Trees」の中に存在することを意味します。

このツリー構造が、組織の帽子の基盤を形成します。

特定の帽子ツリーの枝の中では、ツリーの根に近い帽子が、その枝の下位にある帽子に対する管理権限を持っています。

これは、DAO（分散型自律組織）の権限委任の方向性と一致しており、ネットワークの端に権限が委任されるにつれて責任が希薄化する傾向に対抗します。

- **トップハット**
  トップハットは、帽子の管理者が必ず別の帽子でなければならないというルールの唯一の例外です。  
  トップハットは自分自身を管理者とする帽子です。

  帽子ツリーの根は常にトップハットです。
  通常、DAOは、その運営に関連する帽子のツリーを管理するトップハットを着用します。

- **帽子ツリーと帽子ID**
  各帽子ツリーは最大で15の深さを持ち、各帽子は最大で2^16 = 65,536の子供を持つことができ、このパターンが14回繰り返されます。

  各帽子のIDには、そのツリーのIDとツリー内での位置が含まれます。

### Hat IDs

Hat IDは、ツリーの中で帽子がどこに位置しているか、管理者の全枝を含む情報を持つ「アドレス」を作成するためのuint256ビットマップです。
これは、Ethereumのアドレスというよりも、WebやIPアドレスに近いものです。

帽子IDの32バイトは以下のように構成されています：

最初の4バイトはトップハットIDに予約されています。

トップハットIDはHats Protocolの特定のデプロイメント全体で一意であるため、これらを帽子ツリーのトップレベル「ドメイン」と考えることができます。

次の各16ビットのチャンクは、1つの「帽子レベル」を指します。

帽子レベルは合計で15レベルあり、レベル0のトップハットから始まり、レベル14まで続きます。

次のようなHat ID（16進数）を考えてみましょう：

**0x0000000f00020005000a00010000000000000000000000000000000000000000**

便宜上、IPアドレスのように短縮形に再フォーマットできます：**15.2.5.10.1**

このIDだけで、この帽子について多くのことがわかります：

:::message
- この帽子はツリー15に属している
- レベル4の帽子である
- 直近の管理者（親）は15.2.5.10
- その上位の管理者（祖父母）は15.2.5
:::

### Eligibility Modules

Eligibility Modules(適格性モジュール)には、特定の帽子の着用者に関して以下の2つの権限があります。

- a) 適格性
- b) 良好な状態にあるかどうか

- **着用者の適格性**
  着用者の適格性 (A) は、特定のアドレスがその帽子を着用する資格があるかどうかを判断します。   
  <br/> 
  これは、そのアドレスが帽子を着用する前および着用中の両方に適用されます。以下のシナリオを考えてみましょう。
  <br/> 

  |適格	|非適格|
  |:---|:---|
  |帽子を着用していない場合|帽子をアドレスに発行できる|
  |現在帽子を着用している場合|帽子を着用し続ける|

- **着用者の状態**
  着用者の状態 (B) は、特定のアドレスが良好な状態にあるか、悪い状態にあるかを判断します。
  <br/> 
  状態は、**Hats.sol**にオンチェーンで保存され、責任を明確にします。
  <br/> 
  例えば、ステーキングロジックを実装しているHatter Contractでは、適格性モジュールによって悪い状態にされた場合、着用者のステークを削減することができます。
  <br/> 
  特定の帽子の適格性モジュールによって悪い状態にされたアドレスは、自動的にその帽子の適格性を失います。ただし、非適格であることが必ずしも悪い状態を意味するわけではなく、あるアドレスが非適格であっても、良好な状態である可能性があります。
  <br/> 
  任意のアドレスが特定の帽子に対する適格性モジュールとして機能することができます。
  <br/> 
  Hats Protocolは、次の2つの種類の適格性モジュールをサポートしています：

  - **機械的適格性**
    `IHatsEligibility`インターフェースを実装するロジックコントラクトであり、**Hats.sol**コントラクトが`Hats.balanceOf`関数内からcheckWearerStandingを呼び出すことで、着用者の状態を即座に確認できます。事前定義されたトリガーに基づいて即時に帽子を取り消すことが可能です。

  - **人間的適格性**
    EOAやガバナンスコントラクト（DAOなど）です。人間的適格性では、帽子を取り消すために、HatsコントラクトにHats.ruleOHatWearerStandingを呼び出して状態を更新する必要があります。

  管理者とは異なり、適格性モジュールは帽子ではなくアドレスとして明示的に設定されます。これは、着用者に対する罰則（ステークの削減など）に影響を与える長くて読みづらい可能性のある取り消し権限の連鎖を避けるためです。

### Toggle Modules

**Toggle Contract**は、帽子の`hat.active`ステータスをアクティブから非アクティブに切り替える権限を持っています。帽子が非アクティブになると、その帽子の着用者は存在しなくなり（つまり、以前の着用者の残高が0に変更されます）。

任意のアドレスが帽子のトグルとして機能することができます。適格性モジュールと同様に、Hats Protocolは2つのカテゴリのToggle Modulesをサポートしています：

- **機械的トグル**
  IHatsToggleインターフェースを実装するロジックコントラクトであり、Hats.balanceOf関数内からcheckToggleを呼び出すことで、帽子のアクティブステータスを即座に確認し、非アクティブ化（または再アクティブ化）を行います。例えば、「この帽子は年末に期限切れになる」といった事前定義されたロジックに基づいて、即座に非アクティブ化することが可能です。

- **人間的トグル**
  EOAやガバナンスコントラクト（DAOなど）です。帽子を非アクティブ化（または再アクティブ化）するためには、人間的トグルがHatsコントラクトにHats.toggleHatStatusを呼び出して状態を更新する必要があります。

管理者とは異なり、適格性モジュールと同様に、トグルモジュールは帽子ではなく、アドレスとして明示的に設定されます。

### Hat Mutability and Editing

場合によっては、帽子の特性が不変であることが、特に着用者にとって、何に同意しているかについて最大限の信頼を提供するために重要です。しかし、この確実性は柔軟性の欠如を意味し、柔軟性はDAOが進化し、様々な役割について学んでいく中で価値を持つことが多いです。このトレードオフを考慮して、Hatsは不変または可変のいずれかで作成することができます。

**不変な帽子**は、一度作成されると一切変更することができません。
<br/>

**可変な帽子**は、作成後に変更することが可能です。変更はその帽子の管理者のみが行えます。

以下の帽子の特性に対する変更が許可されています：

- 詳細
- 最大供給量（新しい最大供給量が現在の供給量を下回らない限り）
- 適格性
- トグル
- 可変性（これは一方向の変更です）
- 画像URI

さらに、可変な帽子は管理者によって異なる着用者に移行することができます。不変な帽子は移行することができません。

- **トップハットの例外**
  上記の不変性ルールの唯一の例外は、トップハットです。不変でありながら、自身の詳細と画像URIを変更することが許可されています（ただし、他の特性は変更できません）。

### Creating Hats

帽子を作成する者は、その帽子の管理者でなければなりません。言い換えれば、帽子の管理者は`Hats.createHat`関数を呼び出す際の`msg.sender`である必要があります。

ただし、管理者が自らの権限を**Hatter Contract**に委任することで、その管理者は、任意のロジックに基づいて他の適格者に帽子を作成させることができます。

トップハット（自分自身が管理者である帽子）を作成するには、特別な関数`mintTophat`が必要です。

この関数は、新しい帽子を作成し、その帽子を自分自身の管理者として設定し、その後、トークンを`_target`にミントします。管理者帽子をまだ持っていないアドレスが帽子を作成したい場合、まず自分自身を着用者としてトップハットを作成する必要があります。

DAOが一度に多くの帽子を作成したい場合、特に全体の帽子ツリーを一度に作成する場合に、バッチ作成が役立ちます。これは、DAOやワーキンググループの初期構造をセットアップする際（例：帽子のテンプレートから）や、既存の帽子構造をテンプレートからフォークする際に特に有用です。

複数の帽子をバッチ作成するために、DAOは`Hats.batchCreateHats()`関数を呼び出すことができます。この関数は配列を引数として受け取り、そこから複数の帽子を構築します。これらの帽子が同じ帽子ツリーの一部である限り（すなわち、既存の帽子または新たに作成された帽子が管理者である場合）、一度にすべての帽子を作成することが可能です。

### Minting Hats

帽子のトークンをミントできるのは、その帽子の管理者だけです。

帽子をミントするには以下の条件を満たす必要があります：

:::message
- 帽子がアクティブであること
- 最大供給量に達していないこと
- 対象の着用者がすでにその帽子を着用していないこと
- 帽子の適格性モジュールが機械的な場合、対象の着用者がその帽子に対して適格であること
- 帽子の管理者はHats.mintHatを呼び出すことで、個別に帽子のトークンをミントすることができます。
:::

- **バッチミント**
  管理者は**Hats.batchMintHats**を呼び出して、複数の帽子を一度にミントすることも可能です。これにより、同じ帽子を複数の着用者にミントしたり、複数の帽子を一度にミントしたり、さらには新しく作成した帽子ツリー全体をミントすることもできます。

### Transfering Hats

HatはERC1155ライクなトークンとして発行されるみたいですが、別のアカウントに移転できるのはその帽子の管理者だけのようです。

これは、帽子に関連する権限と責任が、着用者に委任されているものであり、所有されているものではないためです。

そのため、安全な転送（受信者がERC1155に対応しているかを確認する転送）や、受信者にデータを渡すための`on1155Received`や`onERC1155BatchReceived`フックは不要です。

このため、Hats Protocolでは、標準のERC1155転送機能である`safeTransferFrom`および`safeBatchTransferFrom`は無効化され、常にエラーが返されます。同様に、トークンの承認は必要なく、`setApprovalForAll`も常にエラーが返されます。

- **ERC1155互換性**
  代替として、帽子は管理者によって`Hats.transferHat`を通じて移転され、ERC1155標準イベント`TransferSingle`が発行されます。移転の受信者は既にその帽子を着用しておらず、帽子を着用する資格がある必要があります。

トップハット（常に自分自身を移転できるもの）を除き、移転可能なのは、変更可能かつアクティブな帽子のみです。

### Renouncing Hats

帽子の着用者は、`Hats.renounceHat`を通じて自分の帽子を「脱ぐ」ことができます。

これにより、その帽子のトークンは焼却され、元の着用者から関連する権限と責任が取り消されますが、その着用者が不良な立場に置かれることはありません。

### Batch Actions

バッチ作成やバッチミントに加えて、**Hats.sol**の関数を一連の処理としてまとめて一つのトランザクションで実行することができます。

これは、**Hats.sol**が継承している`Multicallable`によって可能になっています。

この機能は、支払い不要の`multicall`関数をコントラクトに追加します。これにより、EOAはコントラクトに対して複数の呼び出しを一括で行うことができ、これまでスマートコントラクトでしか利用できなかった便利なバッチ処理が可能になります。

### Hat Image URIs

他のNFTと同様に、ハットには画像があります。
特定のハットの画像は、次のロジックに従って決定されます。

:::message
- そのハットのimageURIプロパティが設定されている場合は、それを使用します。
- ハットのimageURIプロパティが設定されていない場合は、管理者ハットのimageURIを使用します。
- 管理者ハットのimageURIプロパティが設定されていない場合は、その管理者のimageURIを使用します。
- 元のハットのハットツリー内（トップハットを含む）で設定されたimageURIが見つからない場合は、Hats Protocolコントラクトで設定されたglobalImageURIを使用します。
:::

### ERC1155 との互換性

Hats Protocolは、**ERC1155インターフェースに完全に準拠しています**。

ERC1155標準で求められるすべての外部関数がHats Protocolによって公開されており、これによりハットは既存のトークンゲートアプリケーションとすぐに連携できます。

ただし、Hats ProtocolはERC1155標準に完全に準拠しているわけではありません。ハットは所有者（つまり「着用者」）によって移転できないため、安全な移転や`ERC1155TokenReceiver`ロジックの必要性はほとんどありません。

Hats Protocolを利用する開発者は、たとえば、ハットのミントや移転において、`onERC1155Received`への呼び出しが含まれないことに注意する必要があります。

## Coreコントラクトを見ていこう！！

ではここからは Hats Protocolのコア機能が実装されているスマートコントラクトを確認していきたいと思います！！

コア機能を提供しているコントラクトは以下の４つです。

:::message
- **Hats.sol**
- **HatsEvents.sol**
- **HatsErrors.sol**
- **HatsUtillities.sol**
:::

そしてインターフェース用のファイルとして以下の4つが存在します！

:::message
- **IHats.sol**
- **IHatsIdUtilities.sol**
- **IHatsEligibility.sol**
- **IHatsToggle.sol**
:::

ここからはそれぞれ見ていこうと思います！！

### **Hats.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Hats.sol)

Hatsは、DAOに特化した取り消し可能かつプログラム可能な役割を表しており、これらは非譲渡のERC-1155に似たトークンとして実装されています。

このHats.solは、指定されたブロックチェーン上で全てのHatsを管理するマルチテナントコントラクトです。

ERC1155インターフェースを完全に実装しているものの、ERC1155標準には完全には準拠していません。

#### ステート変数

- **name**
  コントラクトの名前（通常はバージョンを含む）

  ```solidity
  string public name;
  ```

- **lastTopHatId**

  最後に作成されたトップハットのIDの最初の4バイト

  ```sol
  uint32 public lastTopHatId;
  ```

- **baseImageURI**
  画像URIが指定されていないハットトークンのためのフォールバック画像URI

  ```sol
  string public baseImageURI;
  ```

- **_hats**
  ハットとハットIDの内部マッピング。
  ハットIDの仕組みについては、**HatsIdUtilities.sol**を参照

  ```solidity 
  mapping(uint256 => Hat) internal _hats;
  ```

- **badStandings**
  特定のハットの着用者が不良状態にあることを示すマッピング。  
  外部のコントラクトで、ペナルティを課すために使用される。

  ```solidity
  mapping(uint256 => mapping(address => bool)) public badStandings;
  ```

#### 関数

- **mintTopHat**
  自身が管理者であるハット、つまり「トップハット」を作成し、ミントする関数。トップハットには適格性やトグルがない。

  ```solidity
  function mintTopHat(
    address _target, 
    string calldata _details, 
    string calldata _imageURI
  ) public returns (uint256 topHatId);
  ```

- **createHat**
  新しいハットを作成する関数。
  `msg.sender`は`_admin`ハットを着用している必要がある。新しいHat構造体を初期化するが、トークンはミントされない。

  ```solidity
  function createHat(
      uint256 _admin,
      string calldata _details,
      uint32 _maxSupply,
      address _eligibility,
      address _toggle,
      bool _mutable,
      string calldata _imageURI
  ) public returns (uint256 newHatId);
  ```

- **batchCreateHats**
  複数のハットを一括で作成する関数。
  `msg.sender`はそれぞれのハットの管理者である必要がある。

  ```solidity
  function batchCreateHats(
      uint256[] calldata _admins,
      string[] calldata _details,
      uint32[] calldata _maxSupplies,
      address[] memory _eligibilityModules,
      address[] memory _toggleModules,
      bool[] calldata _mutables,
      string[] calldata _imageURIs
  ) public returns (bool success);
  ```

- **getNextId**
  次の子ハットのIDを取得する関数。lastHatIdはインクリメントされない。

  ```solidity
  function getNextId(uint256 _admin) public view returns (uint256 nextId);
  ```

- **mintHat**
  適格な受領者にハットのERC1155に似たトークンをミントし、受領者がそのハットを「着用」する関数。

  ```solidity
  function mintHat(
    uint256 _hatId, 
    address _wearer
  ) public returns (bool success);
  ```

- **batchMintHats**
  複数のハットを一括でミントする関数。msg.senderはそれぞれのハットの管理者である必要がある。

  ```solidity
  function batchMintHats(
    uint256[] calldata _hatIds, 
    address[] calldata _wearers
  ) public returns (bool success);
  ```

- **setHatStatus**
  ハットの状態をアクティブから非アクティブ、またはその逆に切り替える関数。
  
  `msg.sender`はそのハットのトグルとして設定されている必要がある。

  ```solidity
  function setHatStatus(
    uint256 _hatId, 
    bool _newStatus
  ) external returns (bool toggled);
  ```

- **checkHatStatus**
  ハットのトグルモジュールをチェックし、返された状態を処理する関数。ストレージ内のハットの状態を変更する可能性がある。

  ```solidity
  function checkHatStatus(uint256 _hatId) public returns (bool toggled);
  ```

- **setHatWearerStatus**
  ハットの適格性モジュールが報告する着用者の状態を報告し、falseであればそのハットを取り消す関数。
  取り消された場合、着用者のハットはバーンされる。

  ```solidity
  function setHatWearerStatus(
    uint256 _hatId, 
    address _wearer, 
    bool _eligible, 
    bool _standing
  ) external returns (bool updated);
  ```

- **checkHatWearerStatus**
  ハットの適格性モジュールに着用者の状態を報告するように要求し、falseであればそのハットを取り消す関数。
  
  取り消された場合、着用者のハットはバーンされる。

  ```solidity
  function checkHatWearerStatus(
    uint256 _hatId, 
    address _wearer
  ) public returns (bool updated);
  ```

- **renounceHat**
  ハットを「放棄」する関数。`msg.sender`のハットをバーンする。

  ```solidity
  function renounceHat(uint256 _hatId) external;
  ```

- **transferHat**
  ハットを一つの着用者から他の適格な着用者へ移す関数。
  ハットは可変である必要があり、管理者によって転送が開始される必要がある。

  ```solidity
  function transferHat(
    uint256 _hatId, 
    address _from, 
    address _to
  ) public;
  ```

- **makeHatImmutable**
  可変ハットを不変に設定する関数。hat.configの2番目のビットを0に設定する。

  ```solidity
  function makeHatImmutable(uint256 _hatId) external;
  ```

- **changeHatDetails**
  ハットの詳細を変更する関数。ハットは可変である必要があるが、トップハットは例外。

  ```solidity
  function changeHatDetails(
    uint256 _hatId, 
    string calldata _newDetails
  ) external;
  ```

- **changeHatEligibility**
  ハットの適格性モジュールを変更する関数。ハットは可変である必要がある。

  ```solidity
  function changeHatEligibility(
    uint256 _hatId, 
    address _newEligibility
  ) external;
  ```
- **changeHatToggle**
  ハットのトグルモジュールを変更する関数。ハットは可変である必要がある。

  ```solidity
  function changeHatToggle(
    uint256 _hatId, 
    address _newToggle
  ) external;
  ```

- **changeHatImageURI**
  ハットの画像URIを変更する関数。ハットは可変である必要があり、トップハットは例外。

  ```solidity
  function changeHatImageURI(uint256 _hatId, string calldata _newImageURI) external;
  ```

- **changeHatMaxSupply**
  ハットの最大供給量を変更する関数。ハットは可変である必要があり、新しい最大供給量は現在の供給量より少なくできない。

  ```solidity
  function changeHatMaxSupply(
    uint256 _hatId, 
    uint32 _newMaxSupply
  ) external;
  ```

- **requestLinkTopHatToTree**
  ハットツリーを親ツリーにリンクするためのリクエストを送信する関数。

  ```solidity
  function requestLinkTopHatToTree(
    uint32 _topHatDomain, 
    uint256 _requestedAdminHat
  ) external;
  ```

- **approveLinkTopHatToTree**
  ハットツリーを親ツリーにリンクするリクエストを承認する関数。
  リンク先の適格性やトグルモジュールを追加し、メタデータを変更するオプションがある。

  ```solidity
  function approveLinkTopHatToTree(
    uint32 _topHatDomain,
    uint256 _newAdminHat,
    address _eligibility,
    address _toggle,
    string calldata _details,
    string calldata _imageURI
  ) external;
  ```

- **unlinkTopHatFromTree**
  親ツリーとのリンクを解除し、トグルと適格性を削除する関数。画像URIはbaseImageURIにリセットされる。

  ```solidity
  function unlinkTopHatFromTree(uint32 _topHatDomain) external;
  ```

- **viewHat**
  指定されたハットIDに対応するハットのメタデータを返す関数。
  
  ハットIDの仕組みについては`HatsIdUtilities.sol`を参照。

  ```solidity
  function viewHat(uint256 _hatId) public view returns (
      uint256 id,
      uint256 admin,
      string memory details,
      uint32 maxSupply,
      address eligibility,
      address toggle,
      bool mutable,
      string memory imageURI,
      uint32 supply,
      bool active
  );
  ```

- **balanceOf**
  特定のアドレスが所有する特定のハットの数を返す関数。

  ```solidity
  function balanceOf(
    address _wearer, 
    uint256 _hatId
  ) public view override returns (uint256 balance);
  ```

- **ownerOf**
  現在の所有者のリストを返す関数。着用者のみを対象とし、最大20の結果を返す。ページネーションのサポートを計画。

  ```solidity
  function ownerOf(uint256 _hatId) public view returns (address[] memory owners);
  ```

- **isWearerOfHat**
  指定されたアドレスが指定されたハットを着用しているかどうかを返す関数。

  ```solidity
  function isWearerOfHat(
    address _wearer, 
    uint256 _hatId
  ) public view returns (bool isWearer);
  ```

- **isActive**
  ハットがアクティブかどうかを確認する関数。

  ```solidity
  function isActive(uint256 _hatId) public view returns (bool active);
  ```

- **isInGoodStanding**
  ハットの着用者が不良状態でないかを確認する関数。

  ```solidity
  function isInGoodStanding(
    uint256 _hatId, 
    address _wearer
  ) public view returns (bool good);
  ```

- **isAdminOfHat**
  指定されたアドレスが特定のハットの管理者であるかどうかを確認する関数。
  
  `_hatId`の管理者が`_wearer`の所有する他のハットである場合、真を返す。

  ```solidity
  function isAdminOfHat(
    address _wearer, 
    uint256 _hatId
  ) public view returns (bool isAdmin);
  ```

- **getImageURIForHat**
  ハットの画像URIを取得する関数。
  画像URIが設定されていない場合はbaseImageURIを返す。

  ```solidity
  function getImageURIForHat(uint256 _hatId) public view returns (string memory uri);
  ```

- **uri**
  ハットトークンのERC-1155標準準拠のURIメソッド。

  ```solidity
  function uri(uint256 _hatId) public view override returns (string memory);
  ```

- **supportsInterface**
  特定のインターフェースをサポートしているかどうかを確認する関数。

  ```solidity
  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155) returns (bool);
  ```

- **_beforeTokenTransfer**
  トークンの転送前に実行される内部関数。

  ```solidity
  function _beforeTokenTransfer(
    address operator, 
    address from, 
    address to, 
    uint256[] memory ids, 
    uint256[] memory amounts, 
    bytes memory data
  ) internal virtual override;
  ```

#### 構造体

**Hat**という構造体が定義されています。

```sol
struct Hat {
  address eligibility; // 適格性モジュールのアドレス
  uint32 maxSupply; // 最大供給量
  uint32 supply; // 現在の供給量
  uint16 lastHatId; // 最後のハットID
  address toggle; // トグルモジュールのアドレス
  uint96 config; // 構成データ
  string details; // ハットの詳細
  string imageURI; // ハットの画像URI
}
```

### **HatsEvents.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/HatsEvents.sol)

このコントラクトでは各種イベントが定義されています。

- **HatCreated**  
  新しいハットが作成された時に発行されるイベント

  ```sol
  event HatCreated(
    uint256 id, 
    string details, 
    uint32 maxSupply, 
    address eligibility, 
    address toggle, 
    bool mutable_, 
    string imageURI
  );
  ```

- **WearerStandingChanged**
  ハットを着用している人のステータスが更新された時に発行されるイベント

  適格性（Eligibility）は含まれていません。適格性の真偽は適格性モジュールによって管理され、トランザクションなしで変更されることがあるためです。

  ```sol
  event WearerStandingChanged(
    uint256 hatId, 
    address wearer, 
    bool wearerStanding
  );
  ```

- **HatStatusChanged**
  ハットのステータスが更新された時に発行されるイベント

  ```sol
  event HatStatusChanged(uint256 hatId, bool newStatus);
  ```

- **HatDetailsChanged**
  ハットの詳細が更新された時に発行されるイベント

  ```sol
  event HatDetailsChanged(uint256 hatId, string newDetails);
  ```

- **HatEligibilityChanged**
  ハットの適格性モジュールが更新された時に発行されるイベント

  ```sol
  event HatEligibilityChanged(uint256 hatId, address newEligibility);
  ```

- **HatToggleChanged**
  ハットのトグルモジュールが更新された時に発行されるイベント

  ```sol
  event HatToggleChanged(uint256 hatId, address newToggle);
  ```

- **HatMutabilityChanged**
  ハットの可変性が更新された時に発行されるイベント

  ```sol
  event HatMutabilityChanged(uint256 hatId);
  ```

- **HatMaxSupplyChanged**
  ハットの最大供給量が更新された時に発行されるイベント

  ```sol
  event HatMaxSupplyChanged(uint256 hatId, uint32 newMaxSupply);
  ```

- **HatImageURIChanged**
  ハットの画像URIが更新された時に発行されるイベント

  ```sol
  event HatImageURIChanged(uint256 hatId, string newImageURI);
  ```
- **TopHatLinkRequested**
  トッパーハットのリンクがその管理者によってリクエストされた時に発行されるイベント

  ```sol
  event TopHatLinkRequested(uint32 domain, uint256 newAdmin);
  ```

- **TopHatLinked**
  トッパーハットが別のツリーにリンクされた時に発行されるイベント

  ```sol
  event TopHatLinked(uint32 domain, uint256 newAdmin);
  ```

### **HatsErrors.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/HatsErrors.sol)

このファイルではHatsProtocolで利用するカスタムエラーが定義されています。

- **NotAdmin**
  ユーザーが `hatId` に対してアクションを試みたが、その `hatId` の管理者ハットのいずれも着用していない場合に発生するエラーです。

  `approveLinkTopHatToTree` や `relinkTopHatToTree` などの操作で発生する可能性があります。

  ```sol
  error NotAdmin(address user, uint256 hatId);
  ```

- **NotHatWearer**
  指定されたハットの着用者でないアカウントとして、またはそのアカウントのためにアクションを実行しようとした場合に発生するエラーです。

  ```sol
  error NotHatWearer();
  ```

- **NotAdminOrWearer**
  指定されたハットの管理者または着用者である必要があるアクションを試みた場合に発生するエラーです。

  ```sol
  error NotAdminOrWearer();
  ```

- **AllHatsWorn**
  `hatId` をミントしようとしたが、その `hatId` の最大供給量が達成されている場合に発生するエラーです。

  ```sol
  error AllHatsWorn(uint256 hatId);
  ```

- **MaxLevelsReached**
  レベル14のハットを管理者として持つハットを作成しようとした場合に発生するエラーです。

  ```sol
  error MaxLevelsReached();
  ```

- **InvalidHatId**
  試みたハットIDに中間レベルが空である場合に発生するエラーです。

  ```sol
  error InvalidHatId();
  ```

- **AlreadyWearingHat**
  既にそのハットを着用している着用者に対して hatId をミントしようとした場合に発生するエラーです。

  ```sol
  error AlreadyWearingHat(address wearer, uint256 hatId);
  ```

- **HatDoesNotExist**
  存在しないハットをミントしようとした場合に発生するエラーです。

  ```sol
  error HatDoesNotExist(uint256 hatId);
  ```

- **HatNotActive**
  アクティブでないハットをミントまたは転送しようとした場合に発生するエラーです。

  ```sol
  error HatNotActive();
  ```

- **NotEligible**
  適格でない着用者に対してハットをミントまたは転送しようとした場合に発生するエラーです。

  ```sol
  error NotEligible();
  ```

- **NotHatsToggle**
  ハットのステータスを確認または設定しようとしたが、そのアカウントがそのハットのトグルモジュールでない場合に発生するエラーです。

  ```sol
  error NotHatsToggle();
  ```

- **NotHatsEligibility**
  ハットの着用者のステータスを確認または設定しようとしたが、そのアカウントがそのハットの適格性モジュールでない場合に発生するエラーです。

  ```sol
  error NotHatsEligibility();
  ```

- **BatchArrayLengthMismatch**
  バッチ関数に渡す配列の引数の長さが一致しない場合に発生するエラーです。

  ```sol
  error BatchArrayLengthMismatch();
  ```

- **Immutable**
  変更または転送が不可能なハットを試みた場合に発生するエラーです。

  ```sol
  error Immutable();
  ```

- **NewMaxSupplyTooLow**
  ハットの maxSupply を現在の供給量よりも低い値に変更しようとした場合に発生するエラーです。

  ```sol
  error NewMaxSupplyTooLow();
  ```

- **CircularLinkage**
  トッパーハットを新しい管理者にリンクしようとしたが、そのトッパーハットが新しい管理者の管理下にある場合に発生するエラーです。

  ```sol
  error CircularLinkage();
  ```

- **CrossTreeLinkage**
  トッパーハットを別のツリーにリンクまたは再リンクしようとした場合に発生するエラーです。

  ```sol
  error CrossTreeLinkage();
  ```

- **LinkageNotRequested**
  トッパーハットのリンクがリクエストなしで試みられた場合に発生するエラーです。

  ```sol
  error LinkageNotRequested();
  ```

- **InvalidUnlink**
  着用者が存在しないトッパーハットのリンク解除を試みた場合に発生するエラーです。これにより、リンク解除がトッパーハットを壊すことはありません。

  ```sol
  error InvalidUnlink();
  ```

- **ZeroAddress**
  ハットの適格性またはトグルモジュールをゼロアドレスに変更しようとした場合に発生するエラーです。

  ```sol
  error ZeroAddress();
  ```

- **StringTooLong**
  ハットの詳細や画像URIを7000バイト（約7000文字）を超える文字列に変更しようとした場合に発生するエラーです。これにより、管理者がハットの詳細や画像URIを長くしすぎて読み込みがブロックのガス制限を超えることを防ぎます。

  ```sol
  error StringTooLong();
  ```

### **HatsUtillities.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/HatsIdUtilities.sol)

このコントラクトではHatsProtocolで使える便利な共通メソッドや変数が実装されています。

#### ステート変数

- **linkedTreeRequests**
  他のツリーの管理者ハットにリンクを要求するトッパーハットのマッピング

  リクエストが新しい管理者によって承認されるとリンクが行われます。

  ```sol
  mapping(uint32 => uint256) public linkedTreeRequests;
  ```

- **linkedTreeAdmins**
  他のツリーの管理者ハットに承認されてリンクされたトッパーハットのマッピング。ハットツリーを別のツリーに接ぎ木するために使用します。

  ツリーはトッパーハットを介してのみ別のツリーにリンクできます。

  ```sol
  mapping(uint32 => uint256) public linkedTreeAdmins;
  ```

- **TOPHAT_ADDRESS_SPACE**
  ハットIDはアドレスとして機能します。指定されたハットのIDは、そのハットツリー内での位置を表します：レベル、管理者、管理者の管理者（など、トッパーハットまで上昇）。最上位レベルは4バイトで構成され、すべてのトッパーハットを参照します。下の各レベルは16ビットで構成され、最大65,536個の子ハットを含むことができます。uint256 は4バイトのトッパーハットアドレスのスペースを持ち、((256 - 32) / 16) = 14レベルの委任をサポートし、各レベルの管理者は65,536個の異なる子ハットのスペースを持ちます。ハットツリーは単一のトッパーハットで構成され、最大14レベルの深さがあります。

  ```sol
  uint256 internal constant TOPHAT_ADDRESS_SPACE = 32;
  ```

- **LOWER_LEVEL_ADDRESS_SPACE**
  トッパーハットの下にある各レベルのアドレススペースのビット数です。

  ```sol
  uint256 internal constant LOWER_LEVEL_ADDRESS_SPACE = 16;
  ```

- **MAX_LEVELS**
  トッパーハットの下の最大レベル数、つまりツリーの最大深さです。
  
  計算式は (256 - TOPHAT_ADDRESS_SPACE) / LOWER_LEVEL_ADDRESS_SPACE です。

  ```sol
  uint256 internal constant MAX_LEVELS = 14;
  ```

#### 関数

- **buildHatId**
  指定された管理者の下に新しいハットの有効なIDを構築します。

  管理者がすでに MAX_LEVELS に達している場合は、リバートします。

  ```sol
  /**
    * @param _admin 新しい帽子の管理者のID
    * @param _newHat 新しい帽子のID
    * @return id 構築された帽子のID
    */
  function buildHatId(
    uint256 _admin, 
    uint16 _newHat
  ) public pure returns (uint256 id);
  ```

- **getHatLevel**
  指定されたハットがそのハットツリー内でのレベルを識別します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return level 帽子のツリー内でのレベル
   */
  function getHatLevel(uint256 _hatId) public view returns (uint32 level);
  ```

- **getLocalHatLevel**
  指定されたハットがそのローカルハットツリー内でのレベルを識別します。

  getHatLevel と似ていますが、リンクされたツリーは考慮しません。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return level ローカルツリー内での帽子のレベル
   */
  function getLocalHatLevel(uint256 _hatId) public pure returns (uint32 level);
  ```

- **isTopHat**
  ハットがトッパーハットであるかどうかを確認します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return _isTopHat 帽子がトップハットであるかどうか
   */
  function isTopHat(uint256 _hatId) public view returns (bool _isTopHat);
  ```

- **isLocalTopHat**
  ハットがそのローカルハットツリー内でトッパーハットであるかどうかを確認します。

  isTopHat と似ていますが、リンクされたツリーは考慮しません。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return _isLocalTopHat 帽子がローカルツリーのトップハットであるかどうか
   */
  function isLocalTopHat(uint256 _hatId) public pure returns (bool _isLocalTopHat);
  ```

- **isValidHatId**
  ハットIDが有効かどうかを確認します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return validHatId 帽子のIDが有効であるかどうか
   */
  function isValidHatId(uint256 _hatId) public pure returns (bool validHatId);
  ```

- **getAdminAtLevel**
  指定されたハットの指定レベルの管理者ハットのIDを取得します。

  この関数は、linkedTreeAdmin ポインタをたどって、別のツリーにあるハットを探します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @param _level 調べるレベル
   * @return admin 指定レベルの管理者の帽子ID
   */
  function getAdminAtLevel(
    uint256 _hatId, 
    uint32 _level
  ) public view returns (uint256 admin);
  ```

- **getAdminAtLocalLevel**
  指定されたハットがそのツリー内での指定レベルの管理者ハットのIDを取得します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @param _level 調べるレベル
   * @return admin ローカルツリー内で指定レベルの管理者の帽子ID
   */
  function getAdminAtLocalLevel(
    uint256 _hatId, 
    uint32 _level
  ) public pure returns (uint256 admin);
  ```

- **getTopHatDomain**
  指定されたハットのトッパーハットドメインを取得します。

  ドメインはハットIDの最初の4バイトに格納されている、ハットツリーの識別子です。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return domain 帽子のトップハットドメイン
   */
  function getTopHatDomain(uint256 _hatId) public pure returns (uint32 domain);
  ```

- **getTippyTopHatDomain**
  最も高い親トッパーハット、いわゆる「ティッピートッパーハット」のドメインを取得します。

  ```sol
  /**
   * @param _topHatDomain 調べるトップハットドメイン
   * @return domain 最高の親トップハットのドメイン
   */
  function getTippyTopHatDomain(uint32 _topHatDomain) public view returns (uint32 domain);
  ```

- **noCircularLinkage**
  ツリーの循環リンクがないかをチェックします。

  ```sol
  /**
   * @param _topHatDomain リンクするツリーのドメイン
   * @param _linkedAdmin リンク先の管理者の帽子ID
   * @return notCircular 円環状リンクが見つからなかった場合にtrue
   */
  function noCircularLinkage(
    uint32 _topHatDomain, 
    uint256 _linkedAdmin
  ) public view returns (bool notCircular);
  ```

- **sameTippyTopHatDomain**
  トッパーハットドメインとそのポテンシャルリンク管理者が同じツリーから来ていること、つまり同じティッピートッパーハットドメインを持っていることを確認します。

  ```sol
  /**
   * @param _topHatDomain リンクするトップハットのドメイン
   * @param _newAdminHat 新しいリンク先の管理者の帽子ID
   * @return sameDomain トップハットドメインと新しい管理者のドメインが同じかどうか
   */
  function sameTippyTopHatDomain(
    uint32 _topHatDomain, 
    uint256 _newAdminHat
  ) public view returns (bool sameDomain);
  ```

## SDKを見ていこう！！

Coreコントラクトを細かく確認したので次は **SDK** についての細かく確認していきましょう！！

公式ドキュメントでは以下のページで確認できます！！

https://docs.hatsprotocol.xyz/for-developers/v1-sdk

### 読み取り系のメソッド

- **viewHat**
  帽子のプロパティを取得します。

  ```js
  const hat = await hatsClient.viewHat(hatId);
  ```

  取得できるプロパティは以下の通り

  ```js
  {
    details: string;
    maxSupply: number;
    supply: number;
    eligibility: Address;
    toggle: Address;
    imageUri: string;
    numChildren: number;
    mutable: boolean;
    active: boolean;
  }
  ```

- **isWearerOfHat**
  特定の帽子を着用しているかどうかをチェックします。

  ```js
  const isWearer = await hatsClient.isWearerOfHat({
    wearer,
    hatId,
  })
  ```

- **isAdminOfHat**
  特定の帽子の管理者であるかどうかをチェックします。

  ```js
  const isAdmin = await hatsClient.isAdminOfHat({
    user,
    hatId,
  });
  ```

- **isActive**
  帽子がアクティブかどうかをチェックします。

  ```js
  const isActive = await hatsClient.isActive(hatId);
  ```

- **isInGoodStanding**
  特定の帽子の着用者が「良好な状態」にあるかどうかをチェックします。

  ```js
  const isGoodStanding = await hatsClient.isInGoodStanding({
    wearer,
    hatId,
  });
  ```

- **isEligible**
  特定の帽子に対してアドレスが適格であるかどうかをチェックします。

  ```js
  const isEligible = await hatsClient.isEligible({
    wearer,
    hatId,
  });
  ```

- **predictHatId**
  まだ作成されていない帽子のIDを予測します。

  ```js
  const hatId = await hatsClient.predictHatId(admin);
  ```

- **getTreesCount**
  存在するツリーの数を取得します。

  ```js
  const numTrees = await hatsClient.getTreesCount();
  ```

- **getLinkageRequest**

  ツリーのリンクリクエストを取得します。

  ```js
  const requestedAdminHat = await hatsClient.getLinkageRequest(topHatDomain);
  ```

- **getLinkedTreeAdmin**
  リンクされたツリーの管理者を取得します（TopperHatがリンクされている帽子）。

  ```js
  const adminHat = await hatsClient.getLinkedTreeAdmin(topHatDomain);
  ```

- **getHatLevel**
  帽子のレベルを取得します。ツリーがリンクされている場合、レベルはグローバルツリー（すべてのリンクツリーを含む）で計算されます。

  ```js
  const level = await hatsClient.getHatLevel(hatId);
  ```

- **getLocalHatLevel**
  ローカルツリー内での帽子のレベルを取得します（リンクされたツリーを考慮しません）。

  ```js
  const level = await hatsClient.getLocalHatLevel(hatId);
  ```

- **getTopHatDomain**
  帽子のツリードメインを取得します。

  ```js
  const domain = await hatsClient.getTopHatDomain(hatId);
  ```

- **getTippyTopHatDomain**
  指定されたツリーが含まれるグローバルツリーのトッパーハット（「ティッピートッパーハット」）のツリードメインを取得します。

  ```js
  const domain = await hatsClient.getTippyTopHatDomain(topHatDomain);
  ```

- **getAdmin**
  帽子の直接の管理者を取得します。

  ```js
  const admin = await hatsClient.getAdmin(hatId);
  ``` 

- **getChildrenHats**
  帽子の子供の帽子を取得します。

  ```js
  const children = await hatsClient.getChildrenHats(hatId);
  ```

### 書き込み系のメソッド

続いてSDKに用意されている書き込み系の処理を見ていきましょう！！

- **mintTopHat**
  新しいトップハットを作成する（新しいツリーを作成する）。

  ```js
  const mintTopHatResult = await hatsClient.mintTopHat({
    account,
    target,
    details,
    imageURI,
  });
  ```

- **createHat**
  ハットを作成する。

  ```js
  const createHatResult = await hatsClient.createHat({
    account,
    admin,
    details,
    maxSupply,    //ハットの最大着用者数。
    eligibility,  // ハットの適格性アドレス（ゼロアドレスは無効）。
    toggle,       // ハットのトグルアドレス（ゼロアドレスは無効）。
    mutable,      // ハットを変更可能にする場合はtrue、そうでない場合はfalse。
    imageURI,     // 任意のハットの画像URI。
  });
  ```

- **batchCreateHats**
  複数のハットを作成する。

  ```js
  const batchCreateHatsResult = await hatsClient.batchCreateHats({
    account,
    admins,
    details,
    maxSupplies,
    eligibilityModules,
    toggleModules,
    mutables,
    imageURIs,
  });
  ```

- ハットをミントする

  ```js
  const mintHatResult = await hatsClient.mintHat({
    account,
    hatId,
    wearer,
  });
  ```

- **batchMintHats**
  複数のハットをミント（発行）する。

  ```js 
  const batchMintHatsResult = await hatsClient.batchMintHats({
    account,
    hatIds,
    wearers,
  });
  ```

- **setHatStatus**
  ハットのステータスをアクティブ/非アクティブに設定する。

  ```js
  const setHatStatusResult = await hatsClient.setHatStatus({
    account,
    hatId,
    newStatus,
  });
  ```

- **checkHatStatus**
  トグルモジュールを呼び出してハットのステータスを確認し、必要に応じてステータスを更新する。

  ```js
  const checkHatStatusResult = await hatsClient.checkHatStatus({
    account,
    hatId,
  });
  ```

- **setHatWearerStatus**
  ハットの着用者のステータスを設定する。

  ```js
  const setHatWearerStatusResult = await hatsClient.setHatWearerStatus({
    account,
    hatId,
    wearer,
    eligible,
    standing,
  });
  ```

- **checkHatWearerStatus**
  ハットの着用者のステータスを確認し、必要に応じて更新する。

  ```js
  const checkHatWearerStatusResult = await hatsClient.checkHatWearerStatus({
    account,
    hatId,
    wearer,
  });
  ```

- **transferHat**
  ハットを別のユーザーに譲渡する。

  ```js
  const transferHatResult = await hatsClient.transferHat({
    account,
    hatId,
    from,
    to,
  });
  ```

- **renounceHat**
  ユーザーが自分のハットを放棄する。

  ```js
  const renounceHatResult = await hatsClient.renounceHat({
    account,
    hatId,
    wearer,
  });
  ```

- **changeHatDetails**
  ハットの詳細を変更する。

  ```js
  const changeHatDetailsResult = await hatsClient.changeHatDetails({
    account,
    hatId,
    newDetails,
  });
  ```

- **changeHatEligibility**
  ハットの適格性モジュールを変更する。

  ```js
  const changeHatEligibilityResult = await hatsClient.changeHatEligibility({
    account,
    hatId,
    newEligibility,
  });
  ```

- **changeHatToggle**
  ハットのトグルモジュールを変更する。

  ```js
  const changeHatToggleResult = await hatsClient.changeHatToggle({
    account,
    hatId,
    newToggle,
  });
  ```

- **changeHatMutable**
  ハットの変更可能フラグを更新する。

  ```js
  const changeHatMutableResult = await hatsClient.changeHatMutable({
    account,
    hatId,
    newMutable,
  });
  ```

- **changeHatImageURI**
  ハットの画像URIを更新する。

  ```js
  const changeHatImageURIResult = await hatsClient.changeHatImageURI({
    account,
    hatId,
    newImageURI,
  });
  ```

- **changeHatName**
  ハットの名前を変更する。

  ```js
  const changeHatNameResult = await hatsClient.changeHatName({
    account,
    hatId,
    newName,
  });
  ```

- **setHatStatus**
  ハットのステータスを直接設定する。

  ```js 
  const setHatStatusResult = await hatsClient.setHatStatus({
    account,
    hatId,
    wearer,
    eligible,
    standing,
  });     
  ```

- **revokeHatWearer**
  特定の着用者からハットを取り上げる。

  ```js
  const renounceHatResult = await hatsClient.renounceHat({
    account,
    hatId,
  });
  ```

### MuitiCall

一括で複数のトランザクションを実行することもできます！！

```js
const multicallResult = await hatsClient.multicall({
    account,
    calls,
});
```

`calls`に実行させたいトランザクションのデータを詰めます。

```json
{
  account: Account | Address;
  calls: {
    functionName: string;
    callData: Hex;
  }[];
}
```

例えば以下のように用意します。

```js
const mintTopHatCallData = await hatsClient.mintTopHatCallData({
    target,
    details,
    imageURI,
});

const createHatCallData = await hatsClient.createHatCallData({
    admin,
    details,
    maxSupply,
    eligibility,
    toggle,
    mutable,
    imageURI,
});

const mintHatCallData = await hatsClient.mintHatCallData({
    hatId,
    wearer,
});

const multiCallResult = await hatsClient.multicall({
    account,
    calls: [
      mintTopHatCallData, 
      createHatCallData, 
      mintHatCallData
    ],
});
```

`multicallPreFlightCheck` というマルチコール用のシミュレート関数があります。

```js
await hatsClient.multicallPreFlightCheck({
  account,
  calls,
});
```

### ClaimHat

Hat関連で便利な関数がいくつか用意されています。


- **accountCanClaim**
  アカウントが特定のハットを請求できるかどうかを確認します。

  ```js
  const canClaim = await hatsClient.accountCanClaim({
    hatId,
    account,
  });
  ```

- **canClaimForAccount**
  特定のアカウントの代わりにハットを請求できるかどうかを確認します。

  ```js
  const canClaimFor = await hatsClient.canClaimForAccount({
    hatId,
    account,
  });
  ```

- **claimHat**
  呼び出し元のアカウントのためにハットを請求します。

  ```js
  const claimHatResult = await hatsClient.claimHat({
    account,
    hatId,
  });
  ```

- **claimHatFor**
  選択されたアカウントの代わりにハットを請求します。

  ```js
  const claimHatForResult = await hatsClient.claimHatFor({
    account,
    hatId,
    wearer,
  });
  ```

- **multiClaimHatFor**
  複数のアカウントの代わりにハットを請求します。

  ```js
  const claimHatForResult = await hatsClient.multiClaimHatFor({
    account,
    hatId,
    wearers,
  });
  ```

### 便利な機能

他にもSDKには便利な機能がいくつか用意されています！！

- **hatIdDecimalToHex**
  ハットIDを10進数から16進数に変換します。

  ```js
  import { hatIdDecimalToHex } from "@hatsprotocol/sdk-v1-core";

  const hatIdHex = hatIdDecimalToHex(hatId);
  ```

- **hatIdHexToDecimal**
  ハットIDを16進数から10進数に変換します。

  ```js
  import { hatIdHexToDecimal } from "@hatsprotocol/sdk-v1-core";

  const hatIdDecimal = hatIdHexToDecimal(hatId);
  ```

- **treeIdDecimalToHex**
  ツリーIDを10進数から16進数に変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js
  import { treeIdDecimalToHex } from "@hatsprotocol/sdk-v1-core";

  const treeIdHex = treeIdDecimalToHex(treeId);
  ```

- **treeIdHexToDecimal**
  ツリーIDを16進数から10進数に変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js
  import { treeIdHexToDecimal } from "@hatsprotocol/sdk-v1-core";

  const treeIdDecimal = treeIdHexToDecimal(treeId);
  ```

- **treeIdToTopHatId**
  ツリーIDをトップハットIDに変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js 
  import { treeIdToTopHatId } from "@hatsprotocol/sdk-v1-core";

  const tophatId = treeIdToTopHatId(treeId);
  ```

- **hatIdToTreeId**
  ハットIDをツリーIDに変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js 
  import { hatIdToTreeId } from "@hatsprotocol/sdk-v1-core";

  const treeId = hatIdToTreeId(hatId);
  ```

- **hatIdDecimalToIp**
  IP形式は、見栄えの良いハットID形式として使用されることがあります。

  例えば、16進数IDが `0x00000001000a0002000000000000000000000000000000000000000000000000` であるハットは、IP形式で 1.10.2 となります。各レベルはドットで区切られ、ゼロを除いて10進数として表示されます。

  ```js
  import { hatIdDecimalToIp } from "@hatsprotocol/sdk-v1-core";

  const hatIdIp = hatIdDecimalToIp(hatId);
  ```

- **hatIdIpToDecimal**
  ハットIDをIP形式から10進数形式に変換します。


  ```js
  import { hatIdIpToDecimal } from "@hatsprotocol/sdk-v1-core";

  const hatIdDecimal = hatIdIpToDecimal(hatId);
  ```

## Subgraph用のSDKについて

HatsProtocolでは SubGraphも用意されています！！

既に用意されているサブグラフのエンドポイントは以下の通りです！！

https://docs.hatsprotocol.xyz/for-developers/v1-subgraphs

詳しい使い方は以下のドキュメントから確認ができます！！

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/getting-started

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/fetching-hats

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/fetching-wearers

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/fetching-trees

**Sepolia** の場合は以下がエンドポイントのようですね

https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest

Hatsや着用者、ツリー情報の情報を取得することが可能みたいです。

取得できるデータの種類については、下記サイトで確認ができます！！

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/types

- **SDKインスタンスの生成例**

  ```ts
  import {HatsSubgraphClient} from "@hatsprotocol/sdk-v1-subgraph";
  import {optimism, sepolia} from "viem/chains";

  // Subgraph用のインスタンスを生成
  const hatsSubgraphClient = new HatsSubgraphClient({
    config: {
      [sepolia.id]: {
        endpoint:
          "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest",
      },
      [optimism.id]: {
        endpoint:
          "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest",
      },
    },
  });
  ```

- **SDKインスタンスの使用例**

  上記で生成したインスタンスは次のように使うことができます！

  ```ts
  // hatの情報を取得する。
  const hat = await hatsSubgraphClient.getHat({
    chainId: 10, // optimism
    hatId: BigInt(
      "0x0000000100020001000100000000000000000000000000000000000000000000"
    ),
    props: {
      maxSupply: true, // get the maximum amount of wearers for the hat
      wearers: {
        // get the hat's wearers
        props: {}, // for each wearer, include only its ID (address)
      },
      events: {
        // get the hat's events
        props: {
          transactionID: true, // for each event, include the transaction ID
        },
        filters: {
          first: 10, // fetch only the latest 10 events
        },
      },
    },
  });

  console.log("hat:", hat);
  ```

## Hats モジュール

**Hatsモジュール**とは、Eligibilityモジュール、Toggleモジュール、またはHatterコントラクトとして機能する任意のコントラクトを指します。

モジュールは、Hats Protocolの動作をカスタマイズ、自動化、拡張するもので、他のプロトコルやアプリケーションとのアダプターや統合ポイントとしても機能します。

ある意味で、モジュールはHats Protocolの生命線です。

デザインの幅は広く、組織や協調のためのあらゆる構成要素を作り出す可能性に満ちています。


開発者がHatsモジュールを扱うには、主に二つの方法があります。

- ### **既存のモジュールと連携する方法**

  **Modules SDK** を使います！！

  - **必要なライブラリをインストールする方法**

    ```bash
    yarn add @hatsprotocol/modules-sdk viem
    ```

  - **セットアップ**

    以下のようにセットアップするようです。

    Subgraph用のSDKとほぼ同じですね！

    ```ts
    import { HatsModulesClient } from "@hatsprotocol/modules-sdk";

    const hatsModulesClient = new HatsModulesClient({
        publicClient,
        walletClient,
    });
    ```

  - #### **HatsModule SDKが提供している機能をみていこう！**

    - **prepare**

      この関数は、モジュールレジストリからデータを取得します。

      https://github.com/Hats-Protocol/modules-registry
      
      このステップは、クライアントを使用できるようにするために必要です。
      
      さらに、この関数はオプションでレジストリを入力として受け取ることができ、ユーザーのキャッシュをサポートします。もしレジストリが提供された場合、クライアントはレジストリからデータを取得する代わりに、提供されたモジュールを使用します。

      ```ts
      await hatsModulesClient.prepare();
      ```

    - **getModules**

      使用可能なモジュール一覧を取得するメソッド

      ```ts
      const modules = hatsModulesClient.getAllModules();
      ```

    - **getModuleById**

      モジュールIDを指定してモジュールを取得するメソッド

      ```ts
      const module = hatsModulesClient.getModuleById(moduleId);
      ```

    - **getModuleByImplementation**

      `implementation`アドレスを指定してモジュールを取得するメソッド

      ```ts
      const module = hatsModulesClient.getModuleByImplementation(address);
      ```

    - **getModuleByInstance**

      こちらもアドレスを取得してモジュールを取得するメソッドらしい

      ```ts
      const module = await hatsModulesClient.getModuleByInstance(address);
      ```

    - **getModulesByInstances**

      ```ts
      const modules = await hatsModulesClient.getModulesByInstances(addresses);
      ```

    - **createNewInstance**

      新しいモジュールインスタンスを作成します。

      ```ts
      /**
       *
      * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はアドレス、その他のタイプの場合はアカウント）。
      * @param {string} moduleId - モジュールID（実装アドレス）。
      * @param {bigint} hatId - モジュールが作成される帽子ID。
      * @param {unknown[]} immutableArgs - モジュールの不変引数。引数はModuleオブジェクト内の順序と同じでなければなりません。
      * @param {unknown[]} mutableArgs - モジュールの可変引数。引数はModuleオブジェクト内の順序と同じでなければなりません。
      * @param {bigint} [saltNonce] - オプションのソルトナンス。提供されない場合はランダムに生成されます。
      * @return {Object} - レスポンスオブジェクト。
      * @return {string} status - トランザクションが成功した場合は"success"、リバートした場合は"reverted"。
      * @return {string} transactionHash - トランザクションのハッシュ。
      * @return {string} newInstance - 成功した場合、新しいモジュールインスタンスのアドレス。
      */
      const createInstanceResult = await hatsModulesClient.createNewInstan(
        {
          account,
          moduleId,
          hatId,
          immutableArgs,
          mutableArgs,
          saltNonce,
        });
      ```

    - **batchCreateNewInstances**

      まとめて複数のモジュールを作るメソッドです。

      ```ts
      /**
       *
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はアドレス、その他のタイプの場合はアカウント）。
       * @param {string[]} moduleIds - モジュールID（実装アドレス）。
       * @param {bigint[]} hatIds - モジュールが作成される帽子ID。
       * @param {unknown[][]} immutableArgsArray - 各モジュールの不変引数。モジュールごとに、引数はModuleオブジェクト内の順序と同じでなければなりません。
       * @param {unknown[][]} mutableArgsArray - 各モジュールの可変引数。モジュールごとに、引数はModuleオブジェクト内の順序と同じでなければなりません。
       * @param {bigint[]} [saltNonces] - オプションのソルトナンス。提供されない場合はランダムに生成されます。
       * @return {Object} - レスポンスオブジェクト。
       * @return {string} status - トランザクションが成功した場合は"success"、リバートした場合は"reverted"。
       * @return {string} transactionHash - トランザクションのハッシュ。
       * @return {string[]} newInstances - 成功した場合、新しいモジュールインスタンスのアドレス。
       */
      const createInstancesResult = await hatsModulesClient.batchCreateNewInstances(
        {
          account,
          moduleIds,
          hatIds,
          immutableArgsArray,
          mutableArgsArray,
          saltNonces
        });
      ```

    - **predictHatsModuleAddress**

      作成引数を使用して、モジュールのアドレスを予測します。

      ```ts
      /**
       *
       * @param {string} moduleId - モジュールID。
       * @param {bigint} hatId - インスタンス作成関数に提供されたターゲットの帽子ID。
       * @param {unknown[]} immutableArgs - インスタンス作成関数に提供されたモジュールの不変引数。
       * @param {bigint} saltNonce - 使用するソルトナンス。
       * @return {string} - 予測されたモジュールアドレス。
       */
      const predictedAddress = await hatsModulesClient.predictHatsModuleAddress(
        {
          moduleId,
          hatId,
          immutableArgs,
          saltNonce,
        });
      ```

    - **createEligibilitiesChain**

      新しい適格性モジュールを作成するメソッド

      ```ts 
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、それ以外はAccount）。
      * @param {bigint} hatId - モジュールが作成される対象の帽子ID。
      * @param {number} numClauses - 論理結合節の数。
      * @param {number[]} clausesLengths - 各節の長さ。
      * @param {string[]} modules - 提供された各節に対応する順序でチェーン化するモジュールインスタンスの配列。
      * @param {bigint} [saltNonce] - オプションのソルトナンス。指定されない場合はランダムに生成されます。
      * @return {Object} - トランザクション結果と新しいチェーンモジュールインスタンスのアドレス。
      */
      const createInstanceResult = await hatsModulesClient.createEligibilitiesChain(
        {
          account,
          hatId,
          numClauses,
          clausesLengths,
          modules,
          saltNonce,
      });
      ```

    - **createTogglesChain**

      新しいトグルモジュールを作成するメソッド

      ```ts
      /**
        * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、それ以外はAccount）。
        * @param {bigint} hatId - モジュールが作成される対象の帽子ID。
        * @param {number} numClauses - 論理結合節の数。
        * @param {number[]} clausesLengths - 各節の長さ。
        * @param {string[]} modules - 提供された各節に対応する順序でチェーン化するモジュールインスタンスの配列。
        * @param {bigint} [saltNonce] - オプションのソルトナンス。指定されない場合はランダムに生成されます。
        * @return {Object} - トランザクション結果と新しいチェーンモジュールインスタンスのアドレス。
        */
      const createInstanceResult = await hatsModulesClient.createTogglesChain(
        {
          account,
          hatId,
          numClauses,
          clausesLengths,
          modules,
          saltNonce,
        });
      ```

    - **getRulesets**

      モジュールインスタンスのルールセットを取得するメソッド

      ```ts
      /**
       * @param {string} address - インスタンスのアドレス。
      * @return {Ruleset[] | undefined} - モジュールのルールセット、または指定されたアドレスがモジュールでない場合はundefined。
      */
      const rulesets = await hatsModulesClient.getRulesets(address);
      ```

    - **getRulesetsBatched**

      複数のモジュールインスタンスのルールセットを取得するメソッド

      ```ts
      /**
       * @param {string[]} addresses - インスタンスのアドレスの配列。
      * @return {(Ruleset[] | undefined)[]} - 各モジュールインスタンスのルールセット、または指定されたアドレスがモジュールでない場合はundefined。
      */
      const rulesets = await hatsModulesClient.getRulesetsBatched(addresses);
      ```

    - **isChain**

      モジュールインスタンスがモジュールチェーンかどうかを確認するメソッド

      ```ts
      /**
       * @param {string} address - インスタンスのアドレス。
      * @return {boolean} - インスタンスがチェーンであればtrue、そうでなければfalse。
      */
      const isChain = await hatsModulesClient.isChain(address);
      ```

    - **isChainBatched**

      複数のモジュールインスタンスがモジュールチェーンかどうかを確認するメソッド

      ```ts
      /**
       * @param {string[]} addresses - インスタンスのアドレスの配列。
      * @return {boolean[]} - 各インスタンスがチェーンであればtrue、そうでなければfalse。
      */
      const isChainBatched = await hatsModulesClient.isChainBatched(addresses);
      ```

    - **isModuleDeployed**

      モジュールが既にデプロイされているかどうかを確認するメソッド

      ```ts
      /**
       * @param {string} moduleId - モジュールのID。
      * @param {bigint} hatId - インスタンス作成関数に提供されたターゲットの帽子ID。
      * @param {unknown[]} immutableArgs - インスタンス作成関数に提供されたモジュールの不変引数。
      * @param {bigint} saltNonce - 使用するソルトナンス。
      * @return {boolean} - モジュールがデプロイされていれば true、そうでなければ false。
      */
      const isDeployed = await hatsModulesClient.isModuleDeployed(
        {
          moduleId,
          hatId,
          immutableArgs,
          saltNonce,
        });
      ```

    - **getInstanceParameters**

      モジュールインスタンスのライブパラメータを取得するメソッド

      ```ts
      /**
       * @param {string} instance - インスタンスのアドレス。
      * @return {object[]} - 各パラメータの情報を含むオブジェクトの配列
      */
      const module = await hatsModulesClient.getInstanceParameters(instance);
      ```

    - **callInstanceWriteFunction**

      モジュールの書き込み関数を呼び出すメソッド。

      <br/>

      モジュールのオブジェクトの `customRoles` と `writeFunctions` プロパティを使用して、モジュールのすべての書き込み関数をプログラム的に取得し、各関数を呼び出すために必要な入力引数やロール（Hats）を取得します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウント用のAddressまたはその他のタイプのAccount）。
      * @param {string} moduleId - モジュールのID（実装アドレス）。
      * @param {Address} instance - インスタンスのアドレス。
      * @param {WriteFunction} func - 呼び出す関数をWriteFunctionタイプのオブジェクトとして提供します。
      * @param {unknown[]} args - 関数に渡す入力引数。
      */
      const res = await hatsModulesClient.callInstanceWriteFunction(
        {
          account,
          moduleId,
          instance,
          func,
          args,
        });
      ```
- ### **新しいモジュールを構築する方法**

  下記を参考にして新しくモジュールを作ることになります！！

  https://docs.hatsprotocol.xyz/for-developers/hats-modules/building-hats-modules

  - **Hatsモジュールの内部構造**

    通常、Hatsモジュールは**HatsModule.sol**コントラクトを継承します。

    https://github.com/Hats-Protocol/hats-module/blob/main/src/HatsModule.sol

      - **HotModule.sol**

        - 新しいHatsモジュールコントラクトに必要な基本的なテンプレートを提供します。
        - **HatsModuleFactory.sol**との互換性を持たせます。これにより、ユーザーは指定されたモジュールの新しいインスタンスを最も簡単かつ安価にデプロイできます。
        - モジュールレジストリとの互換性を持たせ、ユーザーがモジュールを見つけやすくし、Hatsのフロントエンドに統合することができます。

    <br/>
    
    これは抽象コントラクトであり、特定のユースケースに対応するためにモジュールが拡張できる汎用的な構造を提供します。

    <br/>

    **HatsModule.sol**を継承することは、HatsModuleFactoryを介してデプロイ可能であること、モジュールレジストリにリストされること、レジストリを使用するアプリケーションにネイティブに表示されるために必要です。

    ただし、Hats Protocol全般と互換性を持たせるためには必須ではありません。これに関する要件については、EligibilityモジュールとToggleモジュールのドキュメントを参照してください。

    - **HotModule.solの主な機能**

      HatsModule.solの主な機能は、モジュールをHatsModuleFactoryを介して構成しデプロイできるようにすることです。通常、モジュールが関連付けられる新しいハットごとに、そのモジュールの新しいインスタンスが必要になるため、デプロイの際にガス効率が重要です。さらに、モジュールはその生涯の間に何度も呼び出されることが多いため、実行時のガス効率も重要です。

      <br/>

      これらの理由から、HatsModule.solは、イミュータブルな引数をサポートする最小限のプロキシ（クローン）コントラクトとして構成されています。これはEIP-1167標準に類似しており、ガス効率の高いLibClone.solライブラリを実装しています。

      <br/>

      HatsModule.solの動作に関する詳細は、以下のページを参照してください。

    - **拡張機能**

      HatsModule.solには、一般的なモジュールタイプの出発点として役立ついくつかの標準的な拡張機能があります。

      - HatsEligibilityModule.sol: IHatsEligibility.solを実装
      - HatsToggleModule.sol: IHatsToggle.solを実装

  - **新しいモジュールを作る方法**

    - **はじめに**
      **hats-module-template**リポジトリを使えば、新しいモジュールの構築を簡単に始められます。このリポジトリには、次の内容が含まれています:

      - Hatsに関連する設定がされた初期化済みのFoundryプロジェクト
      - 初期依存関係として追加されたforge-stdとhats-module
      - スタート用のモジュールコントラクトのひな形
      - テストとデプロイ用のファイルテンプレート
      - Forgeテストとガスコストの差分を確認するためのGithub CIワークフロー

      <br/>
    
      エリジビリティモジュールを作成するには、HatsModuleを継承し、さらにIHatsEligibilityインターフェースを実装するHatsEligibilityModuleコントラクトをインポートして継承します:

      ```solidity
      import { HatsEligibilityModule } from "hats-module/HatsModule.sol";
      ```
    
      同様に、トグルモジュールの場合は、HatsModuleを継承し、さらにIHatsToggleインターフェースを実装するHatsToggleModuleコントラクトをインポートして継承します:

      ```solidity
      import { HatsToggleModule } from "hats-module/HatsModule.sol";
      ```

    - **モジュールインスタンスのデプロイ方法**

      HatsModuleを継承したすべてのコントラクトは、HatsModuleFactoryを介して最小限のプロキシクローンとしてデプロイできます。HatsModuleFactoryでは、次の操作が可能です。

      <br/>

      - 単一のモジュールインスタンスを作成
      - 複数のモジュールインスタンスを一括作成
      - モジュールインスタンスのアドレスを予測
      - モジュールインスタンスが既にデプロイされているかを確認

      <br/>

      これらの関数はHatsModuleFactoryコントラクトで直接呼び出すことができ、またModules SDKを介して簡単に新しいモジュールインスタンスをデプロイすることもできます。

    - **createHatsModule**

      ```solidity
      function createHatsModule(
        address _implementation,
        uint256 _hatId,
        bytes calldata _otherImmutableArgs,
        bytes calldata _initData
      ) public returns (address _instance)
      ```

      新しいモジュールのデプロイとセットアップが完了すると、次のイベントが発行され、新しいインスタンスのアドレスが含まれます。

      ```solidity
      event HatsModuleFactory_ModuleDeployed(
        address implementation, 
        address instance, 
        uint256 hatId, 
        bytes otherImmutableArgs, 
        bytes initData
      );
      ``` 
    
    - **batchCreateHatsModule**

      batchCreateHatsModule関数は、createHatsModule関数を使用して複数のインスタンスを作成します。

      <br/>

      必要な作成パラメータは配列として渡され、それぞれの配列の長さは作成するモジュールの数と同じである必要があります。各モジュールに対して、createHatsModule関数が同じインデックスの配列エントリで呼び出されます。

      ```solidity 
      function batchCreateHatsModule(
        address[] calldata _implementations,
        uint256[] calldata _hatIds,
        bytes[] calldata _otherImmutableArgsArray,
        bytes[] calldata _initDataArray
      ) public returns (bool success)
      ```

    - **getHatsModuleAddress**

      getHatsModuleAddress関数は、モジュールインスタンスが作成される前に、そのアドレスを予測します。

      ```solidity
      function getHatsModuleAddress(
        address _implementation, 
        uint256 _hatId, 
        bytes calldata _otherImmutableArgs
      ) public view returns (address)
      ```

    - **deployed**

      deployed関数は、特定のモジュールインスタンスがデプロイされているかどうかを確認します。

      ```solidity
      function deployed(
        address _implementation, 
        uint256 _hatId, 
        bytes calldata _otherImmutableArgs
      ) public view returns (bool)
      ```

    - **HatsModuleFactoryのアドレス**
      
      どのネットワークでもアドレスは共通して **0xfE661c01891172046feE16D3a57c3Cf456729efA** みたいです。

      https://sepolia.etherscan.io/address/0xfe661c01891172046fee16d3a57c3cf456729efa

  - **Module Chainsについて**

    エリジビリティ条件を複数のモジュールで組み合わせたい場合はどうすればいいでしょうか？例えば、ある人が特定のNFT（例：DAOのメンバーシップを表すもの）を持っていることと、さらに選挙で勝利することが条件である場合です。これこそが、エリジビリティチェーン/トグルチェーンモジュールの目的です。

    <br/>

    HatsEligibilitiesChainは、複数のエリジビリティモジュールを「and」/「or」の論理演算で組み合わせるエリジビリティモジュールです。同様に、HatsTogglesChainは、複数のトグルモジュールを組み合わせるトグルモジュールです。

    <br/>

    これらのモジュールは、いずれも同様の構造を持っています。モジュールは、「and」演算子で結合された論理節の非結合形式でチェーン化されます。例えば、"(module1 && module2) || module3"には、2つの論理節があります。

    - "(module1 && module2)"
    - "module3"

    <br/>

    これらの論理節は、「or」演算子でチェーン化されています。

    <br/>

    - **Deriving Wearer Eligibility:**

      エリジビリティチェーンモジュールでは、各モジュールのエリジビリティをチェックし、選択された論理演算に基づいて結果を組み合わせることで、着用者のエリジビリティが判定されます。しかし、どのモジュールにおいても着用者が「不良ステータス」にある場合、そのモジュールは「エリジブルではない」および「不良ステータスにある」という結果を返します。

    - **Deriving Hat Status:**

      トグルチェーンモジュールでは、各モジュールのステータスをチェックし、選択された論理演算に基づいて結果を組み合わせることで、ハットのステータスが判定されます。

  - **新しいエリジビリティ/トグルチェーンモジュールを作成する**

    このモジュールは、可変ストレージ変数を使用せず、初期化データも使用しません。以下の不変変数のみが使用され、モジュールインスタンスの作成時に設定されます。

    <br/>

    - 論理節の数
    - 論理節の長さ
    - エリジビリティ/トグルモジュールのリスト
    
    <br/>
    
    上記の例を使用して、モジュールのデプロイに使用される不変引数の例は次のとおりです。

    ```solidity
    bytes memory otherImmutableArgs = abi.encodePacked(2, [2,1], module1Address, module2Address, module3Address);
    ```

    このモジュールには、これらの不変変数のための以下のゲッターが含まれています。

    ```solidity
    function NUM_CONJUCTION_CLAUSES() public pure returns (uint256)

    function CONJUCTION_CLAUSE_LENGTHS() public pure returns (uint256[] memory)

    function MODULES() public pure returns (address[] memory)
    ```

## Hats Signer Gate SDK

**Hats Signer Gate（HSG）** は、特定のHatを着用しているアドレスに対してマルチシグ署名権を付与するコントラクトです。

これにより、オンチェーン組織（DAOなど）が、個々のユーザーに対して制限付きの署名権限と責任を取り消し可能に委任することができます。

**Multi Hats Signer Gate（MHSG）** は、HSGの改良版で、複数のHatを有効な署名者Hatとして設定することができます。

このSDKは、HSGおよびMHSGのインスタンスを作成し、操作するためのオープンソースのJavaScriptクライアントです。ブラウザとNode.jsの両方で動作するように設計されています。

Hats Signer Gateの詳細な概要については、こちらをご覧ください。

- ### Getting Start

  以下のコマンドで必要なライブラリをインストールする。

  ```bash
  yarn add @hatsprotocol/hsg-sdk viem
  ```

  実際には以下のようにインスタンスを作成する。

  ```ts
  import { HatsSignerGateClient } from "@hatsprotocol/hsg-sdk";

  const hatsSignerGateClient = new HatsSignerGateClient({
    publicClient,
    walletClient,
  });
  ```

- ### Creating New Instances

  - **deployHatsSignerGateAndSafe**

    新しいHSGと新しいSafeを作成し、それらをすべて接続します。

    ```ts
    /**
     * @param account: Account | Address;  // Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプはAccount）
     * @param ownerHatId: bigint;          // HSGのオーナーHatのID
     * @param signersHatId: bigint;        // HSGの署名者HatのID
     * @param minThreshold: bigint;        // HSGの最小閾値
     * @param targetThreshold: bigint;     // HSGの目標閾値
     * @param maxSigners: bigint;          // HSGの最大署名者数
     */
    const createHsgResult = await hatsSignerGateClient.deployHatsSignerGateAndSafe(
      {
        account,
        ownerHatId,
        signersHatId,
        minThreshold,
        targetThreshold,
        maxSigners,
      });
    ```

  - **deployHatsSignerGate**

    新しいHSGをデプロイし、それを既存のSafeに関連付けます。既存のSafeに接続するには、Safeの所有者がそれをモジュールおよびガードとして有効にする必要があります。


    :::message
      - HatsSignerGateは他のモジュールが接続されているSafeには取り付けないでください。
      
      - HatsSignerGateはvalidSignerCount() >= _maxSignersの場合、そのSafeに取り付けないでください。
    :::

    HatsSignerGateをSafeに接続する前に、canAttachHSGToSafeを呼び出して結果がtrueであることを確認してください。そうしないと、Safeが永久にロックされる可能性があります。

    ```ts
    /**
     * @param account: Account | Address;  // Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプはAccount）
     * @param ownerHatId: bigint;          // HSGのオーナーHatのID
     * @param signersHatId: bigint;        // HSGの署名者HatのID
     * @param safe: Address;               // 署名者が参加する既存のGnosis Safe
     * @param minThreshold: bigint;        // HSGの最小閾値
     * @param targetThreshold: bigint;     // HSGの目標閾値
     * @param maxSigners: bigint;          // HSGの最大署名者数
     */
     const createHsgResult = await hatsSignerGateClient.deployHatsSignerGate(
      {
        account,
        ownerHatId,
        signersHatId,
        safe,
        minThreshold,
        targetThreshold,
        maxSigners,
      });
    ```

  - **deployMultiHatsSignerGateAndSafe**

    新しいMHSGと新しいSafeを作成し、それらをすべて接続します。

    ```ts
    /**
     * @param account: Account | Address;  // Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプはAccount）
     * @param ownerHatId: bigint;          // MHSGのオーナーHatのID
     * @param signersHatIds: bigint[];     // MHSGの署名者HatのIDs
     * @param minThreshold: bigint;        // MHSGの最小閾値
     * @param targetThreshold: bigint;     // MHSGの目標閾値
     * @param maxSigners: bigint;          // MHSGの最大署名者数
     */
    const createMhsgResult = await hatsSignerGateClient.deployMultiHatsSignerGateAndSafe(
      {
        account,
        ownerHatId,
        signersHatIds,
        minThreshold,
        targetThreshold,
        maxSigners,
      });
    ```

  - **deployMultiHatsSignerGate**

    新しいMHSGをデプロイし、それを既存のSafeに関連付けます。既存のSafeに接続するには、Safeの所有者がそれをモジュールおよびガードとして有効にする必要があります。

    :::message
      - MultiHatsSignerGateは他のモジュールが接続されているSafeには取り付けないでください。

      - MultiHatsSignerGateはvalidSignerCount() >= _maxSignersの場合、そのSafeに取り付けないでください。
    :::

    MultiHatsSignerGateをSafeに接続する前に、canAttachMHSGToSafeを呼び出して結果がtrueであることを確認してください。そうしないと、Safeが永久にロックされる可能性があります。

    ```ts
    /**
     * @param account: Account | Address;  // Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプはAccount）
     * @param ownerHatId: bigint;          // MHSGのオーナーHatのID
     * @param signersHatIds: bigint[];     // MHSGの署名者HatのIDs
     * @param safe: Address;               // 署名者が参加する既存のGnosis Safe
     * @param minThreshold: bigint;        // MHSGの最小閾値
     * @param targetThreshold: bigint;     // MHSGの目標閾値
     * @param maxSigners: bigint;          // MHSGの最大署名者数
     */
    const createMhsgResult = await hatsSignerGateClient.deployMultiHatsSignerGate(
      {
        account,
        ownerHatId,
        signersHatIds,
        safe,
        minThreshold,
        targetThreshold,
        maxSigners,
      });
    ```

- ### Hats Signer Gate

  HSGインスタンスと対話するための機能です。

  - #### **Signers Management**

    - **hsgClaimSigner**

      Signer権限を要求するメソッド

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウント用のアドレス、その他のタイプ用のアカウント）。
       * @param {Address} hsgInstance - HSGのインスタンスアドレス。
       * @return {Object} - トランザクションのステータスとハッシュ。
       */
      const claimSignerResult = await hatsSignerGateClient.hsgClaimSigner({
        account,
        hsgInstance,
      });
      ```

    - **hsgIsValidSigner**

      アカウントがSinersHatを着用しているかどうかを確認するメソッド

      ```ts
      /**
       * @param {Address} hsgInstance - HSGのインスタンスアドレス。
       * @param {Address} address - 確認するアドレス。
       * @return {boolean} - 有効なサイナーであればtrue、そうでなければfalse。
       */
      const isValid = await hatsSignerGateClient.hsgIsValidSigner({
        hsgInstance,
        address    
      });
      ```

    - **claimedAndStillValid**

      アカウントがSigner権利を所有しており、なおかつ有効であるかどうかを確認するメソッド

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @param {Address} address - 確認するアドレス。
       * @return {boolean} - 安全の所有者の1人であり、かつ有効な場合はtrue、それ以外はfalse。
       */
      const claimedAndValid = await hatsSignerGateClient.claimedAndStillValid({
        instance,
        address    
      });
      ```

    - **validSignerCount**

      Signer'sHatを着用している有効なSafeオーナーの数を集計します。

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {bigint} - Safeにおける有効なサイナーの数。
       */
      const count = await hatsSignerGateClient.validSignerCount({
        instance 
      });
      ```

    - **reconcileSignerCount**

      Signer'sHatを着用している有効なSafeオーナーの数を集計し、必要に応じてSafeの閾値を更新します。ただし、無効なSafeオーナーを削除することはありません。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウント用のアドレス、その他のタイプ用のアカウント）。
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {Object} - トランザクションのステータスとハッシュ。
       */
      const res = await hatsSignerGateClient.reconcileSignerCount({
        account,
        instance,
      });
      ```

    - **removeSigner**

      無効なSignerをSafeから削除し、適切に閾値を更新します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウント用のアドレス、その他のタイプ用のアカウント）。
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @param {Address} signer - 無効な場合に削除するアドレス。
       * @return {Object} - トランザクションのステータスとハッシュ。
       */
      const res = await hatsSignerGateClient.removeSigner({
        account,
        instance,
        signer,
      });
      ```

  - #### HSG Instance Properties

    - **hsgSignersHatId**

      HSGのSigner's Hat IDを取得します。

      ```ts
      /**
       * @param {Address} hsgInstance - HSGのインスタンスアドレス。
       * @return {bigint} - HSGのサイナーズハットID。
       */
      const signersHat = await hatsSignerGateClient.hsgSignersHatId({
        hsgInstance 
      });
      ```

    - **getSafe**

      HSGにアタッチされたSafeを取得します。

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {Address} - アタッチされたSafeのアドレス。
       */
      const safe = await hatsSignerGateClient.getSafe({
        instance 
      });
      ```

    - **getMinThreshold**

      HSGの最小閾値を取得します。

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {bigint} - インスタンスの最小閾値。
       */
      const minThreshold = await hatsSignerGateClient.getMinThreshold({
        instance 
      });
      ```

    - **getTargetThreshold**

      HSGの目標閾値を取得します。

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {bigint} - インスタンスの目標閾値。
       */
      const targetThreshold = await hatsSignerGateClient.getTargetThreshold({
        instance 
      });
      ```

    - **getMaxSigners**

      HSGの最大Signers数を取得します。
      
      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {bigint} - インスタンスの最大サイナー数。
       */
      const maxSigners = await hatsSignerGateClient.getMaxSigners({
        instance 
      });
      ```

    - **getOwnerHat**

      HSGのowner Hatを取得します。

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @return {bigint} - インスタンスのオーナーハット。
       */
      const ownerHat = await hatsSignerGateClient.getOwnerHat({
        instance 
      });
      ```

- ### Multi Hats Signer Gate

  MHSGインスタンスを操作するメソッド

  - #### Signers Management

    - **mhsgClaimSigner**

      署名者の権利をSafeで要求します。

      ```ts
      /**
       * @param {Account | Address} account - Viemのアカウント（JSON-RPCアカウントの場合はAddress、それ以外の場合はAccount）。
       * @param {Address} mhsgInstance - MHSGのインスタンスアドレス。
       * @param {bigint} hatId - 署名者の権利を主張するためのHat ID。これは有効なSigners Hatでなければならない。
       */
      const claimSignerResult = await hatsSignerGateClient.mhsgClaimSigner({
        account,
        mhsgInstance,
        hatId,
      });
      ```

    - **mhsgIsValidSigner**

      アカウントがSigners Hatを着用し、署名者の権利を主張しているかどうかを確認します。

      ```ts
      /**
       * @param {Address} mhsgInstance - MHSGのインスタンスアドレス。
       * @param {Address} address - 確認するアドレス。
       */
      const isValid = await hatsSignerGateClient.mhsgIsValidSigner({
          mhsgInstance,
          address    
      });
      ```

    - **claimedAndStillValid**

      アカウントが署名者の権利を主張しており、まだ有効であるかどうかを確認します。

      ```ts
      /**
       * @param {Address} instance - HSGのインスタンスアドレス。
       * @param {Address} address - 確認するアドレス。
       */
      const claimedAndValid = await hatsSignerGateClient.claimedAndStillValid({
        instance,
        address    
      });
      ```

    - **validSignerCount**

      Signers Hatを着用している有効なSafeの所有者の数を数えます。

      ```ts
      /**
       * @param {Address} instance - MHSGのインスタンスアドレス。
       */
      const count = await hatsSignerGateClient.validSignerCount({
          instance 
      });
      ```

    - **reconcileSignerCount**

      Signers Hatを着用しているSafeの所有者の数を数え、必要に応じてSafeの閾値を更新します。ただし、無効なSafeの所有者は削除しません。

      ```ts
      /**
       * @param {Account | Address} account - Viemのアカウント（JSON-RPCアカウントの場合はAddress、それ以外の場合はAccount）。
       * @param {Address} instance - MHSGのインスタンスアドレス。
       */
      const res = await hatsSignerGateClient.reconcileSignerCount({
          account,
          instance,
      });
      ```

    - **removeSigner**

      無効な署名者をSafeから削除し、適宜閾値を更新します。

      ```ts
      /**
       * @param {Account | Address} account - Viemのアカウント（JSON-RPCアカウントの場合はAddress、それ以外の場合はAccount）。
       * @param {Address} instance - MHSGのインスタンスアドレス。
       * @param {Address} signer - 無効な署名者の場合に削除するアドレス。
       */
      const res = await hatsSignerGateClient.removeSigner({
          account,
          instance,
          signer,
      });
      ```

  - #### MHSG Instance Properties

    MHSGインスタンスの基本的なプロパティを取得します。

    - **mhsgIsValidSignersHat**

      指定されたHatが有効なSigners Hatであるかを確認します。

      ```ts
      /**
       * @param {Address} mhsgInstance - MHSGのインスタンスアドレス。
       * @param {bigint} hatId - 確認するHat ID。
       */
      const isValid = await hatsSignerGateClient.mhsgIsValidSignersHat({
          mhsgInstance,
          hatId    
      });
      ```

    - **getSafe**

      MHSGに関連付けられたSafeを取得します。

      ```ts
      /**
       * @param {Address} instance - MHSGのインスタンスアドレス。
       */
      const safe = await hatsSignerGateClient.getSafe({
          instance 
      });
      ```

    - **getMinThreshold**

      MHSGの最小閾値を取得します。

      ```ts
      /**
       * @param {Address} instance - MHSGのインスタンスアドレス。
       */
      const minThreshold = await hatsSignerGateClient.getMinThresholde({
          instance 
      });
      ```

    - **getTargetThreshold**

      MHSGの目標閾値を取得します。

      ```ts
      /**
       * @param {Address} instance - MHSGのインスタンスアドレス。
       */
      const targetThreshold = await hatsSignerGateClient.getTargetThreshold({
          instance 
      });
      ```

    - **getMaxSigners**

      ```ts
      /**
       * @param {Address} instance - MHSGのインスタンスアドレス。
       */
      const maxSigners = await hatsSignerGateClient.getMaxSigners({
          instance 
      });
      ```

    - **getOwnerHat**

      ```ts
      /**
       * @return {bigint} - インスタンスの最大署名者数。
       */
      const ownerHat = await hatsSignerGateClient.getOwnerHat({
          instance 
      });
      ```

  - #### HSG Owner

    MHSGインスタンスのOwner Hatを持つユーザーにのみが実行できるメソッド

    - **mhsgAddSignerHats**

      新しい承認済みSigners Hatsを追加します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプの場合はAccount）。
       * @param {Address} mhsgInstance - MHSGインスタンスのアドレス。
       * @param {bigint[]} newSignerHats - 承認済みのSigners Hatsとして追加するHat IDの配列。
       * @return {{ status: "success" | "reverted", transactionHash: `0x${string}` }} - 取引が成功した場合は"success"、取引がリバートされた場合は"reverted"を返します。transactionHashは取引のハッシュです。
       */
      const res = await hatsSignerGateClient.mhsgAddSignerHats({
          account,
          mhsgInstance,
          newSignerHats,
      });
      ```

    - **setTargetThreshold**

      新しいターゲットしきい値を設定し、適切な場合にはSafeのしきい値を変更します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプの場合はAccount）。
       * @param {Address} instance - HSGインスタンスのアドレス。
       * @param {bigint} targetThreshold - 設定する新しいターゲットしきい値。
       * @return {{ status: "success" | "reverted", transactionHash: `0x${string}` }} - 取引が成功した場合は"success"、取引がリバートされた場合は"reverted"を返します。transactionHashは取引のハッシュです。
       */
      const res = await hatsSignerGateClient.setTargetThreshold({
          account,
          instance,
          targetThreshold,
      });
      ```

    - **setMinThreshold**

      新しい最小しきい値を設定します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプの場合はAccount）。
       * @param {Address} instance - HSGインスタンスのアドレス。
       * @param {bigint} minThreshold - 設定する新しい最小しきい値。
       * @return {{ status: "success" | "reverted", transactionHash: `0x${string}` }} - 取引が成功した場合は"success"、取引がリバートされた場合は"reverted"を返します。transactionHashは取引のハッシュです。
       */
      const res = await hatsSignerGateClient.setMinThreshold({
          account,
          instance,
          minThreshold,
      });
      ```   

    - **setOwnerHat**

      新しいOwner Hatを設定します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプの場合はAccount）。
       * @param {Address} instance - MHSGインスタンスのアドレス。
       * @param {bigint} newOwnerHat - 設定する新しいOwner Hat。
       * @param {Address} hatsContractAddress - 新しいOwner HatのHats.solコントラクトアドレス。
       * @return {{ status: "success" | "reverted", transactionHash: `0x${string}` }} - 取引が成功した場合は"success"、取引がリバートされた場合は"reverted"を返します。transactionHashは取引のハッシュです。
       */
      const res = await hatsSignerGateClient.setOwnerHat({
          account,
          instance,
          newOwnerHat,
          hatsContractAddress,
      });
      ```

- ### MHSG & MHSG Handlers

  SDKにはHSGおよびMHSGインスタンスの書き込み操作を呼び出すための単一のハンドラーも含まれています。これにより、HSG/MHSGのやり取りを、Hats Modulesとのやり取りと同様に、HSGおよびMHSGのメタデータオブジェクトと単一の書き込み関数ハンドラーを使用して処理することが可能になります。

  - #### **Handlers**

    - **callInstanceWriteFunction**

      HSG/MHSGインスタンスの書き込み関数を呼び出します。

      ```ts
      /**
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はAddress、その他のタイプの場合はAccount）。
       * @param {HsgType} type - 'HSG' または 'MHSG'。
       * @param {Address} instance - MHSG/HSGインスタンスのアドレス。
       * @param {WriteFunction} func - 呼び出す書き込み関数。WriteFunction型のオブジェクトとして提供されます。
       * @param {unknown[]} args - 関数を呼び出すための引数。WriteFunctionArg型のオブジェクトとして提供されます。
       * @return {{ status: "success" | "reverted", transactionHash: `0x${string}` }} - 取引が成功した場合は"success"、取引がリバートされた場合は"reverted"を返します。transactionHashは取引のハッシュです。
       */
      const res = await hatsSignerGateClient.callInstanceWriteFunction({
          account,
          type,
          instance,
          func,
          args,
      });
      ```

    - **getInstanceParameters**

      HSGまたはMHSGインスタンスのライブパラメータを取得します。

      ```ts
      /**
       * @param {Address} instance - インスタンスのアドレス。
       * @return {{ label: string, value: unknown, solidityType: string, displayType: string }[]} - 各パラメータの情報を含むオブジェクトの配列。labelはパラメータの名前や説明、valueはインスタンスコントラクトから返されたパラメータの値、solidityTypeはパラメータのSolidity型、displayTypeはUIで適切なコンポーネントをレンダリングするためのタイプです。
       */
      const params = await hatsSignerGateClient.getInstanceParameters(instance);
      ```

  - #### **Metadata**

    HSGおよびMHSGのメタデータオブジェクトには、それぞれのABI、書き込み関数、および各関数に関連するメタデータやカスタムロールが含まれています。

    - **getMetadata**

      HSGまたはMHSGのメタデータオブジェクトを取得します。

      ```ts
      /**
       * @param {HsgType} type - "HSG" または "MHSG"。
       * @return {HsgMetadata} - HsgMetadata型のオブジェクト。
       */
      const metadata = await hatsSignerGateClient.getMetadata(type);
      ```

  - #### **Type**

    - **HsgMetadata**

      HSGまたはMHSGのメタデータオブジェクトを表します。

      ```ts
      {
        customRoles: Role[]; // HSG/MHSGカスタムロール
        writeFunctions: WriteFunction[]; // HSG/MHSG書き込み関数
        abi: Abi; // HSG/MHSG ABI
      }
      ```

    - **Role**

      カスタムHSG/MHSGロール。各ロールには帽子が関連付けられており、その帽子の着用者がコントラクトの特定の関数を呼び出す権限を持ちます。

      ```ts
      {
        id: string; // ロールのID
        name: string; // ロールの名前
        criteria: string; // ロールの帽子を取得するために使用されるコントラクト関数の名前
        hatAdminsFallback?: boolean; // 'true' の場合、ロールのcriteria関数がゼロを返すとき、そのロールはターゲット帽子の管理者に付与されます。
      }
      ```

    - **WriteFunction**

      HSG/MHSG書き込み関数。各書き込み関数は、ロールの着用者がコントラクトの関数を呼び出す権限を持つロールに関連付けられています。

      ```ts
      {
        roles: string[]; // 関数を呼び出す権限を持つロールのID
        functionName: string; // コントラクト内の関数名
        label: string; // エンドユーザーに表示する関数名
        description: string; // エンドユーザーに表示する関数の説明
        primary?: boolean; // 'true' の場合、この関数は関連するロールの主要関数です。フロントエンドは、この情報を使用して各ロールの関数をより目立たせて表示できます。
        args: WriteFunctionArg[]; // 関数の引数
      }
      ```

    - **WriteFunctionArg**

      HSG/MHSG書き込み関数の引数。

      ```ts
      {
        name: string; // 引数の名前
        description: string; // 引数の説明
        type: string; // 引数のSolidity型、例：'uint256'
        displayType: string; // 引数に適したUIコンポーネントを生成するためのフィールド
        optional?: boolean; // 'true' に設定すると、この入力はオプションであることを示します。
      }
      ```

## Hats Account SDK

**HatsAccount**は、Hats Protocolの各ハットにスマートコントラクトアカウントを提供します。

各ハットには、**ERC6551**規格に準拠し、ERC6551Registryファクトリーを介してデプロイされる複数のHatsAccountのバリエーションが存在します。

HatsAccountにより、各ハットは以下の機能を持つことができます:

- ETH、ERC20、ERC721、ERC1155トークンの送信
- マルチシグの署名者として、ERC1271互換のメッセージに署名
- DAOのメンバーになり、提案を行ったり、投票したりする（例：Moloch DAO）
- 他のコントラクトの関数を呼び出す
- okenboundのサンドボックスコンセプトを利用して、他のコントラクトに`Delegatecall`
- アドレスベースのオンチェーンアクセス制御スキームにおける権限の付与

最初と最後を除くこれらのアクションはすべて、ハットの着用者によって行われ、セキュリティモデルはHatsAccountのバリエーションによって決まります。

このSDKは、Hats Accountインスタンスの作成や操作を行うためのオープンソースのJavaScriptクライアントであり、ブラウザとNode.jsの両方で動作するように設計されています。

### 1 of N Hats Account

HatsAccount1ofN は、典型的な1-of-nセキュリティモデルを反映したHatsAccountの一つです。

このモデルでは、HatsAccount1ofNインスタンスの帽子をかぶるどの個人でも、そのHatsAccountを完全にコントロールすることができます。複数の個人が同じ帽子をかぶっている場合、それぞれが独立して完全なコントロール権を持ちます。

HatsProtocol版のマルチシグって感じですかね。

- #### Getting Started

  Hats Account SDKを使う時はまず以下のライブラリをインストールします。

  ```bash
  yarn add @hatsprotocol/hats-account-sdk viem
  ```

  クライアントインスタンスは以下のように生成すれば良いみたいです！！

  これまでのSDKと同じですね！

  ```ts
  import { HatsAccount1ofNClient } from "@hatsprotocol/hats-account-sdk";

  const hatsAccount1ofNClient = new HatsAccount1ofNClient({
      publicClient,
      walletClient,
  });
  ```

- #### Creating New Instances

  - **createAccount**

    1 of N Hats Account の新しいインスタンスを作成します。

    ```ts
    /**
     * @param {Account | Address} account - Viem アカウント（JSON-RPC アカウントの場合は Address、それ以外のタイプの場合は Account）。
     * @param {bigint} hatId - アカウントを作成する対象の帽子ID。
     * @param {bigint} salt - 任意の数値（"ソルト"として使用）。
     * @return {Object} - 作成結果のオブジェクト。
     */
    const createHatsAccountResult = await hatsAccount1ofNClient.createAccount({
        account,
        hatId,
        salt,
    });
    ```

  - **predictAccountAddress**

    1 of N Hats Account インスタンスのアドレスを予測します。

    ```ts
    /**
     * @param {bigint} hatId - アカウントを作成する対象の帽子ID。
     * @param {bigint} salt - 任意の数値（"ソルト"として使用）。
     * @return {string} - 予測されるアカウントアドレス。
     */
    const predictedAccount = await hatsAccount1ofNClient.predictAccountAddress({
        hatId,
        salt,
    });
    ```

- #### Executing From An Instance

  Hats Account インスタンスから操作を実行します。これらの関数を呼び出せるのは、そのインスタンスの帽子を持つユーザーのみです。

  - **execute**

    ```ts
    /**
     * @param {Account | Address} account - Viem アカウント（JSON-RPC アカウントの場合は Address、それ以外のタイプの場合は Account）。
     * @param {Address} instance - Hats Account インスタンスのアドレス。
     * @param {Operation} operation - 操作の実行データを含む Operation オブジェクト。
     * @return {Object} - 実行結果のオブジェクト。
     */
    const executionResult = await hatsAccount1ofNClient.execute({
        account,
        instance,
        operation,
    });
    ```

  - **executeBatch**

    一連の操作を一括で実行します。

    ```ts
    /**
     * @param {Account | Address} account - Viem アカウント（JSON-RPC アカウントの場合は Address、それ以外のタイプの場合は Account）。
     * @param {Address} instance - Hats Account インスタンスのアドレス。
     * @param {Operation[]} operations - 各操作の実行データを含む Operation オブジェクトの配列。
     * @return {Object} - 実行結果のオブジェクト。
     */
    const executionResult = await hatsAccount1ofNClient.executeBatch({
        account,
        instance,
        operations,
    });
    ```

- #### Type

  - **Operation**

    Hats Account の操作に関する実行データ。

    ```ts
    {
      to: Address; // 操作のターゲットアドレス
      value: bigint; // ターゲットに送信されるEtherの値
      data: Hex; // エンコードされた操作のコールデータ
      operation: OperationType; // 実行する操作の種類を示す OperationType の値
    }
    ```

  - **OperationType**

    実行する操作を示す列挙型。

    ```ts
    {
      Call,         // 通常のコール操作
      DelegateCall, // デリゲートコール操作
    }
    ```

  - **CreateAccountResult**

    アカウント作成の結果。

    ```ts
    {
      status: "success" | "reverted"; // 成功した場合は "success"、失敗した場合は "reverted"
      transactionHash: Address; // トランザクションのハッシュ値
      newAccount: Address; // 新しく作成されたアカウントのアドレス
    }
    ```

  - **ExecutionResult**

    Hats Account の実行結果。

    ```ts
    {
      status: "success" | "reverted"; // 成功した場合は "success"、失敗した場合は "reverted"
      transactionHash: Address; // トランザクションのハッシュ値
    }
    ```

## SDKを使ってみた

では次にSDKを触っていきたいと思います！！

SDKのGitHubは以下です。

https://github.com/Hats-Protocol/sdk-v1-core

自分で触ってみた記録は以下のGitHubにまとめてみました！！

https://github.com/mashharuki/HatsProtocolSample

SDKは **viem** を使うことを前提としているみたいですね。

yarnを使っている場合は以下のコマンドで必要なライブラリをインストールできます。

```bash
yarn add @hatsprotocol/sdk-v1-core
```

サブグラフのSDKも使うのであれば追加で以下のライブラリをインストールします。

```bash
yarn add @hatsprotocol/sdk-v1-subgraph
```

Hats Modules SDKを使うのであれば追加で以下のライブラリをインストールします。

```bash
yarn add @hatsprotocol/modules-sdk viem
```

Hats Signer Gate SDKを使うのであれば追加で以下のライブラリをインストールします。

```bash
yarn add @hatsprotocol/hsg-sdk viem
```

Hats Account SDKを使うのであれば以下のライブラリをインストールします。

```bash
yarn add @hatsprotocol/hats-account-sdk viem
```

このサンプルコードを動かすためには準備が必要なのですがそれについてはREADMEをご覧ください。


環境がセットアップできたらまず以下のコマンドでインストールします。

```bash
yarn
```

その後、以下のコマンドを実行してしましょう！！

```bash
yarn sample sample
```

以下のように出力されればOKです！！

```bash
Current Block Number: 6484557n
Wallet's Balance: 55.995776264812553303 ETH
getting hat info
hatInfo: {
  details: '',
  maxSupply: 0,
  supply: 0,
  eligibility: '0x0000000000000000000000000000000000000000',
  toggle: '0x0000000000000000000000000000000000000000',
  imageUri: 'ipfs://bafkreiflezpk3kjz6zsv23pbvowtatnd5hmqfkdro33x5mh2azlhne3ah4',
  numChildren: 0,
  mutable: false,
  active: false
}
isWearer: false
isAdmin: false
isGoodStanding: true
isEligible: true
numTrees: 443
level: 14
localLevel: 14
domain: 0
requestedAdminHat: 0n
adminHat: 0n
tippyTopHatDomain: 0
adminId: 0n
childrens: []
Done in 6.30s.
```

hatの情報が取得できていますね！！！

少しだけコードの解説をします。

```ts
import {createPublicClient, createWalletClient, formatEther, http} from "viem";
import {sepolia} from "viem/chains";
import * as dotenv from "dotenv";
import {privateKeyToAccount} from "viem/accounts";
import {HatsClient} from "@hatsprotocol/sdk-v1-core";

dotenv.config();

// 環境変数を取得する。
const {RPC_URL, PRIVATE_KEY} = process.env;

// signerオブジェクトを作成する
export const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);

// Sepolia ネットワークのクライアントを作成する
export const client = createPublicClient({
  chain: sepolia,
  transport: http(RPC_URL),
});

// Wallet Client の作成
export const walletClient = createWalletClient({
  chain: sepolia,
  transport: http(RPC_URL),
  account,
});

// HatsProtocol用のインスタンスを生成する。
export const hatsClient = new HatsClient({
  chainId: sepolia.id,
  publicClient: client,
  walletClient,
});

/**
 * メインスクリプト
 */
async function main() {
  try {
    // 最後のブロックの番号を取得する
    const blockNumber = await client.getBlockNumber();
    console.log("Current Block Number:", blockNumber);
    // ウォレットの残高を取得する
    const balance = await client.getBalance({address: account.address});
    console.log(`Wallet's Balance: ${formatEther(balance)} ETH`);

    // hat ID
    const hatId = 442;
    console.log("getting hat info");
    // hatの情報を取得する。
    const hatInfo = await hatsClient.viewHat(BigInt(hatId));
    console.log("hatInfo:", hatInfo);
    // hatの着用者かどうかチェックする。
    const isWearer = await hatsClient.isWearerOfHat({
      wearer: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isWearer:", isWearer);
    // hatの管理者かどうかチェックする。
    const isAdmin = await hatsClient.isAdminOfHat({
      user: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isAdmin:", isAdmin);
    // 着用者が良好な状態にあるかチェックする。
    const isGoodStanding = await hatsClient.isInGoodStanding({
      wearer: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isGoodStanding:", isGoodStanding);
    // 適格な着用者であるかどうかチェックする。
    const isEligible = await hatsClient.isEligible({
      wearer: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isEligible:", isEligible);
    // ツリーの数を取得する。
    const numTrees = await hatsClient.getTreesCount();
    console.log("numTrees:", numTrees);
    // 帽子のレベルを取得する。
    const level = await hatsClient.getHatLevel(BigInt(hatId));
    console.log("level:", level);
    // ローカルでの帽子のレベルを取得する。
    const localLevel = await hatsClient.getLocalHatLevel(BigInt(hatId));
    console.log("localLevel:", localLevel);
    // 帽子のドメインを取得する。
    const domain = await hatsClient.getTopHatDomain(BigInt(hatId));
    console.log("domain:", domain);
    // ツリーのリンクリクエストを取得します。
    const requestedAdminHat = await hatsClient.getLinkageRequest(domain);
    console.log("requestedAdminHat:", requestedAdminHat);
    // リンクされたツリーの管理者を取得する。
    const adminHat = await hatsClient.getLinkedTreeAdmin(domain);
    console.log("adminHat:", adminHat);
    // 指定されたツリーが含まれるグローバルツリーのトッパーハットのツリードメインを取得する。
    const tippyTopHatDomain = await hatsClient.getTippyTopHatDomain(domain);
    console.log("tippyTopHatDomain:", tippyTopHatDomain);
    // 帽子の管理者IDを取得する。
    const adminId = await hatsClient.getAdmin(BigInt(hatId));
    console.log("adminId:", adminId);
    // 指定したHatIdに紐づく子供の帽子を取得する。
    const children = await hatsClient.getChildrenHats(BigInt(hatId));
    console.log("childrens:", children);
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
```

`HatsClient`インスタンスを生成するために`chainID`や`publicClient`、オプションで`WalletClient`が必要になるのでそれらのインスタンスを`viem` のメソッドを利用して用意しています。

そしてあとはインスタンスを生成させメソッドを呼び出しているだけの比較的シンプルな実装になっています！！

次に SubgraghのSDKの機能を試すサンプルスクリプトを実行してみたいと思います！！

```bash
yarn sample subgraph
```

以下のような結果が返ってくるのではないでしょうか？

```bash
hat: {
  id: '0x0000000100020001000100000000000000000000000000000000000000000000',
  maxSupply: '1000',
  wearers: [
    { id: '0x0040daac32d83c78546ae36da42a496b28ab09e1' },
    { id: '0x0109c7e6604b96af83ca272bcf84645ed29e7154' },
    { id: '0x011e0be1128af8c51646181368589ccfbddf746a' },
    { id: '0x017ff2643e1a6d500a54e2c15f8186c87795cbbe' },
    { id: '0x018e494352a3e68e16d03ed976fd64134bd82e72' },
    { id: '0x020f64f264ab7e90ef24a108c379a796a82175df' },
    { id: '0x03b79c0c1487a68aeabd9aa4ce779dad77855f52' },
    { id: '0x03f33bb5e7ca4fee122b1b443cebf2ed265c434a' },
    { id: '0x03f7a3fd58b090abe577651fb92fb4789826191e' },
    { id: '0x04ce3ca877bdbb2faffa63f9eee55d7d639a1700' },
    { id: '0x051ac9d0442d5c689e6a301bebc82821f42fc93a' },
    { id: '0x05a1ff0a32bc24265bcb39499d0c5d9a6cb2011c' },
    { id: '0x063560d831876c9bcebdb1ac48d81815e45a0ab9' },
    { id: '0x071e1682748679cdef2fe3e1fcfb23b8b9d13a03' },
    { id: '0x0731f454cb8682d0176ff28e413b0eba42cc82b0' },
    { id: '0x07f6c379bf06113f7f445317de2238d03911b9e6' },
    { id: '0x088e6beb2bb157940c44440578cf07072eba1cd8' },
    { id: '0x0a453f46f8ae9a99b2b901a26b53e92be6c3c43e' },
    { id: '0x0b06ca5dcc8a10be0951d4e140d4312702b8d0ec' },
    { id: '0x0b5f5a722ac5e8ecedf4da39a656fe5f1e76b34c' },
    { id: '0x0c887420937d8f9305ff872eaa5aaf5e379a811a' },
    { id: '0x0d89421d6eec0a4385f95f410732186a2ab45077' },
    { id: '0x0e11de3e815491b1383d2b9c4f99095c20b5bd90' },
    { id: '0x0ea26051f7657d59418da186137141cea90d0652' },
    { id: '0x0f07d407ac41d6dbb2cf237b0704c0ab5b9b8754' },
    { id: '0x0f1d41cc51e97dc9d0cad80dc681777eed3675e3' },
    { id: '0x0f3332af122adab1b5897b21a72315eb06ebdb31' },
    { id: '0x108c1f6802c6d991fcec033294787c08d718f445' },
    { id: '0x1233d45017d270d7ecc07494cb86d3e8dda643a0' },
    { id: '0x1235ce8f885ccca020740c1fc83b221e693bb5ff' },
    { id: '0x1253594843798ff0fcd7fa221b820c2d3ca58fd5' },
    { id: '0x1296b0a992abc44675ff6800dd86696dc9366490' },
    { id: '0x12c5b6d18536abc4766af3c2612b87eb75ec10d5' },
    { id: '0x13c877de8a85255454620ffc002cfa9ca12dcfc2' },
    { id: '0x140b4cbd81d7ceb0adfc96e5c2d640ae39ddfa22' },
    { id: '0x1421d52714b01298e2e9aa969e14c9317b3e1cfa' },
    { id: '0x143ba1aebe867c46fd48347f8da0ecdca046a40f' },
    { id: '0x177d688b3e49e3a1039e3de50d392e48cb6ca869' },
    { id: '0x178f420637c6667ba467041dd62d93e39ea1f232' },
    { id: '0x17e33637f6b64e9082ea499481b6e6ebae7eea23' },
    { id: '0x19ba17c6969b82642bceccfdfb48df9ea844e18c' },
    { id: '0x1a9cee6e1d21c3c09fb83a980ea54299f01920cd' },
    { id: '0x1aa5b637f5283a9fe53771762fc8f6f0f2d87b79' },
    { id: '0x1ad37c45ebbd03caf2551c22541d7d5e4d8aadab' },
    { id: '0x1b0132aa8db835738ee33f83d67d5a14c532b65d' },
    { id: '0x1b2c142ae4b9c72d2b8957079563d171b7f72892' },
    { id: '0x1b784725944ee55eb74f41e29d1262a0dd4d9135' },
    { id: '0x1c51517d8277c9ad6d701fb5394cec0c18219edb' },
    { id: '0x1c9f765c579f94f6502acd9fc356171d85a1f8d0' },
    { id: '0x1d3bf13f8f7a83390d03db5e23a950778e1d1309' },
    { id: '0x1da44dc5bd3ccad7c9de272a58b5507f5bc251fa' },
    { id: '0x1df428833f2c9fb1ef098754e5d710432450d706' },
    { id: '0x1e7f92540941f9539be4dbd2d7652ddce7a05a71' },
    { id: '0x1e8f9d26cf0808168e02450508991fd9c594426d' },
    { id: '0x1fde40a4046eda0ca0539dd6c77abf8933b94260' },
    { id: '0x1feadfd0e023318da5a0024e28b3a87ca5e5886d' },
    { id: '0x223da87421786dd8960bf2350e6c499bebca64d1' },
    { id: '0x224aba5d489675a7bd3ce07786fada466b46fa0f' },
    { id: '0x23db246031fd6f4e81b0814e9c1dc0901a18da2d' },
    { id: '0x2487fc7e019860afbfc7fb16689e421843c777e2' },
    { id: '0x24f193262c575a66d729334f57bdf82d8aff74cb' },
    { id: '0x25910143c255828f623786f46fe9a8941b7983bb' },
    { id: '0x26165f32607d3f8bee6cd5f0c58e94df77291af3' },
    { id: '0x26250d5b0265a9df5f59b9086cab1095254d38b1' },
    { id: '0x266e7f99787676a24a42c15bfbd7b1b734e99c4d' },
    { id: '0x26e3a9c84fdb9b7fe33dfd5e8d273d016e4e4fb6' },
    { id: '0x270de0ae1bef06d1de5cdbdcf411357f5784ed2e' },
    { id: '0x2758b8b35d2df81f764a909efc3b6aca547d7147' },
    { id: '0x27773b203954fbbb3e98dfa1a85a99e1c2f40f56' },
    { id: '0x289bded2521b51167da31752a5b121a52aa1e4b5' },
    { id: '0x29185eb8cfd22aa719529217bfbade61677e0ad2' },
    { id: '0x29864e4d1588c4164dee7cc495147ec141f9c9d5' },
    { id: '0x2a045211d7d1167d6f5f5812959fa9613f58df8a' },
    { id: '0x2abec368577257cee4b1197337b5491d4d9ed578' },
    { id: '0x2c2e67a4c5ea3335408406503844d4879c84a9f6' },
    { id: '0x2c2ebecd11077849d244263e6a5bcdf702a2664d' },
    { id: '0x2c64f2ccc998613a69b667623f65aeb75e157a24' },
    { id: '0x2cbd785ae43f796e29d4f15c5f16502de6292361' },
    { id: '0x2cc5fbc2d537e5bcd24c9782486a3014e029b1fb' },
    { id: '0x2d4ac9c27fffcd87d7fa2619f537c7eb0db96fb7' },
    { id: '0x2da2b7a81f6105a7e82816f1eb058fb5225e6e51' },
    { id: '0x2e29c9750a203eed22c037061f5fd801f6e1429f' },
    { id: '0x2e57674ea14fa08a6dda865dd139ce3924ab5951' },
    { id: '0x2fb523a295a3b194ee24dc358ba98865e61af6de' },
    { id: '0x3057a4c65d58a632dc76cff4bbe1fd97960b7053' },
    { id: '0x30a07def8043614ebb1f9d239841bb8292ffa2f9' },
    { id: '0x30cf7cb2fe80d394086dab29e1b569e0ddf0a8c0' },
    { id: '0x3219f726edfe8cdc2844bbd08025a33339b8084b' },
    { id: '0x32285e4de7ec54df85572851a2dd1bf191f2651e' },
    { id: '0x327c780114d157bee5780d56d62cfee6d8dc603e' },
    { id: '0x330a1b029a0c41b749b43274c992d535d714bf2c' },
    { id: '0x33785892bb8d9926b8e11dca233bdfce3e331aca' },
    { id: '0x34b7103905aad8a763bf8818cda22e5e9af72624' },
    { id: '0x3659c2cfb2d95cbbcbbcd45f2a41e6d7325f6436' },
    { id: '0x3803e8b525ae9fa18977f964f483598090d5084c' },
    { id: '0x38958f8b2ae828eca1e2a30c8e931d224cada075' },
    { id: '0x39b8edbc6d6bab985bf03b498166db588c00278e' },
    { id: '0x3b48e557d2145fa6df280d2b52f66aa46a3635a3' },
    { id: '0x3b60e31cfc48a9074cd5bebb26c9eaa77650a43f' },
    { id: '0x3c41f941098681bfdb14ed423709cc7c29c1e5e6' }
  ],
  events: [
    {
      id: 'HatMinted-123816594-0',
      transactionID: '0x2e55ee62c212a98eca82bcd75cdddadef8e476eda81402f06a5b93b8755a38a6',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123813523-24',
      transactionID: '0xc3226c1c39531684b1ef6e7cd83a0031720cc7c6e4627f0f4b897dd175435938',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123811781-26',
      transactionID: '0xad9c4c0893fc5606b83786f4994c4a5300564959d8e3511c842ee37837ac87b7',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123802820-5',
      transactionID: '0xc25e4060ab07dd5d6369fabe102675e598730d988536d2c151fef9eed54ebef6',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123800034-73',
      transactionID: '0xcadc2ef1ca95d9e696ff0d6904bd62a9cd4bf7a7e4403097343220cd0b0b4dda',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123755840-19',
      transactionID: '0x5bfa04d7f973140a5f6a9738897b4dfddf676541dd7ff7d6dc55d25562709617',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123734644-66',
      transactionID: '0xf0cb23ad32cb5f713ead9a8144c86c32f816e3a1b52a01fe1a07238fb909053f',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123733570-8',
      transactionID: '0xbbf3565f4700e068825a4dfa4e9a22a3e00be2eca4a3fc57a393bddcb5174442',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123701721-0',
      transactionID: '0xe835a75c74374eb89e47717503521c2934f9924ed62aff8c93a749c5c89a0f03',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123691901-49',
      transactionID: '0xcd8e0dd7964f0e4ed5154925970f628e8b261ec5e6975d4c0fd10964fe54f56f',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    }
  ]
}
hatsByIds: [
  {
    id: '0x0000000100020001000000000000000000000000000000000000000000000000',
    wearers: [ [Object], [Object] ]
  },
  {
    id: '0x0000000100020001000100000000000000000000000000000000000000000000',
    wearers: [
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
]
Done in 3.05s.
```

コードは以下の通りです！！

Subgraph用のインスタンスを生成し、取得したい情報を定義してメソッドを実行するだけです！

```ts
import {HatsSubgraphClient} from "@hatsprotocol/sdk-v1-subgraph";
import {optimism, sepolia} from "viem/chains";

// Subgraph用のインスタンスを生成
const hatsSubgraphClient = new HatsSubgraphClient({
  config: {
    [sepolia.id]: {
      endpoint:
        "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest",
    },
    [optimism.id]: {
      endpoint:
        "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest",
    },
  },
});

/**
 * メインスクリプト
 */
const main = async () => {
  // hatの情報を取得する。
  const hat = await hatsSubgraphClient.getHat({
    chainId: 10, // optimism
    hatId: BigInt(
      "0x0000000100020001000100000000000000000000000000000000000000000000"
    ),
    props: {
      maxSupply: true, // get the maximum amount of wearers for the hat
      wearers: {
        // get the hat's wearers
        props: {}, // for each wearer, include only its ID (address)
      },
      events: {
        // get the hat's events
        props: {
          transactionID: true, // for each event, include the transaction ID
        },
        filters: {
          first: 10, // fetch only the latest 10 events
        },
      },
    },
  });

  console.log("hat:", hat);

  // サンプル用のクエリを実行する
  const res = await hatsSubgraphClient.getHatsByIds({
    chainId: 10, // optimism
    hatIds: [
      BigInt(
        "0x0000000100020001000100000000000000000000000000000000000000000000"
      ),
      BigInt(
        "0x0000000100020001000000000000000000000000000000000000000000000000"
      ),
    ],
    props: {
      wearers: {
        // get each hat's wearers
        props: {
          currentHats: {
            // for each wearer, get its hats
            props: {}, // for each hat, include only its ID
          },
        },
      },
    },
  });

  console.log("hatsByIds:", res);
};

main();
```

次にTopHatをミントするスクリプトを実行してみます！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/mintTopHat.ts

```bash
yarn sample mintTopHat
```

すると以下のような結果が返ってきたのではないでしょうか？

```bash
mintTopHatResult: {
  status: 'success',
  transactionHash: '0xadcb165c2a65f6a0b348a0387c4cc5426cf59607585ce32e486454efaf5b977a',
  hatId: 12078056106883486628010822758984794541789440701298176471534417391648768n
}
```

https://sepolia.etherscan.io/tx/0xadcb165c2a65f6a0b348a0387c4cc5426cf59607585ce32e486454efaf5b977a

次にHatを作るスクリプトを実装してみようと思います！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/createHat.ts

```bash
yarn sample createHat
```

```bash
createHatResult: {
  status: 'success',
  transactionHash: '0x2d0a7c492a0ba9a49ab6fda97bfb329a6a22dff6c27f65670ab97fe229b03898',
  hatId: 12078056518259625958312333297727090181127066946982142879929383228801024n
}
```

https://sepolia.etherscan.io/tx/0x2d0a7c492a0ba9a49ab6fda97bfb329a6a22dff6c27f65670ab97fe229b03898

まとめてHatを作るスクリプトも試してみます！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/batchCreateHats.ts

```bash
yarn sample batchCreateHats
```

```bash
batchCreateHatsResult: {
  status: 'success',
  transactionHash: '0xaa70d7e8bf6e7eaf2ee586297a93892942b6db0385a90f11f117de9826fd6654',
  hatIds: [
    12078056929635765288613843836469385820464693192666109288324349065953280n
  ]
}
```

https://sepolia.etherscan.io/tx/0xaa70d7e8bf6e7eaf2ee586297a93892942b6db0385a90f11f117de9826fd6654


次に作ったHatをミントするスクリプトを実行してみます！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/mintHat.ts

```bash
yarn sample mintHat
```

```bash
mintTopHatResult: {
  status: 'success',
  transactionHash: '0x734483b0ebba7e8ad3a75c263a1e0742e61215fb33afae2feb06356fce30987c'
}
```

https://sepolia.etherscan.io/tx/0x734483b0ebba7e8ad3a75c263a1e0742e61215fb33afae2feb06356fce30987c


次にこのはHatを別の人にtransferしてみたいと思います！！

ソースコードは以下の通りです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/transferHats.ts

```bash
yarn sample transferHat
```

すると....

ちゃんと移転できました！！

```bash
transferHatResult: {
  status: 'success',
  transactionHash: '0xaa5366f06f93f5003e36ea612dd80c0608d5b2178f43f327cba7526416f4538f'
}
Done in 13.16s.
```

https://sepolia.etherscan.io/tx/0xaa5366f06f93f5003e36ea612dd80c0608d5b2178f43f327cba7526416f4538f


## hats-module-templateを試してみた！

以下のように HatsModuleを開発するためのテンプレートが公開されています。

今回はこれを試してみました！！

https://github.com/Hats-Protocol/hats-module-template

使用しているフレームワークは、 **foundry** です。

試したソースコードは以下に格納しています。

https://github.com/mashharuki/HatsProtocolSample

READMEにあるように環境変数を設定したら早速動かしてみましょう。

- ### HatsModules コントラクトのセットアップ

  ```bash
  yarn sample-hats-module setUp
  ```

  `forge install` が実行される。

- ### HatsModules コントラクトのフォーマットチェック

  ```bash
  yarn sample-hats-module fmt
  ```

- ### HatsModules コントラクトのビルド

  ```bash
  yarn sample-hats-module build
  ```

  デフォルトで用意されているコントラクトは次の通り。  
  HatModuleコントラクトを継承しているだけの非常にシンプルなコントラクトです。

  ```solidity
  // SPDX-License-Identifier: UNLICENSED
  pragma solidity ^0.8.19;

  // import { console2 } from "forge-std/Test.sol"; // remove before deploy
  import { HatsModule } from "hats-module/HatsModule.sol";

  /**
  * HatsModuleを継承したModuleコントラクト
  */
  contract Module is HatsModule {
    /*//////////////////////////////////////////////////////////////
                              CUSTOM ERRORS
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                                EVENTS
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                              DATA MODELS
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                              CONSTANTS 
    //////////////////////////////////////////////////////////////*/

    /**
    * This contract is a clone with immutable args, which means that it is deployed with a set of
    * immutable storage variables (ie constants). Accessing these constants is cheaper than accessing
    * regular storage variables (such as those set on initialization of a typical EIP-1167 clone),
    * but requires a slightly different approach since they are read from calldata instead of storage.
    *
    * Below is a table of constants and their location.
    *
    * For more, see here: https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args
    *
    * ----------------------------------------------------------------------+
    * CLONE IMMUTABLE "STORAGE"                                             |
    * ----------------------------------------------------------------------|
    * Offset  | Constant          | Type    | Length  | Source              |
    * ----------------------------------------------------------------------|
    * 0       | IMPLEMENTATION    | address | 20      | HatsModule          |
    * 20      | HATS              | address | 20      | HatsModule          |
    * 40      | hatId             | uint256 | 32      | HatsModule          |
    * 72+     | {other constants} | address | -       | {this}              |
    * ----------------------------------------------------------------------+
    */

    /*//////////////////////////////////////////////////////////////
                              MUTABLE STATE
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Deploy the implementation contract and set its version
    /// @dev This is only used to deploy the implementation contract, and should not be used to deploy clones
    constructor(string memory _version) HatsModule(_version) { }

    /*//////////////////////////////////////////////////////////////
                              INITIALIZOR
    //////////////////////////////////////////////////////////////*/

    function _setUp(bytes calldata _initData) internal override {
      // decode init data
    }

    /*//////////////////////////////////////////////////////////////
                          PUBLIC FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                            VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                          INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /*//////////////////////////////////////////////////////////////
                              MODIFERS
    //////////////////////////////////////////////////////////////*/
  }
  ```

- ### HatsModules コントラクトのテスト

  ```bash
  yarn sample-hats-module test
  ```

  実行するテストコードは次の通り

  ```solidity
  // SPDX-License-Identifier: UNLICENSED
  pragma solidity ^0.8.19;

  import { Test, console2 } from "forge-std/Test.sol";
  import { Module } from "../src/Module.sol";
  import { Deploy, DeployPrecompiled } from "../script/Deploy.s.sol";
  import {
    HatsModuleFactory, IHats, deployModuleInstance, deployModuleFactory
  } from "hats-module/utils/DeployFunctions.sol";
  import { IHats } from "hats-protocol/Interfaces/IHats.sol";

  /**
  * テストスクリプト
  */
  contract ModuleTest is Deploy, Test {
    /// @dev Inherit from DeployPrecompiled instead of Deploy if working with pre-compiled contracts

    /// @dev variables inhereted from Deploy script
    // Module public implementation;
    // bytes32 public SALT;

    uint256 public fork;
    uint256 public BLOCK_NUMBER = 17_671_864; // deployment block for Hats.sol
    IHats public HATS = IHats(0x3bc1A0Ad72417f2d411118085256fC53CBdDd137); // v1.hatsprotocol.eth
    HatsModuleFactory public factory;
    Module public instance;
    bytes public otherImmutableArgs;
    bytes public initArgs;
    uint256 public hatId;
    uint256 saltNonce;

    string public MODULE_VERSION;

    function setUp() public virtual {
      // create and activate a fork, at BLOCK_NUMBER
      fork = vm.createSelectFork(vm.rpcUrl("mainnet"), BLOCK_NUMBER);

      // deploy implementation via the script
      prepare(false, MODULE_VERSION);
      // run メソッド
      run();

      // deploy the hats module factory
      factory = deployModuleFactory(HATS, SALT, "test factory");
    }
  }

  contract WithInstanceTest is ModuleTest {
    function setUp() public virtual override {
      super.setUp();

      // set up the hats

      // set up the other immutable args
      otherImmutableArgs = abi.encodePacked();

      // set up the init args
      initArgs = abi.encode();

      // set up the salt nonce
      saltNonce = 1;

      // deploy an instance of the module
      instance =
        Module(deployModuleInstance(factory, address(implementation), hatId, otherImmutableArgs, initArgs, saltNonce));
    }
  }

  contract Deployment is WithInstanceTest {
    /// @dev ensure that both the implementation and instance are properly initialized
    function test_initialization() public {
      // implementation
      vm.expectRevert("Initializable: contract is already initialized");
      implementation.setUp("setUp attempt");
      // instance
      vm.expectRevert("Initializable: contract is already initialized");
      instance.setUp("setUp attempt");
    }

    function test_version() public {
      assertEq(instance.version(), MODULE_VERSION);
    }

    function test_implementation() public {
      assertEq(address(instance.IMPLEMENTATION()), address(implementation));
    }

    function test_hats() public {
      assertEq(address(instance.HATS()), address(HATS));
    }

    function test_hatId() public {
      assertEq(instance.hatId(), hatId);
    }

    // test other initial values
  }

  contract UnitTests is WithInstanceTest { }
  ```

  ```bash
  Ran 5 tests for test/Module.t.sol:Deployment
  [PASS] test_hatId() (gas: 13088)
  [PASS] test_hats() (gas: 13212)
  [PASS] test_implementation() (gas: 13205)
  [PASS] test_initialization() (gas: 19603)
  [PASS] test_version() (gas: 18366)
  Suite result: ok. 5 passed; 0 failed; 0 skipped; finished in 2.05s (1.08ms CPU time)

  Ran 1 test suite in 2.05s (2.05s CPU time): 5 tests passed, 0 failed, 0 skipped (5 total tests)
  Done in 3.02s.
  ```

- ### HatsModules コントラクトをデプロイする

  ```bash
  
  ```

  ```bash
  
  ```


### 参考文献
1. [HatsProtocol 公式サイト](https://www.hatsprotocol.xyz/)
2. [HatsProtocol - Docs](https://docs.hatsprotocol.xyz/)
3. [HatsProtocol - App](https://app.hatsprotocol.xyz/)
4. [GitHub - HatsProtocol](https://github.com/Hats-Protocol)
5. [GitHub - HatsProtocol/create-hats-app](https://github.com/Hats-Protocol/create-hats-app)
6. [HatsProtocol - Blog](https://blog.hatsprotocol.xyz/)
7. [GitHub - HatsProtocol/v1-subgraphs](https://docs.hatsprotocol.xyz/for-developers/v1-subgraphs)
8. [GitHub - HatsProtocol/hats-module-template](https://github.com/Hats-Protocol/hats-module-template)
9. [GitHub - HatsProtocol/Hats Modules Registry](https://github.com/Hats-Protocol/modules-registry)