---
title: "Hats Protocolを理解する！！"
emoji: "🐈"
type: "tech"
topics: ["TypeScript", "Solidity", "Blockchain", "Web3", "HatsProtocol"]
published: true
---

![](/images/4fc8bb038497aa/0.png)

**※随時更新していきます！※**

## はじめに

みなさん、 **Hats Protocol** というプロトコルを聞いたことがありますか？？

https://www.hatsprotocol.xyz/

**Hats Protocol**について調べる機会があったのでその結果をブログ記事にまとめました！！

## Hats Protocolとは何か？

まずは、 **Hats Protocol** がどういうプロトコルなのか解説します！

https://docs.hatsprotocol.xyz/

**Hats Protocol**とは、組織の役割(ロール)や権限をプログラム可能なデジタルグラフに変換し、オンチェーンで管理できるようにするためのプロトコルです！！

特徴は次の点ですね！

:::message
1. **役割の構成**: 
    役割（Hats）はERC-1155標準に準拠したトークンとして表現され、責任、権限、インセンティブを含む「帽子」として組織グラフのノードとなります。

2. **グラフ構造**: 
    役割間の管理や責任関係がグラフの接続として表され、組織の構造を柔軟に構築・可視化できます。

3. **権限の管理**: 
    役割に委譲された権限により、資金管理や意思決定、データアクセスなどの組織運営が効率化されます。

4. **プログラム可能な役割**: 
    Hatsはプログラム可能で、組織の指定する基準やロジックに従って役割や権限の付与・取り消しが自動化可能です。

5. **広範な統合と利用**: 
    Hatsは多様なアドレスやアカウントで使用でき、組織やスマートコントラクトにより柔軟に管理・利用されます。
:::

**AWS**の**IAMロール**の考え方に近いかもしれませんね。

サポートしているチェーン一覧は下記から確認できます。

https://docs.hatsprotocol.xyz/using-hats/hats-protocol-supported-chains

テストネットでは Sepolia と Holeskyが対応してそうです。

- **Sepoliaにデプロイされたコントラクト**

https://sepolia.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137

- **Holeskyにデプロイされたコントラクト**

https://holesky.etherscan.io/address/0x3bc1A0Ad72417f2d411118085256fC53CBdDd137

## クイックスタート

まずは、下記手順に従ってサンプル組織ツリーを作ってみます！！

https://docs.hatsprotocol.xyz/using-hats/creating-my-first-hat

#### 1. 新しいツリーを作成する

まず、以下のページにアクセスします！！

https://app.hatsprotocol.xyz/

![](/images/4fc8bb038497aa/1.png)

ロゴやTop of Hatsの名前を入力する必要があるみたいです！！

諸々必要なデータ入力します！

![](/images/4fc8bb038497aa/2.png)

今回はこんなロゴを用意しました！！

![](/images/4fc8bb038497aa/3.png)

![](/images/4fc8bb038497aa/4.png)

全部入力したら **Create**ボタンを押します！！

これで HatがNFTとしてミントされます！！

実際のトランザクションは以下から確認できます！！

https://sepolia.etherscan.io/tx/0x5917ad6d7719aa3ea87c246cda0277505b366db3b32f9425e88bae5f3d161cf1

しばらく待つと以下のような画面に遷移します！！

![](/images/4fc8bb038497aa/5.png)

これでツリーができました！！

#### 2. 最初の子Hatを作成する

続いて子Hatを作成します！！

先ほどの画面の左上の **Edit Tree** をクリックします！！

子Hatも細かく設定できるみたいですね！！

![](/images/4fc8bb038497aa/6.png)

名前や画像なども決められるみたいです！

![](/images/4fc8bb038497aa/7.png)

その他、帽子を被れるアカウント数の上限値設定、アドレスの一括登録などが可能なんですね。

![](/images/4fc8bb038497aa/8.png)

他にも細かく権限周りを設定することができるみたいです！！

![](/images/4fc8bb038497aa/9.png)

これで子Hatが作成できました！！

クイックスタートはここまでです！！

## Hats Protocolの機能を細かく確認していこう！！

### Adminにできること

**Hats Protocol**では **Admin** は特別な権限を持ちます。

子Hatの詳細や画像、最大供給量、適格アドレス、トグルアドレスを変更できます（ただし、変更可能な状態のHatに限る）。管理者Hatは、新しい着用者に対して、変更可能なHatや変更不可能なHatを発行でき、変更可能なHatを別のアドレスに移転することも可能みたいです。

各Hatは、その下に直接リンクされたすべてのHatの管理者として機能します。

そして Hatは、EOAのみならずマルチシグなどのコントラクトウォレットやスマートアカウントウォレットにも着用が可能とのことです！

これは面白いですね！！！

これなら柔軟に権限の管理ができそうです！！

### 他のプロトコルとの連携

以下のページで紹介されている通り、様々なプロトコル・アプリと連携が可能とのことです！！！

https://docs.hatsprotocol.xyz/using-hats/connecting-hats-w-permissions-and-authorities

SafeやSuperfuildなどのブロックチェーン側のプロトコルだけでなく、テレグラムやDiscord、Google Docsとも連携できるみたいですね。

HatsProtocolの機能を使って以下のようなユースケースをさらに強力にできるみたいですね！

- **アカウントとリソース**: 
  Ethereumアカウントの管理、マルチシグの署名権限、報酬管理
- **コミュニケーションチャンネル**: 
  共有コミュニケーションチャンネルやアカウントへのアクセス権や投稿権限
- **ガバナンスと投票**: 
  スマートコントラクトへのオンチェーン権限、提案作成、投票権
- **ワークスペース**: 
  ワークスペース、ファイル、ドキュメントでの読み取り、レビュー、書き込み権限

### トークンゲート機能との連携

Hatで管理できる権限には2種類の権限があります。

- **ハードパワー**:
  トークンゲートを通じて提供されるオンチェーンやオフチェーンの明確な権限

- **ソフトパワー**:
  会議の進行や特定のドメインでのプロジェクト作業、トークンゲートで管理できないアプリの管理権限

これらの権限をHatとしてブロックチェーン上で作った後にトークンゲートを通じてHatに結びつけることもできるみたいです。

- **トークンゲーティングプラットフォーム**: 
  Guild、Collab.Land、Lit Protocolなどがトークンゲーティングを提供し、以下のアプリで使用できます：

  - Guild: 
    Coordinape、
    Discord、
    Github（プライベートリポジトリのみ）、
    Google Workspace（Docs、Sheets、Slides）、
    Party.Space、
    POAP、
    Rally、
    Telegram、
    Wonderverse
  - Collab.Land: 
    Discord、
    Telegram
  - Lit Protocol: 
    Gather Town、
    Google Drive、
    Headline、
    IPFS、
    Nowhere、
    Orbis 
    Club、
    Shopify、
    WalletChat、
    Wordpress、
    Zoom

- **トークンゲーティングを統合したアプリ**: 
  Charmverse、Wonderverse、Commonwealth（近日対応予定）など、特定のチャンネルへのアクセスや読み書き権限を提供

- **ERC1155を読み込んでパラメータを変更するツール**: 
  Snapshot Strategiesを使用し、特定のHatのみがSnapshot提案で投票できるようにしたり、特定のHatに投票権の重みを与えたりする

- **HatsSignerGate**: 
  Safe multisig署名権限を特定のHatに提供するZodiacモジュール

- **ソーシャルアグリーメントや他のアカウンタビリティメカニズム**: 
  季節ごとの選挙、ステーキング要件、評判システムなど。トークンゲーティングを通じて明確に権限を付与できない場合でも、そのHatがその権限を持つことを示すためにHatを使うことができます。

  以下のサイトからそれぞれのアプリとどのように統合すれば良いのかまとめられています！！

https://docs.hatsprotocol.xyz/hats-integrations/permissions-and-authorities#guides-for-connecting-authorities-to-hats

### 承認と適格性: Hatの保持者に必要な条件について

Hatを通じてアクセスできる権限は、個人またはグループの管理者によって付与および取り消しが可能です。また、Hatsモジュールを使用することで、幅広い自動化された適格性やアカウンタビリティの基準に基づいて管理することもできるみたいです。

- **Hatsモジュール**

  Hatsモジュール は、役割のためのプログラム可能な拡張機能です。
  
  モジュールをHatに接続することで、特定の条件に基づいてHat（および関連する権限）の自動付与および取り消しが可能になります。

- **Hatの適格性モジュール**

  Hatの適格性モジュールは、どのアドレスがそのHatを着用できるかを決定するアドレスです。
  
  また、着用者がもはや適格でない場合には、そのHatを取り消すことができます。
  
  適格性モジュールは、手動で適用することもコントラクトウォレットによる自動トリガーで実行することできるみたいです。

- **適格性の基準について**

  権限の付与の基準については結構いろんなルールを決められるみたいですね。

  - **トークン、NFT、アテステーション**：
    ERC20トークンの残高、ERC721 NFTs、ERC1155 NFTのトークンID、EASアテステーションなど
  - **選挙と許可リスト**：
    JokeRace、Snapshot、Tallyからの選挙結果、自動任期制限、手動で作成された許可リスト
  - **成果と評判**：
    バッジ、オンチェーンポイント、Colinks、Gitcoinパスポートスコアなど
  - **前提条件のアクション**：
    ステーキング、契約の署名、他の役割の保持、サブスクライバーであることなど
  - **その他**：
    複数の基準をAND/ORロジックで組み合わせたり、AIエージェントを導入したり、細かなオンチェーンまたはオフチェーンのトリガーを作成したりすることができます。

  ルールについては開発者が柔軟に決められるみたいですね。
  また、Hatsモジュールを利用することもありみたいですね。

  もちろん、Appからも設定ができます。
  
  **クイックスタート**の部分で子Hatを作った時に **Revocation & Eligibility**というセクションが出てきたと思いますがそこで設定できるみたいです!!

  利用可能な適格性モジュールはいくつか種類があるみたいで以下のページでリスト化されています！！

https://docs.hatsprotocol.xyz/hats-integrations/eligibility-and-accountability-criteria

## 技術的に Hats Protocolを細かく確認していこう！！

冒頭にも説明しましたが、Hatsは **譲渡不可能なERC1155ライクなトークン**として発行されます！！

Hats Protocolの主要なロジックは、**Hatsの作成、発行、取消、管理**となっています。

特定のHatの動作を拡張し、カスタマイズすることも可能みたいです！！

具体的にどんな仕様・機能が提供されているか確認していきます！

### Hat Properties

Hatsが持つプロパティを確認していきます！！

ERC1155がベースになっているのでERC1155のNFTに似てますね。

:::message
- **id**
  Hatの整数識別子であり、ERC1155に似たトークンIDとしても機能します。
- **details**
  Hatに関する任意のメタデータ。
  名前や説明、Hatに関連する役割や責任などが含まれます。
  7,000文字を超えないようにしてください。
- **maxSupply**
  一度にそのHatを身につけることができるアドレスの最大数。
- **admin**
  Hatを発行し、そのほかのプロパティを管理できるHat。
- **eligibility**
  Hatを身につけることができる条件を管理し、その条件を満たしているかどうかを確認するアドレス。
- **toggle**
  Hatが有効かどうかを管理するアドレス。
- **mutable**
  Hatのプロパティがadminによって変更可能かどうか。
- **imageURI**
  HatのERC1155に似たトークンに使用される画像のURI。
  7,000文字を超えないようにしてください。
:::

### Wearing a Hat

Hatを着用できるかの条件は3つ

:::message
1. そのアカウントのアドレスに帽子のトークンの残高があるかどうか

2. 帽子がアクティブであるかどうか

3. そのアカウントが対象となるかどうか
:::

Hats Protocolには、`isWearerOfHat()`という便利な関数があり、これは`balanceOf()`をラップして、残高が1であるかどうかをブール値で返すみたいです。

### Hat Admins & Hatter Contracts

各帽子の管理者は別の帽子です。つまり、特定の帽子の管理機能を実行する権限は、その管理帽子を着用している人に割り当てられます。

管理帽子を着用しているアカウントは誰が帽子を着用できるか決定することが可能です。

そして管理権限は伝播します。ある帽子のすべての祖先（直接の管理者、その管理者の管理者、など）は、その帽子の管理者として機能できます。

- **帽子に対するコントロール**

  |役割|権限|
  |:---|:---|
  |管理者	|新しい帽子を作成する|
  ||着用者に帽子を発行する|
  ||帽子のプロパティを編集する（変更可能な場合）|
  ||帽子を移転する（変更可能な場合）|
  |対象条件モジュール	|対象外のアドレスが帽子を着用するのを防ぐ|
  ||特定の着用者から帽子を剥奪する|
  |トグルモジュール	|帽子をアクティブまたは非アクティブにする ⇒ 全ての着用者がその帽子を失う

- **Hatter Contracts**
  
  管理者として機能するロジックコントラクトは、Hatter Contractsと呼ばれます。これらは、特定のロジックやルールを実装するコントラクトです。Hatter Contractsの管理者は真の管理者ですが、その管理権限をハッターに埋め込まれたロジックに委任しています。

  <br/>

  Hatter Contractsのロジックは、DAOにとって広範なデザイン領域です。  

  <br/>

  以下は、Hatterロジックの例です：

  - **帽子の作成**
    特定のアドレス（DAOのメンバーなど）に、DAOが管理する帽子を作成する権限を付与します。

  - **帽子の発行**
    特定のアドレス（DAOのメンバーなど）に、帽子トークンを発行する権限を付与します。  
    上記と組み合わせることで、DAOはメンバーが特定のタイプの帽子を許可なく作成し、着用できるようにすることができます。これは、役割の明確化と理解を促進するために帽子を使用する場合に特に有効です。

- **着用者の対象条件**
  特定の帽子を着用するために、候補者が満たすべき要件を強制します。
  
  <br/>

  例えば、DAOのメンバーであることや、特定のトークンを保持していることなどです。これは、多くの場合、対象条件モジュールとして実装する方が効果的です。

- **着用者のステーキング**
  特に重要な対象条件の一つに、トークンやDAOシェア、その他の資産を担保としてステーキングすることがあります。

  <br/>
  
  これは、着用者が帽子に関連する責任を果たさなかったり、義務を遂行しなかった場合に、担保が削減されるリスクがあることを意味します。これも、多くの場合、対象条件モジュールとして実装する方が効果的です。

### Hats Trees

すべての帽子が別の帽子を管理者として持つという事実は、すべての帽子が「Hats Trees」の中に存在することを意味します。

このツリー構造が、組織の帽子の基盤を形成します。

特定の帽子ツリーの枝の中では、ツリーの根に近い帽子が、その枝の下位にある帽子に対する管理権限を持っています。

これは、DAO（分散型自律組織）の権限委任の方向性と一致しており、ネットワークの端に権限が委任されるにつれて責任が希薄化する傾向に対抗します。

- **トップハット**
  トップハットは、帽子の管理者が必ず別の帽子でなければならないというルールの唯一の例外です。  
  トップハットは自分自身を管理者とする帽子です。

  帽子ツリーの根は常にトップハットです。
  通常、DAOは、その運営に関連する帽子のツリーを管理するトップハットを着用します。

- **帽子ツリーと帽子ID**
  各帽子ツリーは最大で15の深さを持ち、各帽子は最大で2^16 = 65,536の子供を持つことができ、このパターンが14回繰り返されます。

  各帽子のIDには、そのツリーのIDとツリー内での位置が含まれます。

### Hat IDs

Hat IDは、ツリーの中で帽子がどこに位置しているか、管理者の全枝を含む情報を持つ「アドレス」を作成するためのuint256ビットマップです。
これは、Ethereumのアドレスというよりも、WebやIPアドレスに近いものです。

帽子IDの32バイトは以下のように構成されています：

最初の4バイトはトップハットIDに予約されています。

トップハットIDはHats Protocolの特定のデプロイメント全体で一意であるため、これらを帽子ツリーのトップレベル「ドメイン」と考えることができます。

次の各16ビットのチャンクは、1つの「帽子レベル」を指します。

帽子レベルは合計で15レベルあり、レベル0のトップハットから始まり、レベル14まで続きます。

次のようなHat ID（16進数）を考えてみましょう：

**0x0000000f00020005000a00010000000000000000000000000000000000000000**

便宜上、IPアドレスのように短縮形に再フォーマットできます：**15.2.5.10.1**

このIDだけで、この帽子について多くのことがわかります：

:::message
- この帽子はツリー15に属している
- レベル4の帽子である
- 直近の管理者（親）は15.2.5.10
- その上位の管理者（祖父母）は15.2.5
:::

### Eligibility Modules

Eligibility Modules(適格性モジュール)には、特定の帽子の着用者に関して以下の2つの権限があります。

- a) 適格性
- b) 良好な状態にあるかどうか

- **着用者の適格性**
  着用者の適格性 (A) は、特定のアドレスがその帽子を着用する資格があるかどうかを判断します。   
  <br/> 
  これは、そのアドレスが帽子を着用する前および着用中の両方に適用されます。以下のシナリオを考えてみましょう。
  <br/> 

  |適格	|非適格|
  |:---|:---|
  |帽子を着用していない場合|帽子をアドレスに発行できる|
  |現在帽子を着用している場合|帽子を着用し続ける|

- **着用者の状態**
  着用者の状態 (B) は、特定のアドレスが良好な状態にあるか、悪い状態にあるかを判断します。
  <br/> 
  状態は、**Hats.sol**にオンチェーンで保存され、責任を明確にします。
  <br/> 
  例えば、ステーキングロジックを実装しているHatter Contractでは、適格性モジュールによって悪い状態にされた場合、着用者のステークを削減することができます。
  <br/> 
  特定の帽子の適格性モジュールによって悪い状態にされたアドレスは、自動的にその帽子の適格性を失います。ただし、非適格であることが必ずしも悪い状態を意味するわけではなく、あるアドレスが非適格であっても、良好な状態である可能性があります。
  <br/> 
  任意のアドレスが特定の帽子に対する適格性モジュールとして機能することができます。
  <br/> 
  Hats Protocolは、次の2つの種類の適格性モジュールをサポートしています：

  - **機械的適格性**
    `IHatsEligibility`インターフェースを実装するロジックコントラクトであり、**Hats.sol**コントラクトが`Hats.balanceOf`関数内からcheckWearerStandingを呼び出すことで、着用者の状態を即座に確認できます。事前定義されたトリガーに基づいて即時に帽子を取り消すことが可能です。

  - **人間的適格性**
    EOAやガバナンスコントラクト（DAOなど）です。人間的適格性では、帽子を取り消すために、HatsコントラクトにHats.ruleOHatWearerStandingを呼び出して状態を更新する必要があります。

  管理者とは異なり、適格性モジュールは帽子ではなくアドレスとして明示的に設定されます。これは、着用者に対する罰則（ステークの削減など）に影響を与える長くて読みづらい可能性のある取り消し権限の連鎖を避けるためです。

### Toggle Modules

**Toggle Contract**は、帽子の`hat.active`ステータスをアクティブから非アクティブに切り替える権限を持っています。帽子が非アクティブになると、その帽子の着用者は存在しなくなり（つまり、以前の着用者の残高が0に変更されます）。

任意のアドレスが帽子のトグルとして機能することができます。適格性モジュールと同様に、Hats Protocolは2つのカテゴリのToggle Modulesをサポートしています：

- **機械的トグル**
  IHatsToggleインターフェースを実装するロジックコントラクトであり、Hats.balanceOf関数内からcheckToggleを呼び出すことで、帽子のアクティブステータスを即座に確認し、非アクティブ化（または再アクティブ化）を行います。例えば、「この帽子は年末に期限切れになる」といった事前定義されたロジックに基づいて、即座に非アクティブ化することが可能です。

- **人間的トグル**
  EOAやガバナンスコントラクト（DAOなど）です。帽子を非アクティブ化（または再アクティブ化）するためには、人間的トグルがHatsコントラクトにHats.toggleHatStatusを呼び出して状態を更新する必要があります。

管理者とは異なり、適格性モジュールと同様に、トグルモジュールは帽子ではなく、アドレスとして明示的に設定されます。

### Hat Mutability and Editing

場合によっては、帽子の特性が不変であることが、特に着用者にとって、何に同意しているかについて最大限の信頼を提供するために重要です。しかし、この確実性は柔軟性の欠如を意味し、柔軟性はDAOが進化し、様々な役割について学んでいく中で価値を持つことが多いです。このトレードオフを考慮して、Hatsは不変または可変のいずれかで作成することができます。

**不変な帽子**は、一度作成されると一切変更することができません。
<br/>

**可変な帽子**は、作成後に変更することが可能です。変更はその帽子の管理者のみが行えます。

以下の帽子の特性に対する変更が許可されています：

- 詳細
- 最大供給量（新しい最大供給量が現在の供給量を下回らない限り）
- 適格性
- トグル
- 可変性（これは一方向の変更です）
- 画像URI

さらに、可変な帽子は管理者によって異なる着用者に移行することができます。不変な帽子は移行することができません。

- **トップハットの例外**
  上記の不変性ルールの唯一の例外は、トップハットです。不変でありながら、自身の詳細と画像URIを変更することが許可されています（ただし、他の特性は変更できません）。

### Creating Hats

帽子を作成する者は、その帽子の管理者でなければなりません。言い換えれば、帽子の管理者は`Hats.createHat`関数を呼び出す際の`msg.sender`である必要があります。

ただし、管理者が自らの権限を**Hatter Contract**に委任することで、その管理者は、任意のロジックに基づいて他の適格者に帽子を作成させることができます。

トップハット（自分自身が管理者である帽子）を作成するには、特別な関数`mintTophat`が必要です。

この関数は、新しい帽子を作成し、その帽子を自分自身の管理者として設定し、その後、トークンを`_target`にミントします。管理者帽子をまだ持っていないアドレスが帽子を作成したい場合、まず自分自身を着用者としてトップハットを作成する必要があります。

DAOが一度に多くの帽子を作成したい場合、特に全体の帽子ツリーを一度に作成する場合に、バッチ作成が役立ちます。これは、DAOやワーキンググループの初期構造をセットアップする際（例：帽子のテンプレートから）や、既存の帽子構造をテンプレートからフォークする際に特に有用です。

複数の帽子をバッチ作成するために、DAOは`Hats.batchCreateHats()`関数を呼び出すことができます。この関数は配列を引数として受け取り、そこから複数の帽子を構築します。これらの帽子が同じ帽子ツリーの一部である限り（すなわち、既存の帽子または新たに作成された帽子が管理者である場合）、一度にすべての帽子を作成することが可能です。

### Minting Hats

帽子のトークンをミントできるのは、その帽子の管理者だけです。

帽子をミントするには以下の条件を満たす必要があります：

:::message
- 帽子がアクティブであること
- 最大供給量に達していないこと
- 対象の着用者がすでにその帽子を着用していないこと
- 帽子の適格性モジュールが機械的な場合、対象の着用者がその帽子に対して適格であること
- 帽子の管理者はHats.mintHatを呼び出すことで、個別に帽子のトークンをミントすることができます。
:::

- **バッチミント**
  管理者は**Hats.batchMintHats**を呼び出して、複数の帽子を一度にミントすることも可能です。これにより、同じ帽子を複数の着用者にミントしたり、複数の帽子を一度にミントしたり、さらには新しく作成した帽子ツリー全体をミントすることもできます。

### Transfering Hats

HatはERC1155ライクなトークンとして発行されるみたいですが、別のアカウントに移転できるのはその帽子の管理者だけのようです。

これは、帽子に関連する権限と責任が、着用者に委任されているものであり、所有されているものではないためです。

そのため、安全な転送（受信者がERC1155に対応しているかを確認する転送）や、受信者にデータを渡すための`on1155Received`や`onERC1155BatchReceived`フックは不要です。

このため、Hats Protocolでは、標準のERC1155転送機能である`safeTransferFrom`および`safeBatchTransferFrom`は無効化され、常にエラーが返されます。同様に、トークンの承認は必要なく、`setApprovalForAll`も常にエラーが返されます。

- **ERC1155互換性**
  代替として、帽子は管理者によって`Hats.transferHat`を通じて移転され、ERC1155標準イベント`TransferSingle`が発行されます。移転の受信者は既にその帽子を着用しておらず、帽子を着用する資格がある必要があります。

トップハット（常に自分自身を移転できるもの）を除き、移転可能なのは、変更可能かつアクティブな帽子のみです。

### Renouncing Hats

帽子の着用者は、`Hats.renounceHat`を通じて自分の帽子を「脱ぐ」ことができます。

これにより、その帽子のトークンは焼却され、元の着用者から関連する権限と責任が取り消されますが、その着用者が不良な立場に置かれることはありません。

### Batch Actions

バッチ作成やバッチミントに加えて、**Hats.sol**の関数を一連の処理としてまとめて一つのトランザクションで実行することができます。

これは、**Hats.sol**が継承している`Multicallable`によって可能になっています。

この機能は、支払い不要の`multicall`関数をコントラクトに追加します。これにより、EOAはコントラクトに対して複数の呼び出しを一括で行うことができ、これまでスマートコントラクトでしか利用できなかった便利なバッチ処理が可能になります。

### Hat Image URIs

他のNFTと同様に、ハットには画像があります。
特定のハットの画像は、次のロジックに従って決定されます。

:::message
- そのハットのimageURIプロパティが設定されている場合は、それを使用します。
- ハットのimageURIプロパティが設定されていない場合は、管理者ハットのimageURIを使用します。
- 管理者ハットのimageURIプロパティが設定されていない場合は、その管理者のimageURIを使用します。
- 元のハットのハットツリー内（トップハットを含む）で設定されたimageURIが見つからない場合は、Hats Protocolコントラクトで設定されたglobalImageURIを使用します。
:::

### ERC1155 との互換性

Hats Protocolは、**ERC1155インターフェースに完全に準拠しています**。

ERC1155標準で求められるすべての外部関数がHats Protocolによって公開されており、これによりハットは既存のトークンゲートアプリケーションとすぐに連携できます。

ただし、Hats ProtocolはERC1155標準に完全に準拠しているわけではありません。ハットは所有者（つまり「着用者」）によって移転できないため、安全な移転や`ERC1155TokenReceiver`ロジックの必要性はほとんどありません。

Hats Protocolを利用する開発者は、たとえば、ハットのミントや移転において、`onERC1155Received`への呼び出しが含まれないことに注意する必要があります。

## Coreコントラクトを見ていこう！！

ではここからは Hats Protocolのコア機能が実装されているスマートコントラクトを確認していきたいと思います！！

コア機能を提供しているコントラクトは以下の４つです。

:::message
- **Hats.sol**
- **HatsEvents.sol**
- **HatsErrors.sol**
- **HatsUtillities.sol**
:::

そしてインターフェース用のファイルとして以下の4つが存在します！

:::message
- **IHats.sol**
- **IHatsIdUtilities.sol**
- **IHatsEligibility.sol**
- **IHatsToggle.sol**
:::

ここからはそれぞれ見ていこうと思います！！

### **Hats.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Hats.sol)

Hatsは、DAOに特化した取り消し可能かつプログラム可能な役割を表しており、これらは非譲渡のERC-1155に似たトークンとして実装されています。

このHats.solは、指定されたブロックチェーン上で全てのHatsを管理するマルチテナントコントラクトです。

ERC1155インターフェースを完全に実装しているものの、ERC1155標準には完全には準拠していません。

#### ステート変数

- **name**
  コントラクトの名前（通常はバージョンを含む）

  ```solidity
  string public name;
  ```

- **lastTopHatId**

  最後に作成されたトップハットのIDの最初の4バイト

  ```sol
  uint32 public lastTopHatId;
  ```

- **baseImageURI**
  画像URIが指定されていないハットトークンのためのフォールバック画像URI

  ```sol
  string public baseImageURI;
  ```

- **_hats**
  ハットとハットIDの内部マッピング。
  ハットIDの仕組みについては、**HatsIdUtilities.sol**を参照

  ```solidity 
  mapping(uint256 => Hat) internal _hats;
  ```

- **badStandings**
  特定のハットの着用者が不良状態にあることを示すマッピング。  
  外部のコントラクトで、ペナルティを課すために使用される。

  ```solidity
  mapping(uint256 => mapping(address => bool)) public badStandings;
  ```

#### 関数

- **mintTopHat**
  自身が管理者であるハット、つまり「トップハット」を作成し、ミントする関数。トップハットには適格性やトグルがない。

  ```solidity
  function mintTopHat(
    address _target, 
    string calldata _details, 
    string calldata _imageURI
  ) public returns (uint256 topHatId);
  ```

- **createHat**
  新しいハットを作成する関数。
  `msg.sender`は`_admin`ハットを着用している必要がある。新しいHat構造体を初期化するが、トークンはミントされない。

  ```solidity
  function createHat(
      uint256 _admin,
      string calldata _details,
      uint32 _maxSupply,
      address _eligibility,
      address _toggle,
      bool _mutable,
      string calldata _imageURI
  ) public returns (uint256 newHatId);
  ```

- **batchCreateHats**
  複数のハットを一括で作成する関数。
  `msg.sender`はそれぞれのハットの管理者である必要がある。

  ```solidity
  function batchCreateHats(
      uint256[] calldata _admins,
      string[] calldata _details,
      uint32[] calldata _maxSupplies,
      address[] memory _eligibilityModules,
      address[] memory _toggleModules,
      bool[] calldata _mutables,
      string[] calldata _imageURIs
  ) public returns (bool success);
  ```

- **getNextId**
  次の子ハットのIDを取得する関数。lastHatIdはインクリメントされない。

  ```solidity
  function getNextId(uint256 _admin) public view returns (uint256 nextId);
  ```

- **mintHat**
  適格な受領者にハットのERC1155に似たトークンをミントし、受領者がそのハットを「着用」する関数。

  ```solidity
  function mintHat(
    uint256 _hatId, 
    address _wearer
  ) public returns (bool success);
  ```

- **batchMintHats**
  複数のハットを一括でミントする関数。msg.senderはそれぞれのハットの管理者である必要がある。

  ```solidity
  function batchMintHats(
    uint256[] calldata _hatIds, 
    address[] calldata _wearers
  ) public returns (bool success);
  ```

- **setHatStatus**
  ハットの状態をアクティブから非アクティブ、またはその逆に切り替える関数。
  
  `msg.sender`はそのハットのトグルとして設定されている必要がある。

  ```solidity
  function setHatStatus(
    uint256 _hatId, 
    bool _newStatus
  ) external returns (bool toggled);
  ```

- **checkHatStatus**
  ハットのトグルモジュールをチェックし、返された状態を処理する関数。ストレージ内のハットの状態を変更する可能性がある。

  ```solidity
  function checkHatStatus(uint256 _hatId) public returns (bool toggled);
  ```

- **setHatWearerStatus**
  ハットの適格性モジュールが報告する着用者の状態を報告し、falseであればそのハットを取り消す関数。
  取り消された場合、着用者のハットはバーンされる。

  ```solidity
  function setHatWearerStatus(
    uint256 _hatId, 
    address _wearer, 
    bool _eligible, 
    bool _standing
  ) external returns (bool updated);
  ```

- **checkHatWearerStatus**
  ハットの適格性モジュールに着用者の状態を報告するように要求し、falseであればそのハットを取り消す関数。
  
  取り消された場合、着用者のハットはバーンされる。

  ```solidity
  function checkHatWearerStatus(
    uint256 _hatId, 
    address _wearer
  ) public returns (bool updated);
  ```

- **renounceHat**
  ハットを「放棄」する関数。`msg.sender`のハットをバーンする。

  ```solidity
  function renounceHat(uint256 _hatId) external;
  ```

- **transferHat**
  ハットを一つの着用者から他の適格な着用者へ移す関数。
  ハットは可変である必要があり、管理者によって転送が開始される必要がある。

  ```solidity
  function transferHat(
    uint256 _hatId, 
    address _from, 
    address _to
  ) public;
  ```

- **makeHatImmutable**
  可変ハットを不変に設定する関数。hat.configの2番目のビットを0に設定する。

  ```solidity
  function makeHatImmutable(uint256 _hatId) external;
  ```

- **changeHatDetails**
  ハットの詳細を変更する関数。ハットは可変である必要があるが、トップハットは例外。

  ```solidity
  function changeHatDetails(
    uint256 _hatId, 
    string calldata _newDetails
  ) external;
  ```

- **changeHatEligibility**
  ハットの適格性モジュールを変更する関数。ハットは可変である必要がある。

  ```solidity
  function changeHatEligibility(
    uint256 _hatId, 
    address _newEligibility
  ) external;
  ```
- **changeHatToggle**
  ハットのトグルモジュールを変更する関数。ハットは可変である必要がある。

  ```solidity
  function changeHatToggle(
    uint256 _hatId, 
    address _newToggle
  ) external;
  ```

- **changeHatImageURI**
  ハットの画像URIを変更する関数。ハットは可変である必要があり、トップハットは例外。

  ```solidity
  function changeHatImageURI(uint256 _hatId, string calldata _newImageURI) external;
  ```

- **changeHatMaxSupply**
  ハットの最大供給量を変更する関数。ハットは可変である必要があり、新しい最大供給量は現在の供給量より少なくできない。

  ```solidity
  function changeHatMaxSupply(
    uint256 _hatId, 
    uint32 _newMaxSupply
  ) external;
  ```

- **requestLinkTopHatToTree**
  ハットツリーを親ツリーにリンクするためのリクエストを送信する関数。

  ```solidity
  function requestLinkTopHatToTree(
    uint32 _topHatDomain, 
    uint256 _requestedAdminHat
  ) external;
  ```

- **approveLinkTopHatToTree**
  ハットツリーを親ツリーにリンクするリクエストを承認する関数。
  リンク先の適格性やトグルモジュールを追加し、メタデータを変更するオプションがある。

  ```solidity
  function approveLinkTopHatToTree(
    uint32 _topHatDomain,
    uint256 _newAdminHat,
    address _eligibility,
    address _toggle,
    string calldata _details,
    string calldata _imageURI
  ) external;
  ```

- **unlinkTopHatFromTree**
  親ツリーとのリンクを解除し、トグルと適格性を削除する関数。画像URIはbaseImageURIにリセットされる。

  ```solidity
  function unlinkTopHatFromTree(uint32 _topHatDomain) external;
  ```

- **viewHat**
  指定されたハットIDに対応するハットのメタデータを返す関数。
  
  ハットIDの仕組みについては`HatsIdUtilities.sol`を参照。

  ```solidity
  function viewHat(uint256 _hatId) public view returns (
      uint256 id,
      uint256 admin,
      string memory details,
      uint32 maxSupply,
      address eligibility,
      address toggle,
      bool mutable,
      string memory imageURI,
      uint32 supply,
      bool active
  );
  ```

- **balanceOf**
  特定のアドレスが所有する特定のハットの数を返す関数。

  ```solidity
  function balanceOf(
    address _wearer, 
    uint256 _hatId
  ) public view override returns (uint256 balance);
  ```

- **ownerOf**
  現在の所有者のリストを返す関数。着用者のみを対象とし、最大20の結果を返す。ページネーションのサポートを計画。

  ```solidity
  function ownerOf(uint256 _hatId) public view returns (address[] memory owners);
  ```

- **isWearerOfHat**
  指定されたアドレスが指定されたハットを着用しているかどうかを返す関数。

  ```solidity
  function isWearerOfHat(
    address _wearer, 
    uint256 _hatId
  ) public view returns (bool isWearer);
  ```

- **isActive**
  ハットがアクティブかどうかを確認する関数。

  ```solidity
  function isActive(uint256 _hatId) public view returns (bool active);
  ```

- **isInGoodStanding**
  ハットの着用者が不良状態でないかを確認する関数。

  ```solidity
  function isInGoodStanding(
    uint256 _hatId, 
    address _wearer
  ) public view returns (bool good);
  ```

- **isAdminOfHat**
  指定されたアドレスが特定のハットの管理者であるかどうかを確認する関数。
  
  `_hatId`の管理者が`_wearer`の所有する他のハットである場合、真を返す。

  ```solidity
  function isAdminOfHat(
    address _wearer, 
    uint256 _hatId
  ) public view returns (bool isAdmin);
  ```

- **getImageURIForHat**
  ハットの画像URIを取得する関数。
  画像URIが設定されていない場合はbaseImageURIを返す。

  ```solidity
  function getImageURIForHat(uint256 _hatId) public view returns (string memory uri);
  ```

- **uri**
  ハットトークンのERC-1155標準準拠のURIメソッド。

  ```solidity
  function uri(uint256 _hatId) public view override returns (string memory);
  ```

- **supportsInterface**
  特定のインターフェースをサポートしているかどうかを確認する関数。

  ```solidity
  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155) returns (bool);
  ```

- **_beforeTokenTransfer**
  トークンの転送前に実行される内部関数。

  ```solidity
  function _beforeTokenTransfer(
    address operator, 
    address from, 
    address to, 
    uint256[] memory ids, 
    uint256[] memory amounts, 
    bytes memory data
  ) internal virtual override;
  ```

#### 構造体

**Hat**という構造体が定義されています。

```sol
struct Hat {
  address eligibility; // 適格性モジュールのアドレス
  uint32 maxSupply; // 最大供給量
  uint32 supply; // 現在の供給量
  uint16 lastHatId; // 最後のハットID
  address toggle; // トグルモジュールのアドレス
  uint96 config; // 構成データ
  string details; // ハットの詳細
  string imageURI; // ハットの画像URI
}
```

### **HatsEvents.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/HatsEvents.sol)

このコントラクトでは各種イベントが定義されています。

- **HatCreated**  
  新しいハットが作成された時に発行されるイベント

  ```sol
  event HatCreated(
    uint256 id, 
    string details, 
    uint32 maxSupply, 
    address eligibility, 
    address toggle, 
    bool mutable_, 
    string imageURI
  );
  ```

- **WearerStandingChanged**
  ハットを着用している人のステータスが更新された時に発行されるイベント

  適格性（Eligibility）は含まれていません。適格性の真偽は適格性モジュールによって管理され、トランザクションなしで変更されることがあるためです。

  ```sol
  event WearerStandingChanged(
    uint256 hatId, 
    address wearer, 
    bool wearerStanding
  );
  ```

- **HatStatusChanged**
  ハットのステータスが更新された時に発行されるイベント

  ```sol
  event HatStatusChanged(uint256 hatId, bool newStatus);
  ```

- **HatDetailsChanged**
  ハットの詳細が更新された時に発行されるイベント

  ```sol
  event HatDetailsChanged(uint256 hatId, string newDetails);
  ```

- **HatEligibilityChanged**
  ハットの適格性モジュールが更新された時に発行されるイベント

  ```sol
  event HatEligibilityChanged(uint256 hatId, address newEligibility);
  ```

- **HatToggleChanged**
  ハットのトグルモジュールが更新された時に発行されるイベント

  ```sol
  event HatToggleChanged(uint256 hatId, address newToggle);
  ```

- **HatMutabilityChanged**
  ハットの可変性が更新された時に発行されるイベント

  ```sol
  event HatMutabilityChanged(uint256 hatId);
  ```

- **HatMaxSupplyChanged**
  ハットの最大供給量が更新された時に発行されるイベント

  ```sol
  event HatMaxSupplyChanged(uint256 hatId, uint32 newMaxSupply);
  ```

- **HatImageURIChanged**
  ハットの画像URIが更新された時に発行されるイベント

  ```sol
  event HatImageURIChanged(uint256 hatId, string newImageURI);
  ```
- **TopHatLinkRequested**
  トッパーハットのリンクがその管理者によってリクエストされた時に発行されるイベント

  ```sol
  event TopHatLinkRequested(uint32 domain, uint256 newAdmin);
  ```

- **TopHatLinked**
  トッパーハットが別のツリーにリンクされた時に発行されるイベント

  ```sol
  event TopHatLinked(uint32 domain, uint256 newAdmin);
  ```

### **HatsErrors.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/Interfaces/HatsErrors.sol)

このファイルではHatsProtocolで利用するカスタムエラーが定義されています。

- **NotAdmin**
  ユーザーが `hatId` に対してアクションを試みたが、その `hatId` の管理者ハットのいずれも着用していない場合に発生するエラーです。

  `approveLinkTopHatToTree` や `relinkTopHatToTree` などの操作で発生する可能性があります。

  ```sol
  error NotAdmin(address user, uint256 hatId);
  ```

- **NotHatWearer**
  指定されたハットの着用者でないアカウントとして、またはそのアカウントのためにアクションを実行しようとした場合に発生するエラーです。

  ```sol
  error NotHatWearer();
  ```

- **NotAdminOrWearer**
  指定されたハットの管理者または着用者である必要があるアクションを試みた場合に発生するエラーです。

  ```sol
  error NotAdminOrWearer();
  ```

- **AllHatsWorn**
  `hatId` をミントしようとしたが、その `hatId` の最大供給量が達成されている場合に発生するエラーです。

  ```sol
  error AllHatsWorn(uint256 hatId);
  ```

- **MaxLevelsReached**
  レベル14のハットを管理者として持つハットを作成しようとした場合に発生するエラーです。

  ```sol
  error MaxLevelsReached();
  ```

- **InvalidHatId**
  試みたハットIDに中間レベルが空である場合に発生するエラーです。

  ```sol
  error InvalidHatId();
  ```

- **AlreadyWearingHat**
  既にそのハットを着用している着用者に対して hatId をミントしようとした場合に発生するエラーです。

  ```sol
  error AlreadyWearingHat(address wearer, uint256 hatId);
  ```

- **HatDoesNotExist**
  存在しないハットをミントしようとした場合に発生するエラーです。

  ```sol
  error HatDoesNotExist(uint256 hatId);
  ```

- **HatNotActive**
  アクティブでないハットをミントまたは転送しようとした場合に発生するエラーです。

  ```sol
  error HatNotActive();
  ```

- **NotEligible**
  適格でない着用者に対してハットをミントまたは転送しようとした場合に発生するエラーです。

  ```sol
  error NotEligible();
  ```

- **NotHatsToggle**
  ハットのステータスを確認または設定しようとしたが、そのアカウントがそのハットのトグルモジュールでない場合に発生するエラーです。

  ```sol
  error NotHatsToggle();
  ```

- **NotHatsEligibility**
  ハットの着用者のステータスを確認または設定しようとしたが、そのアカウントがそのハットの適格性モジュールでない場合に発生するエラーです。

  ```sol
  error NotHatsEligibility();
  ```

- **BatchArrayLengthMismatch**
  バッチ関数に渡す配列の引数の長さが一致しない場合に発生するエラーです。

  ```sol
  error BatchArrayLengthMismatch();
  ```

- **Immutable**
  変更または転送が不可能なハットを試みた場合に発生するエラーです。

  ```sol
  error Immutable();
  ```

- **NewMaxSupplyTooLow**
  ハットの maxSupply を現在の供給量よりも低い値に変更しようとした場合に発生するエラーです。

  ```sol
  error NewMaxSupplyTooLow();
  ```

- **CircularLinkage**
  トッパーハットを新しい管理者にリンクしようとしたが、そのトッパーハットが新しい管理者の管理下にある場合に発生するエラーです。

  ```sol
  error CircularLinkage();
  ```

- **CrossTreeLinkage**
  トッパーハットを別のツリーにリンクまたは再リンクしようとした場合に発生するエラーです。

  ```sol
  error CrossTreeLinkage();
  ```

- **LinkageNotRequested**
  トッパーハットのリンクがリクエストなしで試みられた場合に発生するエラーです。

  ```sol
  error LinkageNotRequested();
  ```

- **InvalidUnlink**
  着用者が存在しないトッパーハットのリンク解除を試みた場合に発生するエラーです。これにより、リンク解除がトッパーハットを壊すことはありません。

  ```sol
  error InvalidUnlink();
  ```

- **ZeroAddress**
  ハットの適格性またはトグルモジュールをゼロアドレスに変更しようとした場合に発生するエラーです。

  ```sol
  error ZeroAddress();
  ```

- **StringTooLong**
  ハットの詳細や画像URIを7000バイト（約7000文字）を超える文字列に変更しようとした場合に発生するエラーです。これにより、管理者がハットの詳細や画像URIを長くしすぎて読み込みがブロックのガス制限を超えることを防ぎます。

  ```sol
  error StringTooLong();
  ```

### **HatsUtillities.sol**

[ソースコード](https://github.com/Hats-Protocol/hats-protocol/blob/b43ad0d1dbe4a4190febc036ee8a2849e3f221b4/src/HatsIdUtilities.sol)

このコントラクトではHatsProtocolで使える便利な共通メソッドや変数が実装されています。

#### ステート変数

- **linkedTreeRequests**
  他のツリーの管理者ハットにリンクを要求するトッパーハットのマッピング

  リクエストが新しい管理者によって承認されるとリンクが行われます。

  ```sol
  mapping(uint32 => uint256) public linkedTreeRequests;
  ```

- **linkedTreeAdmins**
  他のツリーの管理者ハットに承認されてリンクされたトッパーハットのマッピング。ハットツリーを別のツリーに接ぎ木するために使用します。

  ツリーはトッパーハットを介してのみ別のツリーにリンクできます。

  ```sol
  mapping(uint32 => uint256) public linkedTreeAdmins;
  ```

- **TOPHAT_ADDRESS_SPACE**
  ハットIDはアドレスとして機能します。指定されたハットのIDは、そのハットツリー内での位置を表します：レベル、管理者、管理者の管理者（など、トッパーハットまで上昇）。最上位レベルは4バイトで構成され、すべてのトッパーハットを参照します。下の各レベルは16ビットで構成され、最大65,536個の子ハットを含むことができます。uint256 は4バイトのトッパーハットアドレスのスペースを持ち、((256 - 32) / 16) = 14レベルの委任をサポートし、各レベルの管理者は65,536個の異なる子ハットのスペースを持ちます。ハットツリーは単一のトッパーハットで構成され、最大14レベルの深さがあります。

  ```sol
  uint256 internal constant TOPHAT_ADDRESS_SPACE = 32;
  ```

- **LOWER_LEVEL_ADDRESS_SPACE**
  トッパーハットの下にある各レベルのアドレススペースのビット数です。

  ```sol
  uint256 internal constant LOWER_LEVEL_ADDRESS_SPACE = 16;
  ```

- **MAX_LEVELS**
  トッパーハットの下の最大レベル数、つまりツリーの最大深さです。
  
  計算式は (256 - TOPHAT_ADDRESS_SPACE) / LOWER_LEVEL_ADDRESS_SPACE です。

  ```sol
  uint256 internal constant MAX_LEVELS = 14;
  ```

#### 関数

- **buildHatId**
  指定された管理者の下に新しいハットの有効なIDを構築します。

  管理者がすでに MAX_LEVELS に達している場合は、リバートします。

  ```sol
  /**
    * @param _admin 新しい帽子の管理者のID
    * @param _newHat 新しい帽子のID
    * @return id 構築された帽子のID
    */
  function buildHatId(
    uint256 _admin, 
    uint16 _newHat
  ) public pure returns (uint256 id);
  ```

- **getHatLevel**
  指定されたハットがそのハットツリー内でのレベルを識別します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return level 帽子のツリー内でのレベル
   */
  function getHatLevel(uint256 _hatId) public view returns (uint32 level);
  ```

- **getLocalHatLevel**
  指定されたハットがそのローカルハットツリー内でのレベルを識別します。

  getHatLevel と似ていますが、リンクされたツリーは考慮しません。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return level ローカルツリー内での帽子のレベル
   */
  function getLocalHatLevel(uint256 _hatId) public pure returns (uint32 level);
  ```

- **isTopHat**
  ハットがトッパーハットであるかどうかを確認します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return _isTopHat 帽子がトップハットであるかどうか
   */
  function isTopHat(uint256 _hatId) public view returns (bool _isTopHat);
  ```

- **isLocalTopHat**
  ハットがそのローカルハットツリー内でトッパーハットであるかどうかを確認します。

  isTopHat と似ていますが、リンクされたツリーは考慮しません。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return _isLocalTopHat 帽子がローカルツリーのトップハットであるかどうか
   */
  function isLocalTopHat(uint256 _hatId) public pure returns (bool _isLocalTopHat);
  ```

- **isValidHatId**
  ハットIDが有効かどうかを確認します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return validHatId 帽子のIDが有効であるかどうか
   */
  function isValidHatId(uint256 _hatId) public pure returns (bool validHatId);
  ```

- **getAdminAtLevel**
  指定されたハットの指定レベルの管理者ハットのIDを取得します。

  この関数は、linkedTreeAdmin ポインタをたどって、別のツリーにあるハットを探します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @param _level 調べるレベル
   * @return admin 指定レベルの管理者の帽子ID
   */
  function getAdminAtLevel(
    uint256 _hatId, 
    uint32 _level
  ) public view returns (uint256 admin);
  ```

- **getAdminAtLocalLevel**
  指定されたハットがそのツリー内での指定レベルの管理者ハットのIDを取得します。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @param _level 調べるレベル
   * @return admin ローカルツリー内で指定レベルの管理者の帽子ID
   */
  function getAdminAtLocalLevel(
    uint256 _hatId, 
    uint32 _level
  ) public pure returns (uint256 admin);
  ```

- **getTopHatDomain**
  指定されたハットのトッパーハットドメインを取得します。

  ドメインはハットIDの最初の4バイトに格納されている、ハットツリーの識別子です。

  ```sol
  /**
   * @param _hatId 調べる帽子のID
   * @return domain 帽子のトップハットドメイン
   */
  function getTopHatDomain(uint256 _hatId) public pure returns (uint32 domain);
  ```

- **getTippyTopHatDomain**
  最も高い親トッパーハット、いわゆる「ティッピートッパーハット」のドメインを取得します。

  ```sol
  /**
   * @param _topHatDomain 調べるトップハットドメイン
   * @return domain 最高の親トップハットのドメイン
   */
  function getTippyTopHatDomain(uint32 _topHatDomain) public view returns (uint32 domain);
  ```

- **noCircularLinkage**
  ツリーの循環リンクがないかをチェックします。

  ```sol
  /**
   * @param _topHatDomain リンクするツリーのドメイン
   * @param _linkedAdmin リンク先の管理者の帽子ID
   * @return notCircular 円環状リンクが見つからなかった場合にtrue
   */
  function noCircularLinkage(
    uint32 _topHatDomain, 
    uint256 _linkedAdmin
  ) public view returns (bool notCircular);
  ```

- **sameTippyTopHatDomain**
  トッパーハットドメインとそのポテンシャルリンク管理者が同じツリーから来ていること、つまり同じティッピートッパーハットドメインを持っていることを確認します。

  ```sol
  /**
   * @param _topHatDomain リンクするトップハットのドメイン
   * @param _newAdminHat 新しいリンク先の管理者の帽子ID
   * @return sameDomain トップハットドメインと新しい管理者のドメインが同じかどうか
   */
  function sameTippyTopHatDomain(
    uint32 _topHatDomain, 
    uint256 _newAdminHat
  ) public view returns (bool sameDomain);
  ```

## SDKを見ていこう！！

Coreコントラクトを細かく確認したので次は **SDK** についての細かく確認していきましょう！！

公式ドキュメントでは以下のページで確認できます！！

https://docs.hatsprotocol.xyz/for-developers/v1-sdk

### 読み取り系のメソッド

- **viewHat**
  帽子のプロパティを取得します。

  ```js
  const hat = await hatsClient.viewHat(hatId);
  ```

  取得できるプロパティは以下の通り

  ```js
  {
    details: string;
    maxSupply: number;
    supply: number;
    eligibility: Address;
    toggle: Address;
    imageUri: string;
    numChildren: number;
    mutable: boolean;
    active: boolean;
  }
  ```

- **isWearerOfHat**
  特定の帽子を着用しているかどうかをチェックします。

  ```js
  const isWearer = await hatsClient.isWearerOfHat({
    wearer,
    hatId,
  })
  ```

- **isAdminOfHat**
  特定の帽子の管理者であるかどうかをチェックします。

  ```js
  const isAdmin = await hatsClient.isAdminOfHat({
    user,
    hatId,
  });
  ```

- **isActive**
  帽子がアクティブかどうかをチェックします。

  ```js
  const isActive = await hatsClient.isActive(hatId);
  ```

- **isInGoodStanding**
  特定の帽子の着用者が「良好な状態」にあるかどうかをチェックします。

  ```js
  const isGoodStanding = await hatsClient.isInGoodStanding({
    wearer,
    hatId,
  });
  ```

- **isEligible**
  特定の帽子に対してアドレスが適格であるかどうかをチェックします。

  ```js
  const isEligible = await hatsClient.isEligible({
    wearer,
    hatId,
  });
  ```

- **predictHatId**
  まだ作成されていない帽子のIDを予測します。

  ```js
  const hatId = await hatsClient.predictHatId(admin);
  ```

- **getTreesCount**
  存在するツリーの数を取得します。

  ```js
  const numTrees = await hatsClient.getTreesCount();
  ```

- **getLinkageRequest**

  ツリーのリンクリクエストを取得します。

  ```js
  const requestedAdminHat = await hatsClient.getLinkageRequest(topHatDomain);
  ```

- **getLinkedTreeAdmin**
  リンクされたツリーの管理者を取得します（TopperHatがリンクされている帽子）。

  ```js
  const adminHat = await hatsClient.getLinkedTreeAdmin(topHatDomain);
  ```

- **getHatLevel**
  帽子のレベルを取得します。ツリーがリンクされている場合、レベルはグローバルツリー（すべてのリンクツリーを含む）で計算されます。

  ```js
  const level = await hatsClient.getHatLevel(hatId);
  ```

- **getLocalHatLevel**
  ローカルツリー内での帽子のレベルを取得します（リンクされたツリーを考慮しません）。

  ```js
  const level = await hatsClient.getLocalHatLevel(hatId);
  ```

- **getTopHatDomain**
  帽子のツリードメインを取得します。

  ```js
  const domain = await hatsClient.getTopHatDomain(hatId);
  ```

- **getTippyTopHatDomain**
  指定されたツリーが含まれるグローバルツリーのトッパーハット（「ティッピートッパーハット」）のツリードメインを取得します。

  ```js
  const domain = await hatsClient.getTippyTopHatDomain(topHatDomain);
  ```

- **getAdmin**
  帽子の直接の管理者を取得します。

  ```js
  const admin = await hatsClient.getAdmin(hatId);
  ``` 

- **getChildrenHats**
  帽子の子供の帽子を取得します。

  ```js
  const children = await hatsClient.getChildrenHats(hatId);
  ```

### 書き込み系のメソッド

続いてSDKに用意されている書き込み系の処理を見ていきましょう！！

- **mintTopHat**
  新しいトップハットを作成する（新しいツリーを作成する）。

  ```js
  const mintTopHatResult = await hatsClient.mintTopHat({
    account,
    target,
    details,
    imageURI,
  });
  ```

- **createHat**
  ハットを作成する。

  ```js
  const createHatResult = await hatsClient.createHat({
    account,
    admin,
    details,
    maxSupply,    //ハットの最大着用者数。
    eligibility,  // ハットの適格性アドレス（ゼロアドレスは無効）。
    toggle,       // ハットのトグルアドレス（ゼロアドレスは無効）。
    mutable,      // ハットを変更可能にする場合はtrue、そうでない場合はfalse。
    imageURI,     // 任意のハットの画像URI。
  });
  ```

- **batchCreateHats**
  複数のハットを作成する。

  ```js
  const batchCreateHatsResult = await hatsClient.batchCreateHats({
    account,
    admins,
    details,
    maxSupplies,
    eligibilityModules,
    toggleModules,
    mutables,
    imageURIs,
  });
  ```

- ハットをミントする

  ```js
  const mintHatResult = await hatsClient.mintHat({
    account,
    hatId,
    wearer,
  });
  ```

- **batchMintHats**
  複数のハットをミント（発行）する。

  ```js 
  const batchMintHatsResult = await hatsClient.batchMintHats({
    account,
    hatIds,
    wearers,
  });
  ```

- **setHatStatus**
  ハットのステータスをアクティブ/非アクティブに設定する。

  ```js
  const setHatStatusResult = await hatsClient.setHatStatus({
    account,
    hatId,
    newStatus,
  });
  ```

- **checkHatStatus**
  トグルモジュールを呼び出してハットのステータスを確認し、必要に応じてステータスを更新する。

  ```js
  const checkHatStatusResult = await hatsClient.checkHatStatus({
    account,
    hatId,
  });
  ```

- **setHatWearerStatus**
  ハットの着用者のステータスを設定する。

  ```js
  const setHatWearerStatusResult = await hatsClient.setHatWearerStatus({
    account,
    hatId,
    wearer,
    eligible,
    standing,
  });
  ```

- **checkHatWearerStatus**
  ハットの着用者のステータスを確認し、必要に応じて更新する。

  ```js
  const checkHatWearerStatusResult = await hatsClient.checkHatWearerStatus({
    account,
    hatId,
    wearer,
  });
  ```

- **transferHat**
  ハットを別のユーザーに譲渡する。

  ```js
  const transferHatResult = await hatsClient.transferHat({
    account,
    hatId,
    from,
    to,
  });
  ```

- **renounceHat**
  ユーザーが自分のハットを放棄する。

  ```js
  const renounceHatResult = await hatsClient.renounceHat({
    account,
    hatId,
    wearer,
  });
  ```

- **changeHatDetails**
  ハットの詳細を変更する。

  ```js
  const changeHatDetailsResult = await hatsClient.changeHatDetails({
    account,
    hatId,
    newDetails,
  });
  ```

- **changeHatEligibility**
  ハットの適格性モジュールを変更する。

  ```js
  const changeHatEligibilityResult = await hatsClient.changeHatEligibility({
    account,
    hatId,
    newEligibility,
  });
  ```

- **changeHatToggle**
  ハットのトグルモジュールを変更する。

  ```js
  const changeHatToggleResult = await hatsClient.changeHatToggle({
    account,
    hatId,
    newToggle,
  });
  ```

- **changeHatMutable**
  ハットの変更可能フラグを更新する。

  ```js
  const changeHatMutableResult = await hatsClient.changeHatMutable({
    account,
    hatId,
    newMutable,
  });
  ```

- **changeHatImageURI**
  ハットの画像URIを更新する。

  ```js
  const changeHatImageURIResult = await hatsClient.changeHatImageURI({
    account,
    hatId,
    newImageURI,
  });
  ```

- **changeHatName**
  ハットの名前を変更する。

  ```js
  const changeHatNameResult = await hatsClient.changeHatName({
    account,
    hatId,
    newName,
  });
  ```

- **setHatStatus**
  ハットのステータスを直接設定する。

  ```js 
  const setHatStatusResult = await hatsClient.setHatStatus({
    account,
    hatId,
    wearer,
    eligible,
    standing,
  });     
  ```

- **revokeHatWearer**
  特定の着用者からハットを取り上げる。

  ```js
  const renounceHatResult = await hatsClient.renounceHat({
    account,
    hatId,
  });
  ```

### MuitiCall

一括で複数のトランザクションを実行することもできます！！

```js
const multicallResult = await hatsClient.multicall({
    account,
    calls,
});
```

`calls`に実行させたいトランザクションのデータを詰めます。

```json
{
  account: Account | Address;
  calls: {
    functionName: string;
    callData: Hex;
  }[];
}
```

例えば以下のように用意します。

```js
const mintTopHatCallData = await hatsClient.mintTopHatCallData({
    target,
    details,
    imageURI,
});

const createHatCallData = await hatsClient.createHatCallData({
    admin,
    details,
    maxSupply,
    eligibility,
    toggle,
    mutable,
    imageURI,
});

const mintHatCallData = await hatsClient.mintHatCallData({
    hatId,
    wearer,
});

const multiCallResult = await hatsClient.multicall({
    account,
    calls: [
      mintTopHatCallData, 
      createHatCallData, 
      mintHatCallData
    ],
});
```

`multicallPreFlightCheck` というマルチコール用のシミュレート関数があります。

```js
await hatsClient.multicallPreFlightCheck({
  account,
  calls,
});
```

### ClaimHat

Hat関連で便利な関数がいくつか用意されています。


- **accountCanClaim**
  アカウントが特定のハットを請求できるかどうかを確認します。

  ```js
  const canClaim = await hatsClient.accountCanClaim({
    hatId,
    account,
  });
  ```

- **canClaimForAccount**
  特定のアカウントの代わりにハットを請求できるかどうかを確認します。

  ```js
  const canClaimFor = await hatsClient.canClaimForAccount({
    hatId,
    account,
  });
  ```

- **claimHat**
  呼び出し元のアカウントのためにハットを請求します。

  ```js
  const claimHatResult = await hatsClient.claimHat({
    account,
    hatId,
  });
  ```

- **claimHatFor**
  選択されたアカウントの代わりにハットを請求します。

  ```js
  const claimHatForResult = await hatsClient.claimHatFor({
    account,
    hatId,
    wearer,
  });
  ```

- **multiClaimHatFor**
  複数のアカウントの代わりにハットを請求します。

  ```js
  const claimHatForResult = await hatsClient.multiClaimHatFor({
    account,
    hatId,
    wearers,
  });
  ```

### 便利な機能

他にもSDKには便利な機能がいくつか用意されています！！

- **hatIdDecimalToHex**
  ハットIDを10進数から16進数に変換します。

  ```js
  import { hatIdDecimalToHex } from "@hatsprotocol/sdk-v1-core";

  const hatIdHex = hatIdDecimalToHex(hatId);
  ```

- **hatIdHexToDecimal**
  ハットIDを16進数から10進数に変換します。

  ```js
  import { hatIdHexToDecimal } from "@hatsprotocol/sdk-v1-core";

  const hatIdDecimal = hatIdHexToDecimal(hatId);
  ```

- **treeIdDecimalToHex**
  ツリーIDを10進数から16進数に変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js
  import { treeIdDecimalToHex } from "@hatsprotocol/sdk-v1-core";

  const treeIdHex = treeIdDecimalToHex(treeId);
  ```

- **treeIdHexToDecimal**
  ツリーIDを16進数から10進数に変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js
  import { treeIdHexToDecimal } from "@hatsprotocol/sdk-v1-core";

  const treeIdDecimal = treeIdHexToDecimal(treeId);
  ```

- **treeIdToTopHatId**
  ツリーIDをトップハットIDに変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js 
  import { treeIdToTopHatId } from "@hatsprotocol/sdk-v1-core";

  const tophatId = treeIdToTopHatId(treeId);
  ```

- **hatIdToTreeId**
  ハットIDをツリーIDに変換します。ツリーIDはハットIDの最初の4バイトです。

  ```js 
  import { hatIdToTreeId } from "@hatsprotocol/sdk-v1-core";

  const treeId = hatIdToTreeId(hatId);
  ```

- **hatIdDecimalToIp**
  IP形式は、見栄えの良いハットID形式として使用されることがあります。

  例えば、16進数IDが `0x00000001000a0002000000000000000000000000000000000000000000000000` であるハットは、IP形式で 1.10.2 となります。各レベルはドットで区切られ、ゼロを除いて10進数として表示されます。

  ```js
  import { hatIdDecimalToIp } from "@hatsprotocol/sdk-v1-core";

  const hatIdIp = hatIdDecimalToIp(hatId);
  ```

- **hatIdIpToDecimal**
  ハットIDをIP形式から10進数形式に変換します。


  ```js
  import { hatIdIpToDecimal } from "@hatsprotocol/sdk-v1-core";

  const hatIdDecimal = hatIdIpToDecimal(hatId);
  ```

## Subgraph用のSDKについて

HatsProtocolでは SubGraphも用意されています！！

既に用意されているサブグラフのエンドポイントは以下の通りです！！

https://docs.hatsprotocol.xyz/for-developers/v1-subgraphs

詳しい使い方は以下のドキュメントから確認ができます！！

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/getting-started

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/fetching-hats

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/fetching-wearers

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/fetching-trees

**Sepolia** の場合は以下がエンドポイントのようですね

https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest

Hatsや着用者、ツリー情報の情報を取得することが可能みたいです。

取得できるデータの種類については、下記サイトで確認ができます！！

https://docs.hatsprotocol.xyz/for-developers/v1-sdk/subgraph/types

- **SDKインスタンスの生成例**

  ```ts
  import {HatsSubgraphClient} from "@hatsprotocol/sdk-v1-subgraph";
  import {optimism, sepolia} from "viem/chains";

  // Subgraph用のインスタンスを生成
  const hatsSubgraphClient = new HatsSubgraphClient({
    config: {
      [sepolia.id]: {
        endpoint:
          "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest",
      },
      [optimism.id]: {
        endpoint:
          "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest",
      },
    },
  });
  ```

- **SDKインスタンスの使用例**

  上記で生成したインスタンスは次のように使うことができます！

  ```ts
  // hatの情報を取得する。
  const hat = await hatsSubgraphClient.getHat({
    chainId: 10, // optimism
    hatId: BigInt(
      "0x0000000100020001000100000000000000000000000000000000000000000000"
    ),
    props: {
      maxSupply: true, // get the maximum amount of wearers for the hat
      wearers: {
        // get the hat's wearers
        props: {}, // for each wearer, include only its ID (address)
      },
      events: {
        // get the hat's events
        props: {
          transactionID: true, // for each event, include the transaction ID
        },
        filters: {
          first: 10, // fetch only the latest 10 events
        },
      },
    },
  });

  console.log("hat:", hat);
  ```

## Hats モジュール

**Hatsモジュール**とは、Eligibilityモジュール、Toggleモジュール、またはHatterコントラクトとして機能する任意のコントラクトを指します。

モジュールは、Hats Protocolの動作をカスタマイズ、自動化、拡張するもので、他のプロトコルやアプリケーションとのアダプターや統合ポイントとしても機能します。

ある意味で、モジュールはHats Protocolの生命線です。

デザインの幅は広く、組織や協調のためのあらゆる構成要素を作り出す可能性に満ちています。


開発者がHatsモジュールを扱うには、主に二つの方法があります。

- **既存のモジュールと連携する方法**

  **Modules SDK** を使います！！

  - **必要なライブラリをインストールする方法**

    ```bash
    yarn add @hatsprotocol/modules-sdk viem
    ```

  - **セットアップ**

    以下のようにセットアップするようです。

    Subgraph用のSDKとほぼ同じですね！

    ```ts
    import { HatsModulesClient } from "@hatsprotocol/modules-sdk";

    const hatsModulesClient = new HatsModulesClient({
        publicClient,
        walletClient,
    });
    ```

  - **HatsModule SDKが提供している機能をみていこう！**

    - **prepare**

      この関数は、モジュールレジストリからデータを取得します。

      https://github.com/Hats-Protocol/modules-registry
      
      このステップは、クライアントを使用できるようにするために必要です。
      
      さらに、この関数はオプションでレジストリを入力として受け取ることができ、ユーザーのキャッシュをサポートします。もしレジストリが提供された場合、クライアントはレジストリからデータを取得する代わりに、提供されたモジュールを使用します。

      ```ts
      await hatsModulesClient.prepare();
      ```

    - **getModules**

      使用可能なモジュール一覧を取得するメソッド

      ```ts
      const modules = hatsModulesClient.getAllModules();
      ```

    - **getModuleById**

      モジュールIDを指定してモジュールを取得するメソッド

      ```ts
      const module = hatsModulesClient.getModuleById(moduleId);
      ```

    - **getModuleByImplementation**

      `implementation`アドレスを指定してモジュールを取得するメソッド

      ```ts
      const module = hatsModulesClient.getModuleByImplementation(address);
      ```

    - **getModuleByInstance**

      こちらもアドレスを取得してモジュールを取得するメソッドらしい

      ```ts
      const module = await hatsModulesClient.getModuleByInstance(address);
      ```

    - **getModulesByInstances**

      ```ts
      const modules = await hatsModulesClient.getModulesByInstances(addresses);
      ```

    - **createNewInstance**

      新しいモジュールインスタンスを作成します。

      ```ts
      /**
       *
      * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はアドレス、その他のタイプの場合はアカウント）。
      * @param {string} moduleId - モジュールID（実装アドレス）。
      * @param {bigint} hatId - モジュールが作成される帽子ID。
      * @param {unknown[]} immutableArgs - モジュールの不変引数。引数はModuleオブジェクト内の順序と同じでなければなりません。
      * @param {unknown[]} mutableArgs - モジュールの可変引数。引数はModuleオブジェクト内の順序と同じでなければなりません。
      * @param {bigint} [saltNonce] - オプションのソルトナンス。提供されない場合はランダムに生成されます。
      * @return {Object} - レスポンスオブジェクト。
      * @return {string} status - トランザクションが成功した場合は"success"、リバートした場合は"reverted"。
      * @return {string} transactionHash - トランザクションのハッシュ。
      * @return {string} newInstance - 成功した場合、新しいモジュールインスタンスのアドレス。
      */
      const createInstanceResult = await hatsModulesClient.createNewInstan(
        {
          account,
          moduleId,
          hatId,
          immutableArgs,
          mutableArgs,
          saltNonce,
        });
      ```

    - **batchCreateNewInstances**

      まとめて複数のモジュールを作るメソッドです。

      ```ts
      /**
       *
       * @param {Account | Address} account - Viemアカウント（JSON-RPCアカウントの場合はアドレス、その他のタイプの場合はアカウント）。
       * @param {string[]} moduleIds - モジュールID（実装アドレス）。
       * @param {bigint[]} hatIds - モジュールが作成される帽子ID。
       * @param {unknown[][]} immutableArgsArray - 各モジュールの不変引数。モジュールごとに、引数はModuleオブジェクト内の順序と同じでなければなりません。
       * @param {unknown[][]} mutableArgsArray - 各モジュールの可変引数。モジュールごとに、引数はModuleオブジェクト内の順序と同じでなければなりません。
       * @param {bigint[]} [saltNonces] - オプションのソルトナンス。提供されない場合はランダムに生成されます。
       * @return {Object} - レスポンスオブジェクト。
       * @return {string} status - トランザクションが成功した場合は"success"、リバートした場合は"reverted"。
       * @return {string} transactionHash - トランザクションのハッシュ。
       * @return {string[]} newInstances - 成功した場合、新しいモジュールインスタンスのアドレス。
       */
      const createInstancesResult = await hatsModulesClient.batchCreateNewInstances(
        {
          account,
          moduleIds,
          hatIds,
          immutableArgsArray,
          mutableArgsArray,
          saltNonces
        });
      ```

    - **predictHatsModuleAddress**

      作成引数を使用して、モジュールのアドレスを予測します。

      ```ts
      /**
       *
       * @param {string} moduleId - モジュールID。
       * @param {bigint} hatId - インスタンス作成関数に提供されたターゲットの帽子ID。
       * @param {unknown[]} immutableArgs - インスタンス作成関数に提供されたモジュールの不変引数。
       * @param {bigint} saltNonce - 使用するソルトナンス。
       * @return {string} - 予測されたモジュールアドレス。
       */
      const predictedAddress = await hatsModulesClient.predictHatsModuleAddress(
        {
          moduleId,
          hatId,
          immutableArgs,
          saltNonce,
        });
      ```

- **新しいモジュールを構築する方法**

  下記を参考にして新しくモジュールを作ることになります！！

  https://docs.hatsprotocol.xyz/for-developers/hats-modules/building-hats-modules


## SDKを使ってみた

では次にSDKを触っていきたいと思います！！

SDKのGitHubは以下です。

https://github.com/Hats-Protocol/sdk-v1-core

自分で触ってみた記録は以下のGitHubにまとめてみました！！

https://github.com/mashharuki/HatsProtocolSample

SDKは **viem** を使うことを前提としているみたいですね。

yarnを使っている場合は以下のコマンドで必要なライブラリをインストールできます。

```bash
yarn add @hatsprotocol/sdk-v1-core
```

サブグラフのSDKも使うのであれば追加で以下のライブラリをインストールします。

```bash
yarn add @hatsprotocol/sdk-v1-subgraph
```

Hats Modules SDKを使うのであれば追加で以下のライブライをインストールします。

```bash
yarn add @hatsprotocol/modules-sdk viem
```

このサンプルコードを動かすためには準備が必要なのですがそれについてはREADMEをご覧ください。



環境がセットアップできたらまず以下のコマンドでインストールします。

```bash
yarn
```

その後、以下のコマンドを実行してしましょう！！

```bash
yarn sample sample
```

以下のように出力されればOKです！！

```bash
Current Block Number: 6484557n
Wallet's Balance: 55.995776264812553303 ETH
getting hat info
hatInfo: {
  details: '',
  maxSupply: 0,
  supply: 0,
  eligibility: '0x0000000000000000000000000000000000000000',
  toggle: '0x0000000000000000000000000000000000000000',
  imageUri: 'ipfs://bafkreiflezpk3kjz6zsv23pbvowtatnd5hmqfkdro33x5mh2azlhne3ah4',
  numChildren: 0,
  mutable: false,
  active: false
}
isWearer: false
isAdmin: false
isGoodStanding: true
isEligible: true
numTrees: 443
level: 14
localLevel: 14
domain: 0
requestedAdminHat: 0n
adminHat: 0n
tippyTopHatDomain: 0
adminId: 0n
childrens: []
Done in 6.30s.
```

hatの情報が取得できていますね！！！

少しだけコードの解説をします。

```ts
import {createPublicClient, createWalletClient, formatEther, http} from "viem";
import {sepolia} from "viem/chains";
import * as dotenv from "dotenv";
import {privateKeyToAccount} from "viem/accounts";
import {HatsClient} from "@hatsprotocol/sdk-v1-core";

dotenv.config();

// 環境変数を取得する。
const {RPC_URL, PRIVATE_KEY} = process.env;

// signerオブジェクトを作成する
export const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);

// Sepolia ネットワークのクライアントを作成する
export const client = createPublicClient({
  chain: sepolia,
  transport: http(RPC_URL),
});

// Wallet Client の作成
export const walletClient = createWalletClient({
  chain: sepolia,
  transport: http(RPC_URL),
  account,
});

// HatsProtocol用のインスタンスを生成する。
export const hatsClient = new HatsClient({
  chainId: sepolia.id,
  publicClient: client,
  walletClient,
});

/**
 * メインスクリプト
 */
async function main() {
  try {
    // 最後のブロックの番号を取得する
    const blockNumber = await client.getBlockNumber();
    console.log("Current Block Number:", blockNumber);
    // ウォレットの残高を取得する
    const balance = await client.getBalance({address: account.address});
    console.log(`Wallet's Balance: ${formatEther(balance)} ETH`);

    // hat ID
    const hatId = 442;
    console.log("getting hat info");
    // hatの情報を取得する。
    const hatInfo = await hatsClient.viewHat(BigInt(hatId));
    console.log("hatInfo:", hatInfo);
    // hatの着用者かどうかチェックする。
    const isWearer = await hatsClient.isWearerOfHat({
      wearer: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isWearer:", isWearer);
    // hatの管理者かどうかチェックする。
    const isAdmin = await hatsClient.isAdminOfHat({
      user: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isAdmin:", isAdmin);
    // 着用者が良好な状態にあるかチェックする。
    const isGoodStanding = await hatsClient.isInGoodStanding({
      wearer: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isGoodStanding:", isGoodStanding);
    // 適格な着用者であるかどうかチェックする。
    const isEligible = await hatsClient.isEligible({
      wearer: account.address,
      hatId: BigInt(hatId),
    });
    console.log("isEligible:", isEligible);
    // ツリーの数を取得する。
    const numTrees = await hatsClient.getTreesCount();
    console.log("numTrees:", numTrees);
    // 帽子のレベルを取得する。
    const level = await hatsClient.getHatLevel(BigInt(hatId));
    console.log("level:", level);
    // ローカルでの帽子のレベルを取得する。
    const localLevel = await hatsClient.getLocalHatLevel(BigInt(hatId));
    console.log("localLevel:", localLevel);
    // 帽子のドメインを取得する。
    const domain = await hatsClient.getTopHatDomain(BigInt(hatId));
    console.log("domain:", domain);
    // ツリーのリンクリクエストを取得します。
    const requestedAdminHat = await hatsClient.getLinkageRequest(domain);
    console.log("requestedAdminHat:", requestedAdminHat);
    // リンクされたツリーの管理者を取得する。
    const adminHat = await hatsClient.getLinkedTreeAdmin(domain);
    console.log("adminHat:", adminHat);
    // 指定されたツリーが含まれるグローバルツリーのトッパーハットのツリードメインを取得する。
    const tippyTopHatDomain = await hatsClient.getTippyTopHatDomain(domain);
    console.log("tippyTopHatDomain:", tippyTopHatDomain);
    // 帽子の管理者IDを取得する。
    const adminId = await hatsClient.getAdmin(BigInt(hatId));
    console.log("adminId:", adminId);
    // 指定したHatIdに紐づく子供の帽子を取得する。
    const children = await hatsClient.getChildrenHats(BigInt(hatId));
    console.log("childrens:", children);
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
```

`HatsClient`インスタンスを生成するために`chainID`や`publicClient`、オプションで`WalletClient`が必要になるのでそれらのインスタンスを`viem` のメソッドを利用して用意しています。

そしてあとはインスタンスを生成させメソッドを呼び出しているだけの比較的シンプルな実装になっています！！

次に SubgraghのSDKの機能を試すサンプルスクリプトを実行してみたいと思います！！

```bash
yarn sample subgraph
```

以下のような結果が返ってくるのではないでしょうか？

```bash
hat: {
  id: '0x0000000100020001000100000000000000000000000000000000000000000000',
  maxSupply: '1000',
  wearers: [
    { id: '0x0040daac32d83c78546ae36da42a496b28ab09e1' },
    { id: '0x0109c7e6604b96af83ca272bcf84645ed29e7154' },
    { id: '0x011e0be1128af8c51646181368589ccfbddf746a' },
    { id: '0x017ff2643e1a6d500a54e2c15f8186c87795cbbe' },
    { id: '0x018e494352a3e68e16d03ed976fd64134bd82e72' },
    { id: '0x020f64f264ab7e90ef24a108c379a796a82175df' },
    { id: '0x03b79c0c1487a68aeabd9aa4ce779dad77855f52' },
    { id: '0x03f33bb5e7ca4fee122b1b443cebf2ed265c434a' },
    { id: '0x03f7a3fd58b090abe577651fb92fb4789826191e' },
    { id: '0x04ce3ca877bdbb2faffa63f9eee55d7d639a1700' },
    { id: '0x051ac9d0442d5c689e6a301bebc82821f42fc93a' },
    { id: '0x05a1ff0a32bc24265bcb39499d0c5d9a6cb2011c' },
    { id: '0x063560d831876c9bcebdb1ac48d81815e45a0ab9' },
    { id: '0x071e1682748679cdef2fe3e1fcfb23b8b9d13a03' },
    { id: '0x0731f454cb8682d0176ff28e413b0eba42cc82b0' },
    { id: '0x07f6c379bf06113f7f445317de2238d03911b9e6' },
    { id: '0x088e6beb2bb157940c44440578cf07072eba1cd8' },
    { id: '0x0a453f46f8ae9a99b2b901a26b53e92be6c3c43e' },
    { id: '0x0b06ca5dcc8a10be0951d4e140d4312702b8d0ec' },
    { id: '0x0b5f5a722ac5e8ecedf4da39a656fe5f1e76b34c' },
    { id: '0x0c887420937d8f9305ff872eaa5aaf5e379a811a' },
    { id: '0x0d89421d6eec0a4385f95f410732186a2ab45077' },
    { id: '0x0e11de3e815491b1383d2b9c4f99095c20b5bd90' },
    { id: '0x0ea26051f7657d59418da186137141cea90d0652' },
    { id: '0x0f07d407ac41d6dbb2cf237b0704c0ab5b9b8754' },
    { id: '0x0f1d41cc51e97dc9d0cad80dc681777eed3675e3' },
    { id: '0x0f3332af122adab1b5897b21a72315eb06ebdb31' },
    { id: '0x108c1f6802c6d991fcec033294787c08d718f445' },
    { id: '0x1233d45017d270d7ecc07494cb86d3e8dda643a0' },
    { id: '0x1235ce8f885ccca020740c1fc83b221e693bb5ff' },
    { id: '0x1253594843798ff0fcd7fa221b820c2d3ca58fd5' },
    { id: '0x1296b0a992abc44675ff6800dd86696dc9366490' },
    { id: '0x12c5b6d18536abc4766af3c2612b87eb75ec10d5' },
    { id: '0x13c877de8a85255454620ffc002cfa9ca12dcfc2' },
    { id: '0x140b4cbd81d7ceb0adfc96e5c2d640ae39ddfa22' },
    { id: '0x1421d52714b01298e2e9aa969e14c9317b3e1cfa' },
    { id: '0x143ba1aebe867c46fd48347f8da0ecdca046a40f' },
    { id: '0x177d688b3e49e3a1039e3de50d392e48cb6ca869' },
    { id: '0x178f420637c6667ba467041dd62d93e39ea1f232' },
    { id: '0x17e33637f6b64e9082ea499481b6e6ebae7eea23' },
    { id: '0x19ba17c6969b82642bceccfdfb48df9ea844e18c' },
    { id: '0x1a9cee6e1d21c3c09fb83a980ea54299f01920cd' },
    { id: '0x1aa5b637f5283a9fe53771762fc8f6f0f2d87b79' },
    { id: '0x1ad37c45ebbd03caf2551c22541d7d5e4d8aadab' },
    { id: '0x1b0132aa8db835738ee33f83d67d5a14c532b65d' },
    { id: '0x1b2c142ae4b9c72d2b8957079563d171b7f72892' },
    { id: '0x1b784725944ee55eb74f41e29d1262a0dd4d9135' },
    { id: '0x1c51517d8277c9ad6d701fb5394cec0c18219edb' },
    { id: '0x1c9f765c579f94f6502acd9fc356171d85a1f8d0' },
    { id: '0x1d3bf13f8f7a83390d03db5e23a950778e1d1309' },
    { id: '0x1da44dc5bd3ccad7c9de272a58b5507f5bc251fa' },
    { id: '0x1df428833f2c9fb1ef098754e5d710432450d706' },
    { id: '0x1e7f92540941f9539be4dbd2d7652ddce7a05a71' },
    { id: '0x1e8f9d26cf0808168e02450508991fd9c594426d' },
    { id: '0x1fde40a4046eda0ca0539dd6c77abf8933b94260' },
    { id: '0x1feadfd0e023318da5a0024e28b3a87ca5e5886d' },
    { id: '0x223da87421786dd8960bf2350e6c499bebca64d1' },
    { id: '0x224aba5d489675a7bd3ce07786fada466b46fa0f' },
    { id: '0x23db246031fd6f4e81b0814e9c1dc0901a18da2d' },
    { id: '0x2487fc7e019860afbfc7fb16689e421843c777e2' },
    { id: '0x24f193262c575a66d729334f57bdf82d8aff74cb' },
    { id: '0x25910143c255828f623786f46fe9a8941b7983bb' },
    { id: '0x26165f32607d3f8bee6cd5f0c58e94df77291af3' },
    { id: '0x26250d5b0265a9df5f59b9086cab1095254d38b1' },
    { id: '0x266e7f99787676a24a42c15bfbd7b1b734e99c4d' },
    { id: '0x26e3a9c84fdb9b7fe33dfd5e8d273d016e4e4fb6' },
    { id: '0x270de0ae1bef06d1de5cdbdcf411357f5784ed2e' },
    { id: '0x2758b8b35d2df81f764a909efc3b6aca547d7147' },
    { id: '0x27773b203954fbbb3e98dfa1a85a99e1c2f40f56' },
    { id: '0x289bded2521b51167da31752a5b121a52aa1e4b5' },
    { id: '0x29185eb8cfd22aa719529217bfbade61677e0ad2' },
    { id: '0x29864e4d1588c4164dee7cc495147ec141f9c9d5' },
    { id: '0x2a045211d7d1167d6f5f5812959fa9613f58df8a' },
    { id: '0x2abec368577257cee4b1197337b5491d4d9ed578' },
    { id: '0x2c2e67a4c5ea3335408406503844d4879c84a9f6' },
    { id: '0x2c2ebecd11077849d244263e6a5bcdf702a2664d' },
    { id: '0x2c64f2ccc998613a69b667623f65aeb75e157a24' },
    { id: '0x2cbd785ae43f796e29d4f15c5f16502de6292361' },
    { id: '0x2cc5fbc2d537e5bcd24c9782486a3014e029b1fb' },
    { id: '0x2d4ac9c27fffcd87d7fa2619f537c7eb0db96fb7' },
    { id: '0x2da2b7a81f6105a7e82816f1eb058fb5225e6e51' },
    { id: '0x2e29c9750a203eed22c037061f5fd801f6e1429f' },
    { id: '0x2e57674ea14fa08a6dda865dd139ce3924ab5951' },
    { id: '0x2fb523a295a3b194ee24dc358ba98865e61af6de' },
    { id: '0x3057a4c65d58a632dc76cff4bbe1fd97960b7053' },
    { id: '0x30a07def8043614ebb1f9d239841bb8292ffa2f9' },
    { id: '0x30cf7cb2fe80d394086dab29e1b569e0ddf0a8c0' },
    { id: '0x3219f726edfe8cdc2844bbd08025a33339b8084b' },
    { id: '0x32285e4de7ec54df85572851a2dd1bf191f2651e' },
    { id: '0x327c780114d157bee5780d56d62cfee6d8dc603e' },
    { id: '0x330a1b029a0c41b749b43274c992d535d714bf2c' },
    { id: '0x33785892bb8d9926b8e11dca233bdfce3e331aca' },
    { id: '0x34b7103905aad8a763bf8818cda22e5e9af72624' },
    { id: '0x3659c2cfb2d95cbbcbbcd45f2a41e6d7325f6436' },
    { id: '0x3803e8b525ae9fa18977f964f483598090d5084c' },
    { id: '0x38958f8b2ae828eca1e2a30c8e931d224cada075' },
    { id: '0x39b8edbc6d6bab985bf03b498166db588c00278e' },
    { id: '0x3b48e557d2145fa6df280d2b52f66aa46a3635a3' },
    { id: '0x3b60e31cfc48a9074cd5bebb26c9eaa77650a43f' },
    { id: '0x3c41f941098681bfdb14ed423709cc7c29c1e5e6' }
  ],
  events: [
    {
      id: 'HatMinted-123816594-0',
      transactionID: '0x2e55ee62c212a98eca82bcd75cdddadef8e476eda81402f06a5b93b8755a38a6',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123813523-24',
      transactionID: '0xc3226c1c39531684b1ef6e7cd83a0031720cc7c6e4627f0f4b897dd175435938',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123811781-26',
      transactionID: '0xad9c4c0893fc5606b83786f4994c4a5300564959d8e3511c842ee37837ac87b7',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123802820-5',
      transactionID: '0xc25e4060ab07dd5d6369fabe102675e598730d988536d2c151fef9eed54ebef6',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123800034-73',
      transactionID: '0xcadc2ef1ca95d9e696ff0d6904bd62a9cd4bf7a7e4403097343220cd0b0b4dda',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123755840-19',
      transactionID: '0x5bfa04d7f973140a5f6a9738897b4dfddf676541dd7ff7d6dc55d25562709617',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123734644-66',
      transactionID: '0xf0cb23ad32cb5f713ead9a8144c86c32f816e3a1b52a01fe1a07238fb909053f',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123733570-8',
      transactionID: '0xbbf3565f4700e068825a4dfa4e9a22a3e00be2eca4a3fc57a393bddcb5174442',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123701721-0',
      transactionID: '0xe835a75c74374eb89e47717503521c2934f9924ed62aff8c93a749c5c89a0f03',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    },
    {
      id: 'HatMinted-123691901-49',
      transactionID: '0xcd8e0dd7964f0e4ed5154925970f628e8b261ec5e6975d4c0fd10964fe54f56f',
      __typename: 'HatMintedEvent',
      wearer: [Object],
      operator: '0xd0929e6ae5406cbee08604de99f83cf2ce52d903'
    }
  ]
}
hatsByIds: [
  {
    id: '0x0000000100020001000000000000000000000000000000000000000000000000',
    wearers: [ [Object], [Object] ]
  },
  {
    id: '0x0000000100020001000100000000000000000000000000000000000000000000',
    wearers: [
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
]
Done in 3.05s.
```

コードは以下の通りです！！

Subgraph用のインスタンスを生成し、取得したい情報を定義してメソッドを実行するだけです！

```ts
import {HatsSubgraphClient} from "@hatsprotocol/sdk-v1-subgraph";
import {optimism, sepolia} from "viem/chains";

// Subgraph用のインスタンスを生成
const hatsSubgraphClient = new HatsSubgraphClient({
  config: {
    [sepolia.id]: {
      endpoint:
        "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest",
    },
    [optimism.id]: {
      endpoint:
        "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest",
    },
  },
});

/**
 * メインスクリプト
 */
const main = async () => {
  // hatの情報を取得する。
  const hat = await hatsSubgraphClient.getHat({
    chainId: 10, // optimism
    hatId: BigInt(
      "0x0000000100020001000100000000000000000000000000000000000000000000"
    ),
    props: {
      maxSupply: true, // get the maximum amount of wearers for the hat
      wearers: {
        // get the hat's wearers
        props: {}, // for each wearer, include only its ID (address)
      },
      events: {
        // get the hat's events
        props: {
          transactionID: true, // for each event, include the transaction ID
        },
        filters: {
          first: 10, // fetch only the latest 10 events
        },
      },
    },
  });

  console.log("hat:", hat);

  // サンプル用のクエリを実行する
  const res = await hatsSubgraphClient.getHatsByIds({
    chainId: 10, // optimism
    hatIds: [
      BigInt(
        "0x0000000100020001000100000000000000000000000000000000000000000000"
      ),
      BigInt(
        "0x0000000100020001000000000000000000000000000000000000000000000000"
      ),
    ],
    props: {
      wearers: {
        // get each hat's wearers
        props: {
          currentHats: {
            // for each wearer, get its hats
            props: {}, // for each hat, include only its ID
          },
        },
      },
    },
  });

  console.log("hatsByIds:", res);
};

main();
```

次にTopHatをミントするスクリプトを実行してみます！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/mintTopHat.ts

```bash
yarn sample mintTopHat
```

すると以下のような結果が返ってきたのではないでしょうか？

```bash
mintTopHatResult: {
  status: 'success',
  transactionHash: '0xadcb165c2a65f6a0b348a0387c4cc5426cf59607585ce32e486454efaf5b977a',
  hatId: 12078056106883486628010822758984794541789440701298176471534417391648768n
}
```

https://sepolia.etherscan.io/tx/0xadcb165c2a65f6a0b348a0387c4cc5426cf59607585ce32e486454efaf5b977a

次にHatを作るスクリプトを実装してみようと思います！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/createHat.ts

```bash
yarn sample createHat
```

```bash
createHatResult: {
  status: 'success',
  transactionHash: '0x2d0a7c492a0ba9a49ab6fda97bfb329a6a22dff6c27f65670ab97fe229b03898',
  hatId: 12078056518259625958312333297727090181127066946982142879929383228801024n
}
```

https://sepolia.etherscan.io/tx/0x2d0a7c492a0ba9a49ab6fda97bfb329a6a22dff6c27f65670ab97fe229b03898

まとめてHatを作るスクリプトも試してみます！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/batchCreateHats.ts

```bash
yarn sample batchCreateHats
```

```bash
batchCreateHatsResult: {
  status: 'success',
  transactionHash: '0xaa70d7e8bf6e7eaf2ee586297a93892942b6db0385a90f11f117de9826fd6654',
  hatIds: [
    12078056929635765288613843836469385820464693192666109288324349065953280n
  ]
}
```

https://sepolia.etherscan.io/tx/0xaa70d7e8bf6e7eaf2ee586297a93892942b6db0385a90f11f117de9826fd6654


次に作ったHatをミントするスクリプトを実行してみます！！

ソースコードはこちらです。

https://github.com/mashharuki/HatsProtocolSample/blob/main/pkgs/sample/src/mintHat.ts

```bash
yarn sample mintHat
```

```bash
mintTopHatResult: {
  status: 'success',
  transactionHash: '0x734483b0ebba7e8ad3a75c263a1e0742e61215fb33afae2feb06356fce30987c'
}
```

https://sepolia.etherscan.io/tx/0x734483b0ebba7e8ad3a75c263a1e0742e61215fb33afae2feb06356fce30987c


### 参考文献
1. [HatsProtocol 公式サイト](https://www.hatsprotocol.xyz/)
2. [HatsProtocol - Docs](https://docs.hatsprotocol.xyz/)
3. [HatsProtocol - App](https://app.hatsprotocol.xyz/)
4. [GitHub - HatsProtocol](https://github.com/Hats-Protocol)
5. [GitHub - HatsProtocol/create-hats-app](https://github.com/Hats-Protocol/create-hats-app)
6. [HatsProtocol - Blog](https://blog.hatsprotocol.xyz/)
7. [GitHub - HatsProtocol/v1-subgraphs](https://docs.hatsprotocol.xyz/for-developers/v1-subgraphs)