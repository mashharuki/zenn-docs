---
title: "x402 ã¨ Walrus ã® MCP ã‚’ä½œã£ã¦ã¿ãŸï¼AI Agent æ™‚ä»£ã®åˆ†æ•£å‹æ±ºæ¸ˆãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸çµ±åˆã‚¬ã‚¤ãƒ‰ ğŸš€"
emoji: "ğŸ› "
type: "tech"
topics: ["Web3", "AI", "MCP", "Mastra", "ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚³ã‚¤ãƒ³"]
published: true
---

![](/images/x402_walrus_mcp/title.png)

## ã¯ã˜ã‚ã« ğŸ’¡

Web3 æ¥­ç•Œã§ã¯æœ€è¿‘ã€AI Agent ã¨ Web3 ã®æ©Ÿèƒ½ã®é€£æºãŒéå¸¸ã«ãƒ›ãƒƒãƒˆãªè©±é¡Œã¨ãªã£ã¦ã„ã¾ã™ï¼

å…ˆæ—¥ã¾ã§ **Sui** ã¨ã„ã†ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã§é–‹å‚¬ã•ã‚Œã¦ã„ãŸã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒƒã‚«ã‚½ãƒ³ **Sui Overflow** ã«å‚åŠ ã—ã¦ã„ãŸã®ã§ã™ãŒã€ãã“ã§ AI Agent ã¨ Web3 ã®çµ„ã¿åˆã‚ã›ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ã¦ã¿ã¾ã—ãŸï¼

https://sui.io/overflow

ä»Šå›ã®ãƒãƒƒã‚«ã‚½ãƒ³ã§ã€ **x402ï¼ˆHTTP ä¸Šã§ã®å³åº§ã® stablecoin æ±ºæ¸ˆã‚’å¯èƒ½ã«ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼‰** ã¨ **Walrusï¼ˆåˆ†æ•£å‹ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ï¼‰** ã‚’çµ„ã¿åˆã‚ã›ãŸ **MCPï¼ˆModel Context Protocolï¼‰ã‚µãƒ¼ãƒãƒ¼** ã‚’ä½œæˆã—ã¾ã—ãŸï¼ï¼

https://github.com/AO-protocol/overflow2025

ã•ã‚‰ã«è‡ªä½œã—ãŸ MCP ã‚’ **Mastra** ã®ä¸­ã«çµ„ã¿è¾¼ã‚€ã¨ã“ã‚ã¾ã§ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ã¦ã¿ãŸã®ã§ãã®æ™‚ã«åˆ†ã‹ã£ãŸã“ã¨ãªã©ã‚’ãƒ–ãƒ­ã‚°è¨˜äº‹ã«ã¾ã¨ã‚ã¾ã—ãŸï¼ï¼

ã“ã®è¨˜äº‹ã§ã¯ã€å®Ÿéš›ã«å‹•ãã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè£…ã‚’é€šã˜ã¦ã€ã“ã‚Œã‚‰ã®æŠ€è¡“ã‚’ã©ã†çµ„ã¿åˆã‚ã›ã‚‹ã‹ã‚’è©³ã—ãè§£èª¬ã—ã¾ã™ã€‚

ãœã²æœ€å¾Œã¾ã§èª­ã‚“ã§ã„ã¦ãã ã•ã„ï¼

## å®Ÿè£…ã—ãŸã‚‚ã®ã®æ¦‚è¦ ğŸ“‹

ä»Šå›ä½œæˆã—ãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ä»¥ä¸‹ã®æ§‹æˆã«ãªã£ã¦ã„ã¾ã™ï¼š

- **Frontend**: Next.js 15 + React 19 ã«ã‚ˆã‚‹ PWA ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
- **Backend**: Hono ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ™ãƒ¼ã‚¹ã® API ã‚µãƒ¼ãƒãƒ¼
- **MCP Server**: x402 ã¨ Walrus ã‚’çµ±åˆã—ãŸ Model Context Protocol å®Ÿè£…
- **Mastra çµ±åˆ**: AI Agent ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ Mastra ã¨ã®é€£æº

## ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã®ãƒ‡ãƒ¢å‹•ç”»

MCP åŒ–ã—ãŸã®ã§ **Mastra** ã‹ã‚‰å‘¼ã³å‡ºã™ä»¥å¤–ã« **GitHub Copilot Agent Mode** ã‹ã‚‰å‘¼ã³å‡ºã—ãŸã‚Šã—ã¦ã¿ã¾ã—ãŸï¼

ãã®ãƒ‡ãƒ¢å‹•ç”»ã‚’ä»¥ä¸‹ã® X ã®æŠ•ç¨¿ã«ã¦å…¬é–‹ã—ã¦ã„ã¾ã™ã®ã§ãœã²ã“ã¡ã‚‰ã‚‚ã¿ã¦ãã ã•ã„ï¼

https://x.com/ao_protocol/status/1925772185815163208

## x402 ã¨ã¯ï¼Ÿ ğŸ’³

x402 ã¯ã€HTTP ä¸Šã§ stablecoin ã«ã‚ˆã‚‹å³åº§ã®æ±ºæ¸ˆã‚’å¯èƒ½ã«ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚å¾“æ¥ã® Web æ±ºæ¸ˆã®èª²é¡Œã‚’è§£æ±ºã™ã‚‹ç”»æœŸçš„ãªä»•çµ„ã¿ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªç‰¹å¾´ãŒã‚ã‚Šã¾ã™ï¼š

### x402 ã®ä¸»ãªç‰¹å¾´

- **ğŸŒ HTTP é€šä¿¡ã®ä¸­ã«æ±ºæ¸ˆãƒ•ãƒ­ãƒ¼ã‚’å·®ã—è¾¼ã‚ã‚‹**:  
  ãšã£ã¨å‰ã‹ã‚‰å­˜åœ¨ã—ãŸ HTTP ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ **402** ã‚’åˆ©ç”¨ã—ãŸæ±ºæ¸ˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚  
  æ—¢å­˜ã® HTTP é€šä¿¡ã®ä¸­ã«è‡ªç„¶ãªå½¢ã§æ±ºæ¸ˆãƒ•ãƒ­ãƒ¼ã‚’å·®ã—è¾¼ã‚ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼ï¼
- **ğŸ› ï¸ ç°¡å˜çµ±åˆ**:  
  æ—¢å­˜ã® Web ã‚µãƒ¼ãƒãƒ¼ã‚¹ã‚¿ãƒƒã‚¯ã« 1 è¡Œã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚³ãƒ¼ãƒ‰ã‚„è¨­å®šã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§æ±ºæ¸ˆã‚’å—ã‘ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚
- **AI Agent ã¨ã®ç›¸æ€§æŠœç¾¤**ï¼š  
  AI Agent ã¨ã‚‚ç›¸æ€§æŠœç¾¤ã§ã™ã€‚å…¬å¼ã‹ã‚‰ MCP ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚‚å…¬é–‹ã•ã‚Œã¦ãŠã‚Šã€è‡ªå‹•çš„ã«æ”¯æ‰•ã„å‡¦ç†ã‚’å®Ÿè¡Œã•ã›ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

### x402 ã®æŠ€è¡“çš„ãªä»•çµ„ã¿

x402 ã¯ã€é•·ã„é–“ä½¿ã‚ã‚Œã¦ã„ãªã‹ã£ãŸ **HTTP 402ã€ŒPayment Requiredã€** ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å¾©æ´»ã•ã›ã€Web ã‚µã‚¤ãƒˆã«æ±ºæ¸ˆã‚’åŸ‹ã‚è¾¼ã‚€ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã‚„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ä½¿ç”¨ãŒä¸è¦ã«ãªã‚Šã¾ã™ã€‚

## Walrus ã¨ã¯ï¼Ÿ ğŸ¦­

Walrus ã¯ã€å‹•ç”»ã€ç”»åƒã€PDF ãªã©ã®å¤§å®¹é‡ãƒ‡ãƒ¼ã‚¿ã‚„ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã€èª­ã¿å–ã‚Šã€ç®¡ç†ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ãã‚‹åˆ†æ•£å‹é–‹ç™ºãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã™ã€‚

### Walrus ã®ä¸»ãªç‰¹å¾´

- **ğŸ“¦ åŠ¹ç‡çš„ãªåˆ†æ•£ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**: ã‚¤ãƒ¬ã‚¤ã‚¸ãƒ£ãƒ¼ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®é©æ–°ã‚’æ´»ç”¨ã—ã€éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ãƒ–ãƒ­ãƒ–ã‚’å°ã•ãªã‚¹ãƒ©ã‚¤ãƒãƒ¼ã«é«˜é€Ÿã§å …ç‰¢ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒ¼ãƒ‰ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸Šã«åˆ†æ•£ãƒ»ä¿å­˜ã—ã¾ã™
- **ğŸ”„ é«˜ã„å†—é•·æ€§**: ã‚¹ãƒ©ã‚¤ãƒãƒ¼ã® 3 åˆ†ã® 2 ãŒæ¬ è½ã—ã¦ã„ã¦ã‚‚ã€ã‚µãƒ–ã‚»ãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¦å…ƒã®ãƒ–ãƒ­ãƒ–ã‚’è¿…é€Ÿã«å†æ§‹ç¯‰ã§ãã¾ã™
- **âš¡ Sui ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³çµ±åˆ**: Sui ã¯ã€Walrus ãŒã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã®å°‚ç”¨ç®¡ç†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æä¾›ã—ã€é«˜é€Ÿãªã‚³ãƒ³ã‚»ãƒ³ã‚µã‚¹ã€ã‚³ãƒ³ãƒãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ã€ãŠã‚ˆã³ Sui ä¸Šã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’çµ±åˆã™ã‚‹æ©Ÿä¼šã‚’æä¾›ã—ã¾ã™
- **ğŸ’° ã‚³ã‚¹ãƒˆåŠ¹ç‡**: Filecoin ã‚„ Arweave ã¨æ¯”è¼ƒã—ã¦æœ€å¤§ 80%ã®ã‚³ã‚¹ãƒˆå‰Šæ¸›ã‚’å®Ÿç¾

Walrus ã¯ Sui ã«æœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ãŒã€RESTful API ã§ãã®æ©Ÿèƒ½ã‚’å‘¼ã³å‡ºã›ã‚‹ãŸã‚ä»–ã®ãƒã‚§ãƒ¼ãƒ³å‘ã‘ã® Dapp ã®ä¸­ã§ã‚‚ä½¿ã†ã“ã¨ãŒå¯èƒ½ã§ã™ï¼

**ETH Global Cannes** ã§ã‚‚ Walrus ã¯ã‚¹ãƒãƒ³ã‚µãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚’å‡ºã—ã¦ã„ã‚‹ã“ã¨ã‹ã‚‰ã‚‚ä»–ã®ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®é–‹ç™ºè€…ã«ä½¿ã£ã¦ã‚‚ã‚‰ãŠã†ã¨ã—ã¦ã„ã‚‹ã“ã¨ãŒä¼ºãˆã¾ã™ï¼

https://ethglobal.com/events/cannes/prizes#walrus

<br/>

ã¡ãªã¿ã« **Sui ã£ã¦ãªã‚“ã ã£ã‘ï¼Ÿï¼Ÿ** ã¨ã„ã†æ–¹ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚‚å‚è€ƒã«ã—ã¦ãã ã•ã„ï¼ï¼

https://zenn.dev/mashharuki/articles/9eaf96ede16d48

## MCPï¼ˆModel Context Protocolï¼‰ã¨ã¯ï¼Ÿ ğŸ¤–

MCP ã¯ã€AI Agent ãŒã•ã¾ã–ã¾ãªå¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã‚„ API ã¨é€£æºã™ã‚‹ãŸã‚ã®æ¨™æº–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚

Anthropic ç¤¾ãŒ 2024 å¹´ 11 æœˆã«æå”±ã—ãŸã‚‚ã®ã§ã€ãã®å¾Œ Google ãŒ MCP ã‚’è£œå®Œã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã‚ã‚‹ Agent2Agent Protocol ãŒç™ºè¡¨ã•ã‚Œã‚‹ãªã©äº‹å®Ÿä¸Šã®ãƒ‡ãƒ•ã‚¡ã‚¯ãƒˆã«ãªã£ã¦ã—ã¾ã„ã¾ã—ãŸã€‚

https://docs.anthropic.com/ja/docs/agents-and-tools/mcp

ä»Šå›ã®å®Ÿè£…ã§ã¯ã€AI Agent ãŒ Walrus ã¸ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ã€x402 ã«ã‚ˆã‚‹æ±ºæ¸ˆã¨çµ„ã¿åˆã‚ã›ã¦å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚

:::message
ãƒã‚¤ãƒ³ãƒˆã¯ãã‚Œã‚‰ã®å‡¦ç†ãŒå…¨ã¦è‡ªç„¶è¨€èªã§å‘¼ã³å‡ºã›ã¦ã—ã¾ã†ã¨ã“ã‚ã§ã™ï¼
:::

## å®Ÿè£…ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ ğŸ—ï¸

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

```
overflow2025/
â”œâ”€â”€ pkgs/
â”‚   â”œâ”€â”€ frontend/     # Next.js ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
â”‚   â”œâ”€â”€ backend/      # Backend ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆHonoä½¿ç”¨ï¼‰
â”‚   â””â”€â”€ mcp/          # Model Context Protocol å®Ÿè£…
```

### æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- **ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼**:
  - pnpm
- **ãƒ¢ãƒãƒ¬ãƒæ§‹é€ **:
  - pnpm workspaces
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**:
  - Next.js 15
  - React 19
  - TypeScript
  - PWA
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰(x402 ç”¨)**:
  - Hono
  - TypeScript
- **MCP**:
  - Model Context Protocol SDK
  - walrus RESTful API
- **ã‚³ãƒ¼ãƒ‰å“è³ª**:
  - Biome

## å®Ÿè£…è©³ç´° ğŸ”§

### 1. ç’°å¢ƒæ§‹ç¯‰

ã¾ãšã€å¿…è¦ãªç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¾ã™ï¼š

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒ­ãƒ¼ãƒ³
git clone https://github.com/AO-protocol/overflow2025.git
cd overflow2025

# ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pnpm install
```

### 2. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰è¨­å®šï¼ˆx402 çµ±åˆï¼‰

`pkgs/backend/.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ï¼š

å…¬å¼ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã®è¨­å®šæ–¹æ³•ã«å¾“ã„ã€ä»¥ä¸‹ã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¾ã™ã€‚

:::message
x402 ã® GitHub ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã‚‹ã¨ Avalanche ã®ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã«ã‚‚å¯¾å¿œã—ã¦ã„ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã—ãŸãŒã†ã¾ãå‹•ãã¾ã›ã‚“ã§ã—ãŸ...

ã‚„ã¯ã‚Šä¸€ç•ªæŒ™å‹•ãŒå®‰å®šã™ã‚‹ã®ã¯ base ã¨ base sepolia ã¿ãŸã„ã§ã™ã€‚
:::

```env
FACILITATOR_URL=https://x402.org/facilitator
NETWORK=base-sepolia
ADDRESS=<your_wallet_address>
```

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã§ã¯ã€Hono ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã—ã¦ x402 ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’çµ±åˆã—ã€æ±ºæ¸ˆæ©Ÿèƒ½ä»˜ãã® API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚

å…¬å¼ã®ã‚³ãƒ¼ãƒ‰ã‚’å‚è€ƒã« **CORS** ã®è¨­å®šã‚’åŠ ãˆã¦ä»Šå›ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå®Ÿè£…ã¨ã—ã¾ã—ãŸï¼

```ts
import { serve } from "@hono/node-server";
import { config } from "dotenv";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { Network, Resource, paymentMiddleware } from "x402-hono";
// Import walrus functions from relative paths

config();

const facilitatorUrl = process.env.FACILITATOR_URL as Resource;
const payTo = process.env.ADDRESS as `0x${string}`;
const network = process.env.NETWORK as Network;

if (!facilitatorUrl || !payTo || !network) {
  console.error("Missing required environment variables");
  process.exit(1);
}

const app = new Hono();

console.log("Server is running");

// CORS
app.use(
  cors({
    origin: ["*"],
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    exposeHeaders: ["Content-Length", "X-Requested-With"],
    maxAge: 600,
    credentials: true,
  })
);

app.use(
  paymentMiddleware(
    payTo,
    {
      "/download": {
        // x402ã‚’æä¾›ã•ã›ã‚‹APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆURLã‚’ã“ã“ã§æŒ‡å®šã™ã‚‹
        price: "$0.01", // ã„ãã‚‰è«‹æ±‚ã™ã‚‹ã‹ã‚’ã“ã“ã§æŒ‡å®šã™ã‚‹
        network, // é©ç”¨ã•ã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ã“ã“ã§æŒ‡å®šã™ã‚‹
      },
    },
    {
      url: facilitatorUrl,
    }
  )
);

// get download file API
app.get("/download", async (c) => {
  return c.json({
    resulut: "pay to download",
  });
});

// Use PORT from environment variable for Cloud Run compatibility
const port = process.env.PORT ? Number.parseInt(process.env.PORT, 10) : 4021;

serve({
  fetch: app.fetch,
  port,
});

console.log(`Server is running on port ${port}`);
```

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰éƒ¨åˆ†ã¯ä»¥ä¸Šã§ã™ï¼

**Cloud Run** ã¨ã‹ã«ã‚‚ãƒ‡ãƒ—ãƒ­ã‚¤ã§ãã‚ˆã†ã« Dockerfile ã‚‚ä½œã‚Šã¾ã—ãŸã®ã§èˆˆå‘³ã®ã‚ã‚‹æ–¹ã¯ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‹ã‚‰è¦‹ã¦ã¿ã¦ãã ã•ã„ï¼ï¼

https://github.com/AO-protocol/overflow2025/blob/main/pkgs/backend/Dockerfile

### 3. MCP Server è¨­å®š

æ¬¡ã« MCP ã‚µãƒ¼ãƒãƒ¼ã®å®Ÿè£…ã‚’è¦‹ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ï¼

Anthropic ç¤¾ãŒæä¾›ã—ã¦ã„ã‚‹ MCP ã® SDK ã‚’ä½¿ã£ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼

https://www.npmjs.com/package/@modelcontextprotocol/sdk/v/0.6.1

MCP ã‚µãƒ¼ãƒãƒ¼ã®æ ¸ã¨ãªã‚‹å®Ÿè£…éƒ¨åˆ†ï¼š

```typescript
// MCPã‚µãƒ¼ãƒãƒ¼ã®ä¸»è¦å®Ÿè£…ï¼ˆç°¡ç•¥åŒ–ï¼‰
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server(
  {
    name: "x402-walrus-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Walrusã¸ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    // ä»¥ä¸‹ã§AI AgentãŒå‘¼ã³å‡ºã›ã‚‹ãƒ„ãƒ¼ãƒ«ç¾¤ã‚’ç´°ã‹ãè¨­å®š
    tools: [
      {
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ„ãƒ¼ãƒ«
        name: "upload_to_walrus",
        description:
          "Upload file to Walrus decentralized storage with x402 payment",
        inputSchema: {
          type: "object",
          properties: {
            filePath: { type: "string", description: "Path to file to upload" },
            storagePeriod: {
              type: "number",
              description: "Storage period in epochs",
            },
          },
          required: ["filePath", "storagePeriod"],
        },
      },
      {
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ„ãƒ¼ãƒ«
        name: "download_from_walrus",
        description: "Download file from Walrus with x402 payment verification",
        inputSchema: {
          type: "object",
          properties: {
            blobId: { type: "string", description: "Walrus blob ID" },
            savePath: { type: "string", description: "Local save path" },
          },
          required: ["blobId", "savePath"],
        },
      },
    ],
  };
});
```

### 4. Walrus ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã®å®Ÿè£…

MCP ã§å®Ÿè£…ã—ãŸãƒ„ãƒ¼ãƒ«ã®ä¸­ã«ã¯ walrus ã® API ã‚’å‘¼ã³å‡ºã—ã¦å®Ÿéš›ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹æ©Ÿèƒ½ã‚‚å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼

ä»Šå›ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼

```typescript
/**
 * Script to upload files to Walrus
 */

import fetch from "node-fetch";
import fs from "node:fs";
import path from "node:path";

// Walrus settings
const AGGREGATOR = "https://aggregator.walrus-testnet.walrus.space";
const PUBLISHER = "https://publisher.walrus-01.tududes.com";

// Sui related settings
const SUI_NETWORK = "testnet";
const SUI_VIEW_TX_URL = `https://suiscan.xyz/${SUI_NETWORK}/tx`;
const SUI_VIEW_OBJECT_URL = `https://suiscan.xyz/${SUI_NETWORK}/object`;

/**
 * Function to upload a file to Walrus
 *
 * @param filePath Path of the file to be uploaded
 * @param numEpochs Storage duration (number of epochs)
 * @param sendTo Optional: Address to send the object to
 * @returns Upload information
 */
export async function uploadFile(
  filePath: string,
  numEpochs: number,
  sendTo?: string
): Promise<any> {
  console.log(`Uploading file: ${filePath}`);
  // Check if the file exists
  if (!fs.existsSync(filePath)) {
    console.log(`File does not exist: ${filePath}`);
    throw new Error(`File does not exist: ${filePath}`);
  }

  const fileContent = fs.readFileSync(filePath);
  const mimeType = getMimeType(filePath);

  console.log(`Uploading file: ${filePath}`);
  console.log(`MIME Type: ${mimeType}`);
  console.log(`Storage duration: ${numEpochs} epochs`);

  // Construct the upload endpoint
  const sendToParam = sendTo ? `&send_object_to=${sendTo}` : "";
  const uploadUrl = `${PUBLISHER}/v1/blobs?epochs=${numEpochs}${sendToParam}`;

  console.log(`Uploading to: ${uploadUrl}`);

  try {
    // Upload the file with a PUT request
    const response = await fetch(uploadUrl, {
      method: "PUT",
      body: fileContent,
      headers: {
        "Content-Type": mimeType,
      },
    });

    if (response.status !== 200) {
      throw new Error(`Upload failed with status: ${response.status}`);
    }

    const resultData = await response.json();
    console.log("Upload successful!");

    // Process the response
    const storageInfo = processUploadResponse(
      resultData as Record<string, unknown>
    );
    return storageInfo;
  } catch (error) {
    console.error("Error uploading file:", error);
    throw error;
  }
}

/**
 * Function to process the upload response
 * @param response Response from the Walrus API
 * @returns Processed upload information
 */
function processUploadResponse(response: Record<string, unknown>): {
  status: string;
  blobId: string;
  endEpoch: number;
  suiRefType: string;
  suiRef: string;
  suiBaseUrl: string;
  blobUrl: string;
  suiUrl: string;
} {
  interface InfoType {
    status: string;
    blobId: string;
    endEpoch: number;
    suiRefType: string;
    suiRef: string;
    suiBaseUrl: string;
    blobUrl?: string;
    suiUrl?: string;
  }

  let info: InfoType;

  if (
    "alreadyCertified" in response &&
    typeof response.alreadyCertified === "object" &&
    response.alreadyCertified !== null
  ) {
    const certifiedData = response.alreadyCertified as Record<string, any>;
    info = {
      status: "Already certified",
      blobId: String(certifiedData.blobId || ""),
      endEpoch: Number(certifiedData.endEpoch || 0),
      suiRefType: "Previous Sui Certified Event",
      suiRef: String(
        (certifiedData.event as Record<string, any>)?.txDigest || ""
      ),
      suiBaseUrl: SUI_VIEW_TX_URL,
    };
  } else if (
    "newlyCreated" in response &&
    typeof response.newlyCreated === "object" &&
    response.newlyCreated !== null
  ) {
    const newData = response.newlyCreated as Record<string, any>;
    const blobObject = newData.blobObject as Record<string, any>;
    const storage = blobObject.storage as Record<string, any>;

    info = {
      status: "Newly created",
      blobId: String(blobObject.blobId || ""),
      endEpoch: Number(storage.endEpoch || 0),
      suiRefType: "Associated Sui Object",
      suiRef: String(blobObject.id || ""),
      suiBaseUrl: SUI_VIEW_OBJECT_URL,
    };
  } else {
    throw new Error("Unhandled successful response!");
  }

  // Add the blob URL
  info.blobUrl = `${AGGREGATOR}/v1/blobs/${info.blobId}`;
  info.suiUrl = `${info.suiBaseUrl}/${info.suiRef}`;

  return info as Required<InfoType>;
}

/**
 * Function to infer the MIME type from the file extension
 * @param filePath File path
 * @returns MIME type string
 */
function getMimeType(filePath: string): string {
  const extension = path.extname(filePath).toLowerCase();
  const mimeTypes: Record<string, string> = {
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".png": "image/png",
    ".gif": "image/gif",
    ".webp": "image/webp",
    ".pdf": "application/pdf",
    ".txt": "text/plain",
    ".json": "application/json",
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
  };

  return mimeTypes[extension] || "application/octet-stream";
}
```

ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼š

```typescript
/**
 * Script to download files from Walrus
 */

import axios from "axios";
import { config } from "dotenv";
import fetch from "node-fetch";
import fs from "node:fs";
import path from "node:path";
import type { Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { withPaymentInterceptor } from "x402-axios";

config();

const privateKey = process.env.PRIVATE_KEY as Hex;
const baseURL = process.env.RESOURCE_SERVER_URL as string; // e.g. https://example.com
const endpointPath = process.env.ENDPOINT_PATH as string; // e.g. /weather

if (!privateKey || !baseURL || !endpointPath) {
  throw new Error("Missing environment variables");
}

// Create a wallet client to handle payments
const account = privateKeyToAccount(privateKey);

// Create an axios client with payment interceptor using x402-axios
const client = withPaymentInterceptor(axios.create({ baseURL }), account);

// Walrus settings
const AGGREGATOR = "https://aggregator.walrus-testnet.walrus.space";

/**
 * Script to download files from Walrus
 *
 * @param blobId Download Blob ID
 * @param outputPath Save path
 * @returns Downloaded file paths and information
 */
export async function downloadFile(
  blobId: string,
  outputPath?: string
): Promise<any> {
  const downloadUrl = `${AGGREGATOR}/v1/blobs/${blobId}`;

  console.log(`Downloading blob: ${blobId}`);
  console.log(`Download URL: ${downloadUrl}`);

  try {
    // pay via x402
    const res = await client.get(endpointPath);
    console.log("x402 response status", res.status);
    console.log("x402 response data", res.data);
    // Download Blob with GET request
    const response = await fetch(downloadUrl);

    if (response.status !== 200) {
      throw new Error(`Download failed with status: ${response.status}`);
    }

    // Get Content-Type from response header
    const contentType =
      response.headers.get("content-type") || "application/octet-stream";
    const buffer = await response.arrayBuffer();
    const fileData = Buffer.from(buffer);

    // Generates a temporary file name if no output path is specified
    const finalOutputPath =
      outputPath ||
      path.join(
        process.cwd(),
        `downloaded-${blobId.substring(0, 8)}${getExtensionFromMime(
          contentType
        )}`
      );

    // Save File
    fs.writeFileSync(finalOutputPath, fileData);

    console.log(`File downloaded successfully to: ${finalOutputPath}`);

    // Create basic result object
    const result = {
      filePath: finalOutputPath,
      blobId,
      contentType,
      size: fileData.length,
      metadata: null,
    };

    try {
      // Retrieve metadata (optional - continue processing if failed)
      const metadataUrl = `${AGGREGATOR}/v1/blobs/${blobId}/info`;
      console.log(`Fetching metadata from: ${metadataUrl}`);

      const metadataResponse = await fetch(metadataUrl);

      if (metadataResponse.status === 200) {
        const responseText = await metadataResponse.text();
        if (responseText && responseText.trim().length > 0) {
          try {
            result.metadata = JSON.parse(responseText);
            console.log("Metadata retrieved successfully");
          } catch (parseError) {
            console.warn(
              `Error parsing metadata JSON: ${
                parseError instanceof Error
                  ? parseError.message
                  : String(parseError)
              }`
            );
            console.log(
              "Raw metadata response:",
              responseText.substring(0, 100) + "..."
            );
          }
        } else {
          console.warn("Metadata endpoint returned empty response");
        }
      } else {
        console.warn(
          `Metadata endpoint returned status: ${metadataResponse.status}`
        );
      }
    } catch (metadataError) {
      console.warn(
        `Failed to retrieve metadata: ${
          metadataError instanceof Error
            ? metadataError.message
            : String(metadataError)
        }`
      );
    }

    return result;
  } catch (error) {
    console.error("Error downloading file:", error);
    throw error;
  }
}

/**
 * Function to get the appropriate file extension from the MIME type
 */
function getExtensionFromMime(mimeType: string): string {
  const mimeToExtension: Record<string, string> = {
    "image/jpeg": ".jpg",
    "image/png": ".png",
    "image/gif": ".gif",
    "image/webp": ".webp",
    "application/pdf": ".pdf",
    "text/plain": ".txt",
    "application/json": ".json",
    "text/html": ".html",
    "text/css": ".css",
    "application/javascript": ".js",
  };

  return mimeToExtension[mimeType] || "";
}
```

## å®Ÿéš›ã®ä½¿ç”¨ä¾‹(GitHub Copilot) ğŸ¯

### MCP ã‚µãƒ¼ãƒãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«

ã¾ãšä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§ MCP ã‚µãƒ¼ãƒãƒ¼ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚

```bash
pnpm mcp build
```

### GitHub Copilot ã‹ã‚‰å‘¼ã³å‡ºã™ãŸã‚ã®è¨­å®š

ã¾ãšã€GitHub Copilot ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚

:::message
GitHub Copilot ã¯ **Agent Mode** ã‚’æŒ‡å®šã—ã¾ã—ã‚‡ã†ï¼ï¼
:::

æ¬¡ã«ã€ VSCode ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ« `settings.json` ã‚’é–‹ã„ã¦ MCP ã‚µãƒ¼ãƒãƒ¼ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®æ¬„ã«ä»¥ä¸‹ã®æƒ…å ±ã‚’è¿½åŠ ã—ã¾ã™ï¼

```json
{
  "x402-walrus": {
    "command": "node",
    "args": ["<absolute path to this repo>/dist/index.js"],
    "env": {
      "PRIVATE_KEY": "<private key of a wallet with USDC on Base Sepolia>", //AI Agentã«æ“ä½œæ¨©é™ã‚’å§”è¨—ã™ã‚‹ç§˜å¯†éµã‚’æŒ‡å®šã—ã¾ã™ã€‚
      "RESOURCE_SERVER_URL": "http://localhost:4021",
      "ENDPOINT_PATH": "/download"
    }
  }
}
```

ã“ã‚Œã§ãƒ„ãƒ¼ãƒ«ã‚’ Start ã•ã›ã‚‰ã‚Œã‚Œã°æº–å‚™ OK ã§ã™ï¼ï¼

**Claude Desktop** ã‹ã‚‰å‘¼ã³å‡ºã™å ´åˆã‚‚åŒã˜ã‚ˆã†ã«è¨­å®šã—ã¦ã‚ã’ã‚Œã° OK ã§ã™ï¼ï¼

å®Ÿéš›ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã¿ãŸãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã¯ãã‚Œãã‚Œä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‹ã‚‰ç¢ºèªã§ãã¾ã™ï¼ï¼

https://aggregator.walrus-testnet.walrus.space/v1/blobs/eY-foaTn9LTwqfxy0Q_wW4YURADxG_MZK-nrtjhSjGk

https://suiscan.xyz/testnet/object/0xe1ab4a998027e1d1fc4e7c919d126a0c8f6a5442f282a13c3c7d399d475b3d69

### ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰

```bash
# AI Agentã¨ã®ãƒãƒ£ãƒƒãƒˆä¾‹
User: "sample.txtãƒ•ã‚¡ã‚¤ãƒ«ã‚’Walrusã«10ã‚¨ãƒãƒƒã‚¯ä¿å­˜ã—ã¦ãã ã•ã„"

Agent: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’Walrusã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚x402ã«ã‚ˆã‚‹æ±ºæ¸ˆã‚’å®Ÿè¡Œä¸­..."
       "âœ… æ±ºæ¸ˆå®Œäº†: 0.01 USDC"
       "ğŸ“¦ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†"
       "ğŸ†” Blob ID: 0x1234...abcd"
       "â° ä¿å­˜æœŸé–“: 10ã‚¨ãƒãƒƒã‚¯"
```

### ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰

```bash
User: "Blob ID 0x1234...abcdã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„"

Agent: "Walrusã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™..."
       "ğŸ” æ±ºæ¸ˆæ¤œè¨¼å®Œäº†"
       "ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: downloaded_file.txt"
       "ğŸ“Š ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 1.2KB"
```

## å®Ÿéš›ã®ä½¿ç”¨ä¾‹(Mastra) ğŸ¯

**Mastra** ã‹ã‚‰å‘¼ã³å‡ºã™ã«ã¯ã€ãƒ„ãƒ¼ãƒ«ã®è¨­å®šã§ MCP ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«æŒ‡å®šã—ã¦ã‚ã’ã‚Œã° OK ã§ã™ï¼ï¼

### ãƒ„ãƒ¼ãƒ«ã®è¨­å®š

ä»Šå›ã¯ã€ mastra ãŒæä¾›ã—ã¦ã„ã‚‹ SDK ã‚’ä½¿ã£ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¨­å®šã‚’è¡Œã„ã¾ã—ãŸï¼

VS Code ã® `settings.json` ã§è¨­å®šã—ã¦ã„ã‚‹ã‚ˆã†ãªå†…å®¹ã§ã™ã­ã€‚

```ts
import { MCPClient } from "@mastra/mcp";

/**
 * Create MCP Client for file upload and download for Walrus
 * @returns MCPClient instance
 */
export const createWalrusMCPClient = () => {
  // create MCPClient instance
  // this mcp has 3 tools
  const mcpClient = new MCPClient({
    id: "x402-walrus-tools",
    servers: {
      walrus: {
        command: "node",
        args: [process.env.PATH_TO_MCP as string],
        env: {
          PRIVATE_KEY: process.env.PRIVATE_KEY as string,
          RESOURCE_SERVER_URL: "http://localhost:4021",
          ENDPOINT_PATH: "/download",
        },
        // @ts-expect-error server is not a function
        log: (logMessage: LogMessage) => {
          console.log(`[${logMessage.level}] ${logMessage.message}`);
        },
      },
    },
    timeout: 60000, // Timeout: 60 seconds
  });

  return mcpClient;
};

/**
 * Method to get only tools
 */
export const getwalrusMCPCTools = async () => {
  const walrusMCPClient = createWalrusMCPClient();
  // ãƒ„ãƒ¼ãƒ«ç¾¤ã‚’è¿”ã™
  return await walrusMCPClient.getTools();
};
```

### AI Agent ã®è¨­å®š

æ¬¡ã«ä¸Šè¨˜ã§å®šç¾©ã—ãŸãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ãª AI Agent ã‚’è¨­å®šã—ã¾ã™ã€‚

```ts
import { Agent } from "@mastra/core/agent";
import { fastembed } from "@mastra/fastembed";
import { LibSQLStore } from "@mastra/libsql";
import { Memory } from "@mastra/memory";
import { googleGemini } from "../models";

import fs from "node:fs";
// Basic memory setup
import path from "node:path";
import { getwalrusMCPCTools } from "../tools";

// Specify the database file path as an absolute path
const dbPath = path.resolve(process.cwd(), "src/mastra/db/mastra.db");
const dbDir = path.dirname(dbPath);

// Ensure the database directory exists
if (!fs.existsSync(dbDir)) {
  fs.mkdirSync(dbDir, { recursive: true });
  console.log(`Created database directory: ${dbDir}`);
}

// Set the SQLite connection string correctly
const memory = new Memory({
  embedder: fastembed,
  storage: new LibSQLStore({
    url: `file:${dbPath}`,
  }),
  options: {
    lastMessages: 40,
    semanticRecall: false,
    workingMemory: {
      enabled: true,
      use: "tool-call",
    },
    threads: {
      generateTitle: true,
    },
  },
});

/**
 * x402 And Walrus Agent
 */
export const x402WalrusAgent = new Agent({
  name: "x402 And Walrus Agent",
  instructions: `
    You are a supportive assistant that can help users upload and download files using Walrus.

    ## About Walrus
    Walrus is a file storage system built on blockchain (Sui) that allows for secure and decentralized file storage.
    Files uploaded to Walrus are stored for a specified epoch period (time units).

    ## Available Tools
    1. walrus_uploadFile - Upload files to Walrus
       - filePath: Path to the file you want to upload (required)
       - numEpochs: Number of epochs to store the file (required)
       - sendTo: Optional destination address

    2. walrus_downloadFile - Download files from Walrus to the local machine
       - blobId: The blobId of the file to download (required)
       - outputPath: Destination file path (optional)

    ## Usage Examples
    - Upload a file: "Please upload this file to Walrus and store it for 5 epochs"
    - Download a file: "Please download the file with blobId ABC123"

    ## How to Respond
    - Use the appropriate tool when the user wants to upload/download files
    - Ask for any missing parameters before performing file operations
    - After completing an operation, inform the user about its success and provide details (blobId, file path, etc.)
    - If an error occurs, explain the issue and possible solutions in clear language

    ## Limitations
    - Very large files may take longer to upload or fail
    - Supported file formats include common image, document, and data files
    - A blobId is required to download a file

    Always be helpful and courteous in your responses, and support users with their file operations.
  `,
  // model: claude,
  model: googleGemini,
  // @ts-expect-error this is a workaround for the type error
  memory: memory,
  tools: await getwalrusMCPCTools(),
});
```

### Mastra å…¨ä½“ã®è¨­å®š

ã‚ã¨ã¯ã‚‚ã†é€šå¸¸ã® Mastra ã®è¨­å®šã¨åŒã˜ã§ã™ã­ã€‚

`Mastra` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å®šç¾©ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ä»Šå›ç”¨æ„ã—ãŸ AI Agent ã‚’æŒ‡å®šã—ã¦ã‚ã’ã‚Œã° OK ã§ã™ï¼ï¼

```ts
import { createLogger } from "@mastra/core/logger";
import { Mastra } from "@mastra/core/mastra";

import { x402WalrusAgent } from "./agents";

/**
 * Create an instance for Mastra
 */
export const mastra = new Mastra({
  agents: { x402WalrusAgent }, // ã“ã“ã§ x402WalrusAgentã‚’ä½¿ã†ã‚ˆã†ã«æŒ‡å®šã™ã‚‹ã€‚
  logger: createLogger({
    name: "x402-walrus-Agent",
    level: "info",
  }),
});
```

å®Ÿè£…å†…å®¹ã®ç´¹ä»‹ã«ã¤ã„ã¦ã¯ä»¥ä¸Šã§ã™ï¼ï¼

## æŠ€è¡“çš„ãªå·¥å¤«ã¨èª²é¡Œ âš™ï¸

### å·¥å¤«ã—ãŸç‚¹

1. **æ±ºæ¸ˆã¨ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®çµ±åˆ**:  
   x402 ã¨ Walrus ã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ“ä½œã‚’è‡ªç„¶ã«çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã«æŒ‘æˆ¦ã—ã¦ã¿ã¾ã—ãŸï¼
2. **MCP æ¨™æº–æº–æ‹ **:  
   AI Agent ãŒæ¨™æº–çš„ãªæ–¹æ³•ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆ©ç”¨ã§ãã‚‹ã‚ˆã†è¨­è¨ˆã—ã¾ã—ãŸ
3. **ãƒ¢ãƒãƒ¬ãƒæ§‹æˆ**:  
   ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã€MCP ã‚µãƒ¼ãƒãƒ¼ã‚’åŠ¹ç‡çš„ã«ç®¡ç†ã§ãã‚‹æ§‹æˆã«ã—ã¾ã—ãŸ

### èª²é¡Œ

1. **MCP ã‚µãƒ¼ãƒãƒ¼ã®å®‰å®šæ€§**ï¼š

   ãƒ‡ãƒ¢å‹•ç”»ã ã¨ã†ã¾ãã„ã£ã¦ã„ã¾ã™ãŒã€æ¸¡ã™ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ã‚ˆã£ã¦ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œãªã‹ã£ãŸã‚Šã¨æŒ™å‹•ãŒå®‰å®šã—ã¾ã›ã‚“ã€‚

   ã“ã®ã‚ãŸã‚Šã¯ã¾ã ã¾ã èª¿æ•´ã—ã¦ã„ãå¿…è¦ãŒã‚ã‚Šãã†ã§ã™ã€‚

2. **ç§˜å¯†éµã®ä¿ç®¡ã®å•é¡Œ**ï¼š

   å®Ÿè£…å†…å®¹ã‚’è¦‹ã¦ **ã“ã‚Œã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çš„ã«å¤§ä¸ˆå¤«ã‹ï¼Ÿï¼Ÿ** ã¨æ€ã‚ã‚ŒãŸæ–¹ãŒã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚

   AI Agent ã«ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã®æ“ä½œæ¨©é™ã‚’ç§»è­²ã™ã‚‹ãŸã‚ã¨ã¯ã„ãˆã€ç§˜å¯†éµã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ™ã‚¿ãŒãã—ãŸã‚Šã™ã‚‹ã®ã¯ã¡ã‚‡ã£ã¨å±é™ºã‹ãªã¨...

   ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ã“ã¨ã‚’ç„¡è¦–ã™ã‚Œã°å‹•ãã‚‚ã®ã¯ã§ãã¾ã™ãŒã€ãã‚Œã§ã¯å®Ÿç”¨çš„ã¨ã¯è¨€ãˆã¾ã›ã‚“ã—ã€äººãŒç®¡ç†ã™ã‚‹ç§˜å¯†éµã¨åˆã‚ã›ã¦ **ãƒãƒ«ãƒã‚·ã‚°** ã®ã‚ˆã†ãªå½¢ã§ç®¡ç†ã™ã‚‹ä»•çµ„ã¿ã‹ **AWS Secret Manager** ã®ã‚ˆã†ãªç§˜åŒ¿æƒ…å ±ã‚’ä¿ç®¡ã™ã‚‹ã‚ˆã†ãªä»•çµ„ã¿ã®å°å…¥ãŒå¿…é ˆã ã¨æ„Ÿã˜ã¾ã—ãŸã€‚

## ä»Šå¾Œã®å±•æœ› ğŸ”®

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é€šã˜ã¦è¦‹ãˆã¦ããŸã€AI Agent æ™‚ä»£ã®åˆ†æ•£å‹ã‚¤ãƒ³ãƒ•ãƒ©ã®å¯èƒ½æ€§ã§ã™ï¼ï¼ï¼š

### çŸ­æœŸçš„ãªæ”¹å–„äºˆå®š

- **ğŸ”„ è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³æ™‚ã®è‡ªå‹•å¾©æ—§
- **ğŸ“Š ä½¿ç”¨é‡åˆ†æ**: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸åˆ©ç”¨çŠ¶æ³ã®ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
- **ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–**: ã‚ˆã‚Šå …ç‰¢ãªç§˜å¯†éµç®¡ç†
- **âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œã®æ”¹å–„

### é•·æœŸçš„ãªãƒ“ã‚¸ãƒ§ãƒ³

- **ğŸ¤– è¤‡æ•° AI Agent å¯¾å¿œ**: è¤‡æ•°ã® Agent ãŒå”èª¿ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚’å®Ÿè¡Œ
- **ğŸŒ ã‚¯ãƒ­ã‚¹ãƒã‚§ãƒ¼ãƒ³å¯¾å¿œ**: Ethereumã€Solana ç­‰ã¸ã®å¯¾å¿œæ‹¡å¼µ
- **ğŸ’ NFT çµ±åˆ**: ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®æ‰€æœ‰æ¨©ã‚’ NFT ã§ç®¡ç†
- **ğŸ“ˆ å‹•çš„ä¾¡æ ¼è¨­å®š**: ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚„éœ€è¦ã«å¿œã˜ãŸæŸ”è»Ÿãªèª²é‡‘

## ã¾ã¨ã‚ ğŸ‰

ä»Šå›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€x402 ã¨ Walrus ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€AI Agent ãŒè‡ªå¾‹çš„ã«æ±ºæ¸ˆã‚’è¡Œã„ãªãŒã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’åˆ©ç”¨ã§ãã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã—ãŸã€‚

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®ã“ã¨ãŒå®Ÿç¾ã§ãã¾ã—ãŸï¼ï¼ï¼ï¼š

- âœ… **ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ãªæ±ºæ¸ˆçµ±åˆ**: HTTP æ¨™æº–ã«åŸºã¥ãè‡ªç„¶ãªæ±ºæ¸ˆãƒ•ãƒ­ãƒ¼
- âœ… **åˆ†æ•£å‹ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®æ´»ç”¨**: å …ç‰¢ã§çµŒæ¸ˆçš„ãªãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
- âœ… **AI Agent å¯¾å¿œ**: MCP ã«ã‚ˆã‚‹æ¨™æº–çš„ãªãƒ„ãƒ¼ãƒ«é€£æº
- âœ… **å®Ÿç”¨çš„ãª UX**: Mastra ã«ã‚ˆã‚‹ç›´æ„Ÿçš„ãªãƒãƒ£ãƒƒãƒˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®Ÿè£…ï¼ï¼

Web3 æŠ€è¡“ã®å®Ÿç”¨åŒ–ãŒé€²ã‚€ä¸­ã§ã€ã“ã®ã‚ˆã†ãªçµ±åˆçš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒã€AI Agent ã®è‡ªå¾‹æ€§ã‚’ã‚ˆã‚Šé«˜ã‚ã€çœŸã«åˆ†æ•£åŒ–ã•ã‚ŒãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿç¾ã«è²¢çŒ®ã™ã‚‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

çš†ã•ã‚“ã‚‚ãœã²ã€ã“ã®ãƒªãƒã‚¸ãƒˆãƒªã‚’ fork ã—ã¦ã€ç‹¬è‡ªã® AI AgentÃ—Web3 ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã£ã¦ã¿ã¦ãã ã•ã„ï¼ ğŸš€

ã“ã“ã¾ã§èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼ï¼

---

## å‚è€ƒæ–‡çŒ® ğŸ“š

1. [AO-protocol/overflow2025 - GitHub](https://github.com/AO-protocol/overflow2025)
2. [x402 Whitepaper](https://www.x402.org/x402-whitepaper.pdf)
3. [x402 Ecosystem](https://www.x402.org/ecosystem)
4. [Coinbase x402 - GitHub](https://github.com/coinbase/x402)
5. [DeepWiki - Coinbase x402](https://deepwiki.com/coinbase/x402)
6. [Walrus Protocol](https://www.walrus.xyz/)
7. [Announcing Walrus - Mysten Labs Blog](https://www.mystenlabs.com/blog/announcing-walrus-a-decentralized-storage-and-data-availability-protocol)
8. [Coinbase x402 Launch](https://www.coinbase.com/developer-platform/discover/launches/x402)
9. [Zenn Markdown è¨˜æ³•ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆ](https://zenn.dev/activecore/articles/abbd797c5859c6)

---

_ã“ã®è¨˜äº‹ãŒãŠå½¹ã«ç«‹ã¡ã¾ã—ãŸã‚‰ã€ãœã²ãƒãƒ¼ãƒˆ â¤ï¸ ã‚„ã‚³ãƒ¡ãƒ³ãƒˆ ğŸ’¬ ã‚’ãŠé¡˜ã„ã—ã¾ã™ï¼_
