---
title: "DEXã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼LI.FIã‚’è©¦ã—ã¦ã¿ãŸï¼"
emoji: "ğŸ’°"
type: "tech" 
topics: ["Web3","blockchain","DEX","typescript","Ethereum"]
published: true
---

# ã¯ã˜ã‚ã«

å…ˆæ—¥ **ETH Global**ãŒä¸»å‚¬ã™ã‚‹**HackMoney2026**ã«å‚åŠ ã™ã‚‹æ©Ÿä¼šãŒã‚ã‚Š**LI.FI**ã¨ã„ã†DEXã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã«ã¤ã„ã¦èª¿ã¹ã‚‹æ©Ÿä¼šãŒã‚ã£ãŸã®ã§å­¦ã³ã‚’ã‚·ã‚§ã‚¢ã™ã‚‹ãŸã‚ã®è¨˜äº‹ã‚’æ›¸ãã¾ã—ãŸï¼

https://ethglobal.com/events/hackmoney2026

ãœã²æœ€å¾Œã¾ã§èª­ã‚“ã§ã„ã£ã¦ãã ã•ã„ï¼

:::message
**DEXã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã¨ã¯ï¼Ÿ**
 
Dè¤‡æ•°ã®åˆ†æ•£å‹å–å¼•æ‰€ï¼ˆDEXï¼‰ã‚’æ¨ªæ–­æ¤œç´¢ã—ã€æœ€ã‚‚æœ‰åˆ©ãªä¾¡æ ¼ã‚„ä½ã„æ‰‹æ•°æ–™ã§æš—å·è³‡ç”£ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ï¼ˆäº¤æ›ï¼‰ã§ãã‚‹ãƒ„ãƒ¼ãƒ«ã®ã“ã¨ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å„DEXã‚’æ‰‹å‹•ã§æ¯”è¼ƒã™ã‚‹æ‰‹é–“ãªãã€1inchã‚„Jupiterãªã©ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’é€šã˜ã¦ã€æœ€é©ãªãƒ¬ãƒ¼ãƒˆã‚’è‡ªå‹•ã§ç²å¾—ã§ãã¾ã™ã€‚ 
:::

# LI.FIã®å…¬å¼ã‚µã‚¤ãƒˆ

https://li.fi/

# ä»Šå›è©¦ã—ãŸã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰

ä»¥ä¸‹ã®GitHubãƒªãƒã‚¸ãƒˆãƒªã§å…¬é–‹ã—ã¦ã„ã¾ã™ï¼

https://github.com/mashharuki/lify-sample

# LI.FIã§ã‚„ã‚Œã‚‹ã“ã¨

é–‹ç™ºè€…ã¯LI.FIã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªæ©Ÿèƒ½ã‚’ç°¡å˜ã«ã‚¢ãƒ—ãƒªã«å®Ÿè£…ã§ãã¾ã™ã€‚

1. **ã‚¯ãƒ­ã‚¹ãƒã‚§ãƒ¼ãƒ³ã‚¹ãƒ¯ãƒƒãƒ— & ãƒ–ãƒªãƒƒã‚¸**
    - ç•°ãªã‚‹ãƒã‚§ãƒ¼ãƒ³é–“ã§ã®è³‡ç”£ç§»å‹•ã¨äº¤æ›ã‚’ãƒ¯ãƒ³ã‚¹ãƒˆãƒƒãƒ—ã§è¡Œãˆã¾ã™ã€‚
    - ä¾‹: Ethereumä¸Šã®**ETH**ã‚’ã€Baseä¸Šã®**USDC**ã«ç›´æ¥äº¤æ›ã€‚
  
2. **ã‚¹ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°**
    - è¤‡æ•°ã®DEXã€ãƒ–ãƒªãƒƒã‚¸ã€ã‚½ãƒ«ãƒãƒ¼ï¼ˆIntentãƒ™ãƒ¼ã‚¹ã®æµå‹•æ€§æä¾›è€…ï¼‰ã‚’æ¯”è¼ƒã—ã€æœ€ã‚‚æœ‰åˆ©ãªæ‰‹æ•°æ–™ã‚„ãƒ¬ãƒ¼ãƒˆã€æœ€é€Ÿã®ãƒ«ãƒ¼ãƒˆã‚’è‡ªå‹•çš„ã«é¸å®šã—ã¾ã™ã€‚

3. **ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«ãªæµå‹•æ€§ã‚¢ã‚¯ã‚»ã‚¹**
    - 35ä»¥ä¸Šã®ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ï¼ˆEVMã€Solanaã€Bitcoinã€SUIãªã©ï¼‰ã«å¯¾å¿œã€‚
    - Stargate, Across, Hopãªã©ã®ä¸»è¦ãªãƒ–ãƒªãƒƒã‚¸ã‚„ã€Uniswap, 1inchãªã©ã®DEXã‚’çµ±åˆã€‚

      > **å¯¾å¿œãƒã‚§ãƒ¼ãƒ³ã®ç¢ºèªæ–¹æ³•**
      >
      > ä»¥ä¸‹ã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å©ãã“ã¨ã§ã€ç¾åœ¨LI.FIãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãƒã‚§ãƒ¼ãƒ³ã®ä¸€è¦§ã‚’ç¢ºèªã§ãã¾ã™ã€‚
      >
      > ```bash
      > curl --request GET --url 'https://li.quest/v1/chains' --header 'accept: application/json'
      > ```

# LI.FIã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

LI.FIã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€Web3ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®UXã‚’åŠ‡çš„ã«å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼

- **ã‚¯ãƒ­ã‚¹ãƒã‚§ãƒ¼ãƒ³æ±ºæ¸ˆ**
  - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¿æœ‰ã™ã‚‹ä»»æ„ã®ãƒã‚§ãƒ¼ãƒ³ã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã€å•†å“ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã®æ”¯æ‰•ã„ã‚’å—ã‘ä»˜ã‘ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã€‚
- **DeFi Zaps (ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯é å…¥)**
  - é¢å€’ãªãƒ–ãƒªãƒƒã‚¸ã‚„ã‚¹ãƒ¯ãƒƒãƒ—ã®æ‰‹é †ã‚’çœç•¥ã—ã€ä»–ã®ãƒã‚§ãƒ¼ãƒ³ã«ã‚ã‚‹è³‡ç”£ã‚’ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§ç‰¹å®šã®DeFiãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆAaveã‚„Morphoãªã©ï¼‰ã«é ã‘å…¥ã‚Œã‚‹æ©Ÿèƒ½ã€‚
- **DEX/Bridge ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³**
  - è‡ªç¤¾ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚„ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªç®¡ç†ã‚¢ãƒ—ãƒªå†…ã«ã€æœ€é©ãªãƒ¬ãƒ¼ãƒˆã§ã®äº¤æ›æ©Ÿèƒ½ã‚’çµ„ã¿è¾¼ã‚€ã€‚
- **ã‚¬ã‚¹ä»£ã®æŠ½è±¡åŒ– (Gas Abstraction)**
  - ã‚¬ã‚¹ä»£ï¼ˆETHãªã©ï¼‰ã‚’æŒã£ã¦ã„ãªã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã‚‚ã€æ‰‹æŒã¡ã®USDCãªã©ã§ã‚¬ã‚¹ä»£ã‚’æ‰•ã„ãªãŒã‚‰ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã•ã›ã‚‹ã€‚

# SDKã¨APIã§æä¾›ã—ã¦ã„ã‚‹æ©Ÿèƒ½

LI.FIã¯ä¸»ã«**API**ã€**SDK**ã€**Widget**ã®3ã¤ã®å½¢æ…‹ã§æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚

### LI.FI API

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚„ç‹¬è‡ªã®ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æ§‹ç¯‰å‘ã‘ã€‚

- **Quote**:   
  ã‚¹ãƒ¯ãƒƒãƒ—ã‚„ãƒ–ãƒªãƒƒã‚¸ã®è¦‹ç©ã‚‚ã‚Šã¨ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã€‚
- **Status**:   
  ã‚¯ãƒ­ã‚¹ãƒã‚§ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®è¿½è·¡ã€‚
- **Tools**:   
  åˆ©ç”¨å¯èƒ½ãªãƒ–ãƒªãƒƒã‚¸ã‚„DEXã®ä¸€è¦§å–å¾—ã€‚

### LI.FI SDK (`@lifi/sdk`)

TypeScript/JavaScriptå‘ã‘ã®åŒ…æ‹¬çš„ãªé–‹ç™ºã‚­ãƒƒãƒˆã€‚

- **ã‚¦ã‚©ãƒ¬ãƒƒãƒˆé€£æº**:   
  Viemãªã©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ç°¡å˜ã«çµ±åˆå¯èƒ½ã€‚
- **ãƒ«ãƒ¼ãƒˆå®Ÿè¡Œ (Execute Route)**:   
  è¦‹ç©ã‚‚ã‚Šã®å–å¾—ã‹ã‚‰ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç½²åã€å®Œäº†ã¾ã§ã®ãƒ•ãƒ­ãƒ¼ã‚’é–¢æ•°ä¸€ã¤ã§ç®¡ç†ã€‚
- **ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒƒã‚¯**:   
  ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é€²è¡ŒçŠ¶æ³ã«å¿œã˜ãŸUIæ›´æ–°ãŒå®¹æ˜“ã€‚

### LI.FI Widget

Reactãªã©ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«åŸ‹ã‚è¾¼ã‚€ã ã‘ã§ä½¿ãˆã‚‹æ—¢è£½ã®UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚

- è¤‡é›‘ãªUIæ§‹ç¯‰ãªã—ã«ã€ã‚¯ãƒ­ã‚¹ãƒã‚§ãƒ¼ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—æ©Ÿèƒ½ã‚’ã‚¢ãƒ—ãƒªã«è¿½åŠ å¯èƒ½ã€‚

# ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã®å‹•ã‹ã—æ–¹

> **æ³¨æ„äº‹é …**
>
> ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã§ã—ã‹å‹•ã‹ã›ãªã‹ã£ãŸã®ã§è©¦ã™ã¨ãã¯ã€å°‘é¡ã®è³‡ç”£ã§è©¦ã™ã‚ˆã†ã«ã—ã¦GOXç­‰ã«ååˆ†æ³¨æ„ã—ã¦ãã ã•ã„ï¼

## ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
bun install
```

.env ã‚’ä½œæˆã™ã‚‹

```bash
cp .env.example .env
```

WALLET_ADDRESS ã‚’è‡ªåˆ†ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¤‰æ›´ã™ã‚‹ä»–ã€ä»¥ä¸‹ã®å€¤ã‚’åŸ‹ã‚ã¾ã™ã€‚

ä»Šå›ã¯ **zkSync**ã‹ã‚‰**Base**ã«USDCã‚’å‹•ã‹ã—ã¦ã¿ã¾ã™ã€‚

```bash
# Wallet address for quote (used to compute route and fees)
WALLET_ADDRESS=<é€é‡‘å…ƒã®ã‚¢ãƒ‰ãƒ¬ã‚¹>
TO_ADDRESS=<é€ä¿¡å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹>

FROM_CHAIN=324
TO_CHAIN=8453
FROM_TOKEN=0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4   # USDC on zkSync Era
TO_TOKEN=0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913     # USDC on Base
FROM_AMOUNT=500000 # 0.5
SLIPPAGE=0.005

# Optional: execute the transaction returned by /quote
SEND_SWAP=true
RPC_URL=https://mainnet.era.zksync.io
PRIVATE_KEY=<è‡ªåˆ†ã®ç§˜å¯†éµ>

# Optional: per-chain RPC URLs (SDK demo uses these for chain switching)
RPC_URL_42161=
RPC_URL_10=
RPC_URL_8453=https://mainnet.base.org
RPC_URL_324=https://mainnet.era.zksync.io
```

ã“ã“ã¾ã§åŸ‹ã‚ã‚‰ã‚ŒãŸã‚‰æº–å‚™OKã§ã™ï¼

## APIã§å‹•ã‹ã—ã¦ã¿ã‚‹

APIã§ã‚¯ãƒ­ã‚¹ãƒã‚§ãƒ¼ãƒ³swapã™ã‚‹å ´åˆã«ã¯ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™

```bash
bun run demo:lifi:swap
```

ã†ã¾ãã„ã‘ã°ä»¥ä¸‹ã®ã‚ˆã†ãªçµæœãŒè¿”ã£ã¦ãã¾ã™ã€‚

```bash
Request:
https://li.quest/v1/quote?fromChain=324&toChain=8453&fromToken=0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4&toToken=<æŒ‡å®šã—ãŸã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹>&fromAmount=500000&fromAddress=<æŒ‡å®šã—ãŸã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹>&toAddress=<æŒ‡å®šã—ãŸã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹>&slippage=0.005

Quote summary:
{
  id: "c8b3c2ca-bac7-429e-9c93-16e0867aa933:0",
  type: "lifi",
  tool: "relaydepository",
  fromToken: "USDC.e",
  toToken: "USDC",
  fromAmount: "500000",
  toAmount: undefined,
  toAmountMin: "465380",
  approvalAddress: "0x341e94069f53234fe6dabef707ad424830525715",
}

Prepared transactionRequest:
{
  to: "0x341e94069f53234fe6dabef707ad424830525715",
  from: "<æŒ‡å®šã—ãŸã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹>",
  data: "0xa344...000",
  value: 0n,
  gasLimit: 4561411n,
  gasPrice: 63090000n,
  maxFeePerGas: undefined,
  maxPriorityFeePerGas: undefined,
  chainId: 324,
}

Sending approve transaction...
{
  hash: "<ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>",
}
Approve confirmed.

Transaction submitted:
{
  hash: "<ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>",
}
```

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã§ã™ã€‚

ã“ã‚Œã ã‘ã§æœ€é©ãªãƒ«ãƒ¼ãƒˆã‚’é¸å®šã—ã¦Swapã—ã¦ãã‚Œã‚‹ãªã®ã§éå¸¸ã«æ¥½ã¡ã‚“ã§ã™ï¼ï¼

```ts
import "dotenv/config";
import { Contract, JsonRpcProvider, Wallet } from "ethers";

const ERC20_ABI = [
  "function allowance(address owner, address spender) view returns (uint256)",
  "function approve(address spender, uint256 amount) returns (bool)",
];

const API_BASE_URL = "https://li.quest/v1";

const env = process.env;

const requiredWallet = env.WALLET_ADDRESS;
if (!requiredWallet) {
  console.error("Missing WALLET_ADDRESS in environment.");
  console.error("Set it in .env (see .env.example).");
  process.exit(1);
}

const fromChain = env.FROM_CHAIN ?? "42161"; // Arbitrum One
const toChain = env.TO_CHAIN ?? "10"; // Optimism
const fromToken = env.FROM_TOKEN ?? "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"; // USDC on Arbitrum
const toToken = env.TO_TOKEN ?? "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"; // DAI on Optimism
const fromAmount = env.FROM_AMOUNT ?? "1000000"; // 1.0 USDC (6 decimals)
const slippage = env.SLIPPAGE ?? "0.005"; // 0.5%

const params = new URLSearchParams({
  fromChain,
  toChain,
  fromToken,
  toToken,
  fromAmount,
  fromAddress: requiredWallet,
  toAddress: env.TO_ADDRESS ?? requiredWallet,
  slippage,
});

const headers: Record<string, string> = {
  Accept: "application/json",
};

if (env.LIFI_API_KEY) {
  headers["x-lifi-api-key"] = env.LIFI_API_KEY;
}

// LI.FI API does not expose a direct /swap endpoint; execution happens by
// sending the returned transactionRequest from /quote (single-step) or
// /advanced/stepTransaction (multi-step routes). This sample uses /quote.
const url = `${API_BASE_URL}/quote?${params.toString()}`;

console.log("Request:");
console.log(url);

const res = await fetch(url, { headers });
if (!res.ok) {
  const errorText = await res.text();
  console.error(`LI.FI API error: ${res.status} ${res.statusText}`);
  console.error(errorText);
  process.exit(1);
}

const data = (await res.json()) as {
  id?: string;
  type?: string;
  tool?: string;
  action?: {
    fromToken?: { symbol?: string; address?: string };
    toToken?: { symbol?: string; address?: string };
    fromAmount?: string;
    toAmount?: string;
  };
  estimate?: {
    approvalAddress?: string;
    toAmountMin?: string;
  };
  transactionRequest?: {
    to?: string;
    from?: string;
    data?: string;
    value?: string;
    gasLimit?: string;
    gasPrice?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    chainId?: number | string;
  };
};

console.log("\nQuote summary:");
console.log({
  id: data.id,
  type: data.type,
  tool: data.tool,
  fromToken: data.action?.fromToken?.symbol ?? data.action?.fromToken?.address,
  toToken: data.action?.toToken?.symbol ?? data.action?.toToken?.address,
  fromAmount: data.action?.fromAmount,
  toAmount: data.action?.toAmount,
  toAmountMin: data.estimate?.toAmountMin,
  approvalAddress: data.estimate?.approvalAddress,
});

if (!data.transactionRequest) {
  console.error("Missing transactionRequest in quote response.");
  process.exit(1);
}

const preparedTx = formatTransactionRequest(data.transactionRequest);

console.log("\nPrepared transactionRequest:");
console.log(preparedTx);

const shouldSend = (env.SEND_SWAP ?? "").toLowerCase() === "true";
if (!shouldSend) {
  console.log(
    "\nSEND_SWAP is not true. Set SEND_SWAP=true and provide RPC_URL and PRIVATE_KEY to send the transaction.",
  );
  process.exit(0);
}

const rpcUrl = env.RPC_URL;
const privateKey = env.PRIVATE_KEY;
if (!rpcUrl || !privateKey) {
  console.error("RPC_URL and PRIVATE_KEY are required to send the swap.");
  process.exit(1);
}

const provider = new JsonRpcProvider(rpcUrl);
const wallet = new Wallet(privateKey, provider);
const walletAddress = await wallet.getAddress();

if (walletAddress.toLowerCase() !== requiredWallet.toLowerCase()) {
  console.warn(
    `Warning: wallet address ${walletAddress} does not match WALLET_ADDRESS ${requiredWallet}.`,
  );
}

const network = await provider.getNetwork();
if (preparedTx.chainId && preparedTx.chainId !== Number(network.chainId)) {
  console.warn(
    `Warning: transactionRequest.chainId ${preparedTx.chainId} does not match RPC chainId ${network.chainId}.`,
  );
}

await ensureApproval({
  fromToken: data.action?.fromToken?.address ?? fromToken,
  owner: walletAddress,
  spender: data.estimate?.approvalAddress,
  amount: data.action?.fromAmount ?? fromAmount,
  wallet,
});

const txResponse = await wallet.sendTransaction({
  to: preparedTx.to,
  data: preparedTx.data,
  value: preparedTx.value,
  gasLimit: preparedTx.gasLimit,
  gasPrice: preparedTx.gasPrice,
  maxFeePerGas: preparedTx.maxFeePerGas,
  maxPriorityFeePerGas: preparedTx.maxPriorityFeePerGas,
});

console.log("\nTransaction submitted:");
console.log({
  hash: txResponse.hash,
});

function formatTransactionRequest(input: {
  to?: string;
  from?: string;
  data?: string;
  value?: string;
  gasLimit?: string;
  gasPrice?: string;
  maxFeePerGas?: string;
  maxPriorityFeePerGas?: string;
  chainId?: number | string;
}) {
  const toBigInt = (value?: string) => (value ? BigInt(value) : undefined);
  const chainIdValue = typeof input.chainId === "string" ? Number(input.chainId) : input.chainId;

  if (!input.to) {
    throw new Error("transactionRequest.to is missing.");
  }

  return {
    to: input.to,
    from: input.from,
    data: input.data ?? "0x",
    value: toBigInt(input.value),
    gasLimit: toBigInt(input.gasLimit),
    gasPrice: toBigInt(input.gasPrice),
    maxFeePerGas: toBigInt(input.maxFeePerGas),
    maxPriorityFeePerGas: toBigInt(input.maxPriorityFeePerGas),
    chainId: chainIdValue,
  };
}

async function ensureApproval(options: {
  fromToken: string;
  owner: string;
  spender?: string;
  amount: string;
  wallet: Wallet;
}) {
  const zeroAddress = "0x0000000000000000000000000000000000000000";
  const { fromToken, owner, spender, amount, wallet } = options;

  if (!spender) {
    console.log("\nNo approvalAddress provided. Skipping approve.");
    return;
  }

  if (fromToken.toLowerCase() === zeroAddress) {
    console.log("\nNative token swap detected. No approve needed.");
    return;
  }

  const token = new Contract(fromToken, ERC20_ABI, wallet);
  const currentAllowance = (await token.allowance(owner, spender)) as bigint;
  const requiredAmount = BigInt(amount);

  if (currentAllowance >= requiredAmount) {
    console.log("\nAllowance is sufficient. No approve needed.");
    return;
  }

  console.log("\nSending approve transaction...");
  const approveTx = await token.approve(spender, requiredAmount);
  console.log({ hash: approveTx.hash });
  await approveTx.wait();
  console.log("Approve confirmed.");
}

```

## SDKã§å‹•ã‹ã—ã¦ã¿ã‚‹

æ¬¡ã«SDKã§ã‚‚è©¦ã—ã¦ã¿ã¾ã™ï¼

```bash
bun run demo:lifi:sdk
```

ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Œã°OKã§ã™ï¼

```bash
Quote summary:
{
  fromChain: 324,
  toChain: 8453,
  fromToken: "USDC.e",
  toToken: "USDC",
  fromAmount: "500000",
  toAmount: undefined,
  tool: "relaydepository",
  approvalAddress: "0x341e94069f53234fe6dabef707ad424830525715",
}

Sending approve transaction...
{
  hash: "<ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>",
}
Tx hash (step 1, CROSS_CHAIN): <ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>
Tx hash (step 1, CROSS_CHAIN): <ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>
Tx hash (step 1, CROSS_CHAIN): <ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>
Tx hash (step 1, CROSS_CHAIN): <ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>
Tx hash (step 1, RECEIVING_CHAIN):<ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>
Tx hash (step 1, CROSS_CHAIN): <ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>
Tx hash (step 1, RECEIVING_CHAIN): <ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥å€¤>

Execution finished:
{
  routeId: undefined,
  status: undefined
}
```

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã§ã™ï¼

APIã‚’ä½¿ã£ãŸæ™‚ã‚ˆã‚Šã‚‚ã“ã£ã¡ã®æ–¹ãŒã‚¹ãƒƒã‚­ãƒªã—ã¾ã™ã­

```ts
import {
  EVM,
  type QuoteRequest,
  type RouteExtended,
  convertQuoteToRoute,
  createConfig,
  executeRoute,
  getQuote,
  getTokenAllowance,
  setTokenAllowance,
} from "@lifi/sdk";
import "dotenv/config";
import { type Chain, type WalletClient, createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { arbitrum, base, mainnet, optimism, zksync } from "viem/chains";

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

const env = process.env;

const requiredWallet = env.WALLET_ADDRESS;
if (!requiredWallet) {
  console.error("Missing WALLET_ADDRESS in environment.");
  console.error("Set it in .env (see .env.example).");
  process.exit(1);
}

const privateKey = env.PRIVATE_KEY as `0x${string}` | undefined;
if (!privateKey) {
  console.error("Missing PRIVATE_KEY in environment.");
  console.error("Set it in .env (see .env.example).");
  process.exit(1);
}

// ç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®šã™ã‚‹
const integrator = env.LIFI_INTEGRATOR ?? "lify-sample";

const fromChain = Number(env.FROM_CHAIN ?? "42161");
const toChain = Number(env.TO_CHAIN ?? "10");
const fromToken = env.FROM_TOKEN ?? "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"; // USDC on Arbitrum
const toToken = env.TO_TOKEN ?? "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"; // DAI on Optimism
const fromAmount = env.FROM_AMOUNT ?? "1000000"; // 1.0 USDC (6 decimals)
const slippage = env.SLIPPAGE ? Number(env.SLIPPAGE) : undefined;

const account = privateKeyToAccount(privateKey);
const walletAddress = account.address;

if (walletAddress.toLowerCase() !== requiredWallet.toLowerCase()) {
  console.warn(
    `Warning: wallet address ${walletAddress} does not match WALLET_ADDRESS ${requiredWallet}.`,
  );
}

const chainMap: Record<number, Chain> = {
  1: mainnet,
  10: optimism,
  42161: arbitrum,
  8453: base,
  324: zksync,
};

const getChain = (chainId: number) => {
  const chain = chainMap[chainId];
  if (!chain) {
    throw new Error(
      `Unsupported chainId ${chainId}. Add it to chainMap or provide a custom Chain definition.`,
    );
  }
  return chain;
};

const getRpcUrl = (chainId: number) => {
  const keyed = env[`RPC_URL_${chainId}`];
  if (keyed) return keyed;
  if (chainId === fromChain && env.RPC_URL) return env.RPC_URL;
  return undefined;
};

// Walletã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½œæˆ
let walletClient = createWalletClient({
  account,
  chain: getChain(fromChain),
  transport: http(getRpcUrl(fromChain)),
});

/**
 * EVM Providerã‚’å–å¾—ã™ã‚‹
 */
const evmProvider = EVM({
  getWalletClient: async () => walletClient,
  switchChain: async (chainId: number) => {
    walletClient = createWalletClient({
      account,
      chain: getChain(chainId),
      transport: http(getRpcUrl(chainId)),
    });
    return walletClient;
  },
});

createConfig({
  integrator,
  providers: [evmProvider],
});

// ã‚¯ã‚©ãƒ¼ãƒˆã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
const quoteRequest: QuoteRequest = {
  fromChain,
  toChain,
  fromToken,
  toToken,
  fromAmount,
  fromAddress: walletAddress,
  toAddress: env.TO_ADDRESS ?? walletAddress,
  slippage,
};
// ã‚¯ã‚©ãƒ¼ãƒˆã‚’å–å¾—ã™ã‚‹
const quote = await getQuote(quoteRequest);

console.log("Quote summary:");
console.log({
  fromChain,
  toChain,
  fromToken: quote.action?.fromToken?.symbol ?? quote.action?.fromToken?.address,
  toToken: quote.action?.toToken?.symbol ?? quote.action?.toToken?.address,
  fromAmount: quote.action?.fromAmount,
  toAmount: quote.action?.toAmount,
  tool: quote.tool,
  approvalAddress: quote.estimate?.approvalAddress,
});

const route = convertQuoteToRoute(quote);

const shouldSend = (env.SEND_SWAP ?? "").toLowerCase() === "true";
if (!shouldSend) {
  console.log("\nSEND_SWAP is not true. Set SEND_SWAP=true to execute the route.");
  process.exit(0);
}

// approveãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã™ã‚‹
await ensureAllowance({
  chainId: fromChain,
  tokenAddress: fromToken,
  ownerAddress: walletAddress,
  spenderAddress: quote.estimate?.approvalAddress,
  amount: BigInt(fromAmount),
  walletClient,
});

// swapã‚’å®Ÿè¡Œ
const executedRoute = await executeRoute(route, {
  updateRouteHook: (updatedRoute: RouteExtended) => {
    logTransactionHashes(updatedRoute);
  },
});

console.log("\nExecution finished:");
console.log({
  routeId: executedRoute.routeId,
  status: executedRoute.status,
});

function logTransactionHashes(route: RouteExtended) {
  for (const [index, step] of route.steps.entries()) {
    step.execution?.process?.forEach((process) => {
      if (process.txHash) {
        console.log(`Tx hash (step ${index + 1}, ${process.type}): ${process.txHash}`);
      }
    });
  }
}

async function ensureAllowance(options: {
  chainId: number;
  tokenAddress: string;
  ownerAddress: string;
  spenderAddress?: string;
  amount: bigint;
  walletClient: WalletClient;
}) {
  const { chainId, tokenAddress, ownerAddress, spenderAddress, amount, walletClient } = options;

  if (!spenderAddress) {
    console.log("\nNo approvalAddress provided. Skipping approve.");
    return;
  }

  if (tokenAddress.toLowerCase() === ZERO_ADDRESS) {
    console.log("\nNative token swap detected. No approve needed.");
    return;
  }

  const token = { address: tokenAddress, chainId };
  const allowance = await getTokenAllowance(token, ownerAddress, spenderAddress);

  if (allowance && allowance >= amount) {
    console.log("\nAllowance is sufficient. No approve needed.");
    return;
  }

  console.log("\nSending approve transaction...");
  const txHash = await setTokenAllowance({
    walletClient,
    token,
    spenderAddress,
    amount,
  });
  console.log({ hash: txHash });
}
```

# ã¾ã¨ã‚

**LI.FI**ã«ã¤ã„ã¦ã¾ã¨ã‚ã¦ã¿ã¾ã—ãŸï¼

è§¦ã£ãŸæ„Ÿã˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“çš„ã«ã¯**1inch**ã¨ã•ã»ã©å¤‰ã‚ã‚‰ãªã„ã¨ã„ã†å°è±¡ã§ã—ãŸã€‚

ä»–ã«ã‚‚æ©Ÿèƒ½ãŒãƒªãƒªãƒ¼ã‚¹äºˆå®šã¨ã®ã“ã¨ãªã®ã§ä»Šå¾Œã‚‚ã‚¦ã‚©ãƒƒãƒã—ã¦ãƒªãƒªãƒ¼ã‚¹ã•ã‚ŒãŸã‚‰æ–°æ©Ÿèƒ½ã‚’è©¦ã—ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ï¼ï¼

# å‚è€ƒæ–‡çŒ®

- [API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.li.fi/api-reference/introduction)
- [SDK ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.li.fi/sdk/overview?utm_source=lifi&utm_medium=header_developers_get_started&utm_campaign=lifi_to_docs)
- [Widget ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.li.fi/widget/overview?utm_source=lifi&utm_medium=header_developers_get_started&utm_campaign=lifi_to_docs)