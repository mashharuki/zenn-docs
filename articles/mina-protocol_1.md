---
title: "MinaProtocolã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã¿ãŸï¼"
emoji: "ğŸ› "
type: "tech"
topics: ["Web3", "Blockchain", "ã‚¼ãƒ­çŸ¥è­˜è¨¼æ˜", "TypeScript", "zk"]
published: false
---

![](/images/mina-protocol_1/0.jpeg)

## ã¯ã˜ã‚ã«

çš†ã•ã‚“ã€ã“ã‚“ã«ã¡ã¯ã€‚

ä»Šå›ã¯ã€**MinaProtocol** ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚’ãƒ†ãƒ¼ãƒã«ã—ãŸè¨˜äº‹ã‚’åŸ·ç­†ã—ã¦ã„ã“ã†ã¨æ€ã„ã¾ã™ï¼

ç¾åœ¨ãƒãƒƒã‚«ã‚½ãƒ³ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ **Akindo**ã¨**MinaProtocol**ã®ãƒãƒ¼ãƒ ãŒã‚¿ãƒƒã‚°çµ„ã‚“ã§ WaveHack ã¨ã„ã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿæ–½ä¸­ã§ã™ï¼

https://app.akindo.io/wave-hacks/ENw9p7R6nUz818lo1

**WaveHack** ã£ã¦ãªã‚“ã ã¨ã„ã†æ–¹ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’ã”å‚ç…§ãã ã•ã„ï¼

ãƒ•ã‚¡ã‚¦ãƒ³ãƒ€ãƒ¼ã§ã‚ã‚‹é‡‘åŸã•ã‚“ã®æƒ³ã„ãŒã¾ã¨ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ï¼ï¼ï¼

https://note.com/shinkinjo/n/n313d1e931ebf

## Mina Protocol ã¨ã¯

Mina Protocol ã¯ O(1)Labs ã«ã‚ˆã‚Š 2017 å¹´ 6 æœˆã‹ã‚‰é–‹ç™ºã•ã‚Œã¦ã„ã‚‹ L1 ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã™ã€‚

**o1js** ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦ **TypeScript** ã§ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ï¼

ã¾ãŸã€ãŸã ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã¯ãªãã‚¼ãƒ­çŸ¥è­˜è¨¼æ˜ã‚’ãƒ•ãƒ«æ´»ç”¨ã—ãŸ **ZK App**ã‚’é–‹ç™ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ãªã£ã¦ã„ã¾ã™ï¼ï¼

## ä»Šå›ä½¿ã†ã‚³ãƒ¼ãƒ‰

ä»Šå›ä½¿ã†ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã«æ ¼ç´ã•ã‚Œã¦ã„ã¾ã™ã€‚

https://github.com/mashharuki/MinaProtocol-MinHackathon

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ä»¥å‰å‚åŠ ã—ãŸ MinaProtocol ã® Mini Hackathon ã«æŒ‘æˆ¦ã—ãŸæ™‚ã®ã‚‚ã®ã§ã™ï¼

https://app.akindo.io/hackathons/d8QRPgkrNCxGZ3Ea

## ä»Šå›å®Ÿè£…ã—ãŸã‚‚ã®

ä»Šå›å®Ÿè£…ã—ãŸã‚‚ã®ã¯éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ãªã‚‚ã®ã§ä»¥ä¸‹ã® 4 ã¤ã®æ©Ÿèƒ½ã§ã™ã€‚

- **æ–°ã—ã„éµãƒšã‚¢ã‚’ç”Ÿæˆã™ã‚‹æ©Ÿèƒ½**
- **ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ–°ã—ããƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹æ©Ÿèƒ½**
- **ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒŸãƒ³ãƒˆã™ã‚‹æ©Ÿèƒ½**
- **ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€é‡‘ã™ã‚‹æ©Ÿèƒ½**

## ã‚³ãƒ¼ãƒ‰ã®è§£èª¬

ã“ã“ã‹ã‚‰ã¯ã‚³ãƒ¼ãƒ‰ã®è§£èª¬ã‚’ã—ã¦ã„ãã¾ã™ã€‚

ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸã‚Šé€é‡‘ã—ãŸã‚Šã™ã‚‹ã‚³ãƒ¼ãƒ‰ã®è§£èª¬ã«ãªã‚Šã¾ã™ï¼ï¼

- **FungibleToken** ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆ

  :::message
  FungibleToken.ts ã®ä¸­èº«ã§ã™ï¼
  :::

  ã¾ãšã¯ã€FungibleToken ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®è§£èª¬ã‹ã‚‰ï¼

  æ›¸ãã£ã·ã‚Šã¯ã€TypeScript ã§ã™ãŒã€Solidty ã§ ERC20 ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å®Ÿè£…ã—ãŸã“ã¨ãŒã‚ã‚‹äººãªã‚‰è¦‹è¦šãˆã®ã‚ã‚‹å®Ÿè£…ãªã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿï¼Ÿ

  ```ts
  import {
    AccountUpdate,
    AccountUpdateForest,
    assert,
    Bool,
    DeployArgs,
    Int64,
    method,
    Permissions,
    Provable,
    PublicKey,
    State,
    state,
    Struct,
    TokenContractV2,
    Types,
    UInt64,
    UInt8,
    VerificationKey,
  } from "o1js";
  import {
    FungibleTokenAdmin,
    FungibleTokenAdminBase,
  } from "./FungibleTokenAdmin.js";

  interface FungibleTokenDeployProps extends Exclude<DeployArgs, undefined> {
    symbol: string;
    src: string;
  }

  /**
   * ã‚¨ãƒ©ãƒ¼ã®å®šç¾©
   */
  export const FungibleTokenErrors = {
    noAdminKey: "could not fetch admin contract key",
    noPermissionToChangeAdmin: "Not allowed to change admin contract",
    tokenPaused: "Token is currently paused",
    noPermissionToMint: "Not allowed to mint tokens",
    noPermissionToPause: "Not allowed to pause token",
    noPermissionToResume: "Not allowed to resume token",
    noTransferFromCirculation: "Can't transfer to/from the circulation account",
    noPermissionChangeAllowed:
      "Can't change permissions for access or receive on token accounts",
    flashMinting:
      "Flash-minting or unbalanced transaction detected. Please make sure that your transaction is balanced, and that your `AccountUpdate`s are ordered properly, so that tokens are not received before they are sent.",
    unbalancedTransaction: "Transaction is unbalanced",
  };

  ////////////////////////////////////////////////////////////////////////////////////////
  // å‡¦ç†ã«å¿œã˜ã¦ç™ºç«ã•ã›ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®å®šç¾©
  ////////////////////////////////////////////////////////////////////////////////////////

  export class SetAdminEvent extends Struct({
    adminKey: PublicKey,
  }) {}

  export class PauseEvent extends Struct({
    isPaused: Bool,
  }) {}

  export class MintEvent extends Struct({
    recipient: PublicKey,
    amount: UInt64,
  }) {}

  export class BurnEvent extends Struct({
    from: PublicKey,
    amount: UInt64,
  }) {}

  export class BalanceChangeEvent extends Struct({
    address: PublicKey,
    amount: Int64,
  }) {}

  /**
   * FungibleToken Contractã‚¯ãƒ©ã‚¹
   */
  export class FungibleToken extends TokenContractV2 {
    // å¤‰æ•°ã®å®šç¾©
    @state(UInt8)
    decimals = State<UInt8>();
    @state(PublicKey)
    admin = State<PublicKey>();
    @state(Bool)
    paused = State<Bool>();

    // This defines the type of the contract that is used to control access to administrative actions.
    // If you want to have a custom contract, overwrite this by setting FungibleToken.AdminContract to
    // your own implementation of FungibleTokenAdminBase.
    static AdminContract: new (...args: any) => FungibleTokenAdminBase =
      FungibleTokenAdmin;

    readonly events = {
      SetAdmin: SetAdminEvent,
      Pause: PauseEvent,
      Mint: MintEvent,
      Burn: BurnEvent,
      BalanceChange: BalanceChangeEvent,
    };

    /**
     * deploy ãƒ¡ã‚½ãƒƒãƒ‰ ã“ã‚Œã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã€‚
     * @param props
     */
    async deploy(props: FungibleTokenDeployProps) {
      await super.deploy(props);
      this.paused.set(Bool(true));
      this.account.zkappUri.set(props.src);
      this.account.tokenSymbol.set(props.symbol);

      this.account.permissions.set({
        ...Permissions.default(),
        setVerificationKey:
          Permissions.VerificationKey.impossibleDuringCurrentVersion(),
        setPermissions: Permissions.impossible(),
        access: Permissions.proof(),
      });
    }

    /**
     * Update the verification key.
     * Note that because we have set the permissions for setting the verification key to `impossibleDuringCurrentVersion()`, this will only be possible in case of a protocol update that requires an update.
     */
    @method
    async updateVerificationKey(vk: VerificationKey) {
      this.account.verificationKey.set(vk);
    }

    /**
     * Initializes the account for tracking total circulation.
     * @argument {PublicKey} admin - public key where the admin contract is deployed
     * @argument {UInt8} decimals - number of decimals for the token
     * @argument {Bool} startPaused - if set to `Bool(true), the contract will start in a mode where token minting and transfers are paused. This should be used for non-atomic deployments
     */
    @method
    async initialize(admin: PublicKey, decimals: UInt8, startPaused: Bool) {
      this.account.provedState.requireEquals(Bool(false));

      this.admin.set(admin);
      this.decimals.set(decimals);
      this.paused.set(Bool(false));

      this.paused.set(startPaused);

      const accountUpdate = AccountUpdate.createSigned(
        this.address,
        this.deriveTokenId()
      );
      let permissions = Permissions.default();
      // This is necessary in order to allow token holders to burn.
      permissions.send = Permissions.none();
      permissions.setPermissions = Permissions.impossible();
      accountUpdate.account.permissions.set(permissions);
    }

    /**
     * getAdminContract method
     * @returns
     */
    public async getAdminContract(): Promise<FungibleTokenAdminBase> {
      const admin = await Provable.witnessAsync(PublicKey, async () => {
        let pk = await this.admin.fetch();
        assert(pk !== undefined, FungibleTokenErrors.noAdminKey);
        return pk;
      });
      this.admin.requireEquals(admin);
      return new FungibleToken.AdminContract(admin);
    }

    /**
     * setAdmin method
     * @param admin
     */
    @method
    async setAdmin(admin: PublicKey) {
      const adminContract = await this.getAdminContract();
      const canChangeAdmin = await adminContract.canChangeAdmin(admin);
      canChangeAdmin.assertTrue(FungibleTokenErrors.noPermissionToChangeAdmin);
      this.admin.set(admin);
      this.emitEvent("SetAdmin", new SetAdminEvent({ adminKey: admin }));
    }

    /**
     * ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒŸãƒ³ãƒˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
     * @param recipient
     * @param amount
     * @returns
     */
    @method.returns(AccountUpdate)
    async mint(recipient: PublicKey, amount: UInt64): Promise<AccountUpdate> {
      this.paused
        .getAndRequireEquals()
        .assertFalse(FungibleTokenErrors.tokenPaused);
      // mint
      const accountUpdate = this.internal.mint({ address: recipient, amount });
      const adminContract = await this.getAdminContract();
      // mintå¯èƒ½ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
      const canMint = await adminContract.canMint(accountUpdate);
      canMint.assertTrue(FungibleTokenErrors.noPermissionToMint);
      recipient
        .equals(this.address)
        .assertFalse(FungibleTokenErrors.noTransferFromCirculation);
      this.approve(accountUpdate);
      // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
      this.emitEvent("Mint", new MintEvent({ recipient, amount }));
      const circulationUpdate = AccountUpdate.create(
        this.address,
        this.deriveTokenId()
      );
      circulationUpdate.balanceChange = Int64.fromUnsigned(amount);
      return accountUpdate;
    }

    /**
     * ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒãƒ¼ãƒ³ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
     * @param from
     * @param amount
     * @returns
     */
    @method.returns(AccountUpdate)
    async burn(from: PublicKey, amount: UInt64): Promise<AccountUpdate> {
      this.paused
        .getAndRequireEquals()
        .assertFalse(FungibleTokenErrors.tokenPaused);
      // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒãƒ¼ãƒ³ã™ã‚‹ã€‚
      const accountUpdate = this.internal.burn({ address: from, amount });
      const circulationUpdate = AccountUpdate.create(
        this.address,
        this.deriveTokenId()
      );
      from
        .equals(this.address)
        .assertFalse(FungibleTokenErrors.noTransferFromCirculation);
      circulationUpdate.balanceChange = Int64.fromUnsigned(amount).negV2();
      // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã•ã›ã‚‹ã€‚
      this.emitEvent("Burn", new BurnEvent({ from, amount }));
      return accountUpdate;
    }

    /**
     * pause method
     */
    @method
    async pause() {
      const adminContract = await this.getAdminContract();
      const canPause = await adminContract.canPause();
      canPause.assertTrue(FungibleTokenErrors.noPermissionToPause);
      this.paused.set(Bool(true));
      this.emitEvent("Pause", new PauseEvent({ isPaused: Bool(true) }));
    }

    /**
     * resume method
     */
    @method
    async resume() {
      const adminContract = await this.getAdminContract();
      const canResume = await adminContract.canResume();
      canResume.assertTrue(FungibleTokenErrors.noPermissionToResume);
      this.paused.set(Bool(false));
      this.emitEvent("Pause", new PauseEvent({ isPaused: Bool(false) }));
    }

    /**
     * ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç§»è»¢ã•ã›ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
     * @param from
     * @param to
     * @param amount
     */
    @method
    async transfer(from: PublicKey, to: PublicKey, amount: UInt64) {
      this.paused
        .getAndRequireEquals()
        .assertFalse(FungibleTokenErrors.tokenPaused);
      from
        .equals(this.address)
        .assertFalse(FungibleTokenErrors.noTransferFromCirculation);
      to.equals(this.address).assertFalse(
        FungibleTokenErrors.noTransferFromCirculation
      );
      // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç§»è»¢ã•ã›ã‚‹ã€‚
      this.internal.send({ from, to, amount });
    }

    /**
     * checkPermissionsUpdate method
     * @param update
     */
    private checkPermissionsUpdate(update: AccountUpdate) {
      let permissions = update.update.permissions;

      let { access, receive } = permissions.value;
      let accessIsNone = Provable.equal(
        Types.AuthRequired,
        access,
        Permissions.none()
      );
      let receiveIsNone = Provable.equal(
        Types.AuthRequired,
        receive,
        Permissions.none()
      );
      let updateAllowed = accessIsNone.and(receiveIsNone);

      assert(
        updateAllowed.or(permissions.isSome.not()),
        FungibleTokenErrors.noPermissionChangeAllowed
      );
    }

    /** Approve `AccountUpdate`s that have been created outside of the token contract.
     *
     * @argument {AccountUpdateForest} updates - The `AccountUpdate`s to approve. Note that the forest size is limited by the base token contract, @see TokenContractV2.MAX_ACCOUNT_UPDATES The current limit is 9.
     */
    @method
    async approveBase(updates: AccountUpdateForest): Promise<void> {
      this.paused
        .getAndRequireEquals()
        .assertFalse(FungibleTokenErrors.tokenPaused);
      let totalBalance = Int64.from(0);
      this.forEachUpdate(updates, (update, usesToken) => {
        // Make sure that the account permissions are not changed
        this.checkPermissionsUpdate(update);
        this.emitEventIf(
          usesToken,
          "BalanceChange",
          new BalanceChangeEvent({
            address: update.publicKey,
            amount: update.balanceChange,
          })
        );
        // Don't allow transfers to/from the account that's tracking circulation
        update.publicKey
          .equals(this.address)
          .and(usesToken)
          .assertFalse(FungibleTokenErrors.noTransferFromCirculation);
        totalBalance = Provable.if(
          usesToken,
          totalBalance.add(update.balanceChange),
          totalBalance
        );
        totalBalance
          .isPositiveV2()
          .assertFalse(FungibleTokenErrors.flashMinting);
      });
      totalBalance.assertEquals(
        Int64.zero,
        FungibleTokenErrors.unbalancedTransaction
      );
    }

    /**
     * getBalanceOf method
     * @param address
     * @returns
     */
    @method.returns(UInt64)
    async getBalanceOf(address: PublicKey): Promise<UInt64> {
      const account = AccountUpdate.create(
        address,
        this.deriveTokenId()
      ).account;
      const balance = account.balance.get();
      account.balance.requireEquals(balance);
      return balance;
    }

    /**
     * Reports the current circulating supply
     * This does take into account currently unreduced actions.
     */
    async getCirculating(): Promise<UInt64> {
      let circulating = await this.getBalanceOf(this.address);
      return circulating;
    }

    /**
     * getDecimals method
     * @returns
     */
    @method.returns(UInt8)
    async getDecimals(): Promise<UInt8> {
      return this.decimals.getAndRequireEquals();
    }
  }
  ```

- **FungibleTokenAdmin** ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆ

  :::message
  FungibleTokenAdmin.ts ã®ä¸­èº«ã§ã™ï¼
  :::

  ãƒˆãƒ¼ã‚¯ãƒ³æ“ä½œç”¨ã®æ¨©é™ç­‰ã‚’ç®¡ç†ã™ã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã™ã€‚

  FungibleToken ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸­ã§ `canMint`ãªã©æ¨©é™å‘¨ã‚Šã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ãŒå«ã¾ã‚Œã¦ã„ã¾ã—ãŸãŒã€ãã®æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã™ã€‚

  ```ts
  import {
    AccountUpdate,
    assert,
    Bool,
    DeployArgs,
    method,
    Permissions,
    Provable,
    PublicKey,
    SmartContract,
    State,
    state,
    VerificationKey,
  } from "o1js";

  export type FungibleTokenAdminBase = SmartContract & {
    canMint(accountUpdate: AccountUpdate): Promise<Bool>;
    canChangeAdmin(admin: PublicKey): Promise<Bool>;
    canPause(): Promise<Bool>;
    canResume(): Promise<Bool>;
  };

  export interface FungibleTokenAdminDeployProps
    extends Exclude<DeployArgs, undefined> {
    adminPublicKey: PublicKey;
  }

  /** A contract that grants permissions for administrative actions on a token.
   *
   * We separate this out into a dedicated contract. That way, when issuing a token, a user can
   * specify their own rules for administrative actions, without changing the token contract itself.
   *
   * The advantage is that third party applications that only use the token in a non-privileged way
   * can integrate against the unchanged token contract.
   */
  export class FungibleTokenAdmin
    extends SmartContract
    implements FungibleTokenAdminBase
  {
    @state(PublicKey)
    private adminPublicKey = State<PublicKey>();

    /**
     * deploy
     */
    async deploy(props: FungibleTokenAdminDeployProps) {
      await super.deploy(props);
      this.adminPublicKey.set(props.adminPublicKey);
      this.account.permissions.set({
        ...Permissions.default(),
        setVerificationKey:
          Permissions.VerificationKey.impossibleDuringCurrentVersion(),
        setPermissions: Permissions.impossible(),
      });
    }

    /**
     * Update the verification key.
     * Note that because we have set the permissions for setting the verification key to `impossibleDuringCurrentVersion()`, this will only be possible in case of a protocol update that requires an update.
     */
    @method
    async updateVerificationKey(vk: VerificationKey) {
      this.account.verificationKey.set(vk);
    }

    /**
     * ensureAdminSignature method
     * @returns
     */
    private async ensureAdminSignature() {
      const admin = await Provable.witnessAsync(PublicKey, async () => {
        let pk = await this.adminPublicKey.fetch();
        assert(pk !== undefined, "could not fetch admin public key");
        return pk;
      });
      this.adminPublicKey.requireEquals(admin);
      return AccountUpdate.createSigned(admin);
    }

    /**
     * canMint method
     * @param _accountUpdate
     * @returns
     */
    @method.returns(Bool)
    public async canMint(_accountUpdate: AccountUpdate) {
      await this.ensureAdminSignature();
      return Bool(true);
    }

    /**
     * canChangeAdmin method
     * @param _admin
     * @returns
     */
    @method.returns(Bool)
    public async canChangeAdmin(_admin: PublicKey) {
      await this.ensureAdminSignature();
      return Bool(true);
    }

    /**
     * canPause method
     * @returns
     */
    @method.returns(Bool)
    public async canPause(): Promise<Bool> {
      await this.ensureAdminSignature();
      return Bool(true);
    }

    /**
     * canResume method
     * @returns
     */
    @method.returns(Bool)
    public async canResume(): Promise<Bool> {
      await this.ensureAdminSignature();
      return Bool(true);
    }
  }
  ```

- æ–°ã—ã„éµãƒšã‚¢ã‚’ç”Ÿæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰

  :::message
  examples/generate_keys.ts ã®ä¸­èº«ã§ã™ï¼
  :::

  æ–°ã—ã„ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚

  ã¾ãšæœ€åˆã«éµãƒšã‚¢ã®ç”ŸæˆãŒå¿…è¦ãªç‚¹ã¯ Ethereum ã§ã‚‚åŒã˜ã§ã™ã‚ˆã­ï¼ï¼

  ä»Šå›ã¯å‹•ã‹ã™ãŸã‚ã« 3 ã¤ã®éµãƒšã‚¢ã‚’ä½œæˆã—ã¾ã™ï¼ï¼

  - ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆç”¨
  - Admin ç”¨
  - Deployer ç”¨

  ```ts
  import { PrivateKey } from "o1js";

  // æ–°ã—ãã‚­ãƒ¼ãƒšã‚¢ã‚’ç”Ÿæˆã™ã‚‹
  const { privateKey: tokenKey, publicKey: tokenAddress } =
    PrivateKey.randomKeypair();

  console.log(`Private Key: ${tokenKey.toBase58()}`);
  console.log(`Public Key: ${tokenAddress.toBase58()}`);
  ```

- æ–°ã—ããƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã‚³ãƒ¼ãƒ‰

  :::message
  examples/deploy_devnet.ts ã®ä¸­èº«ã§ã™ï¼
  :::

  ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ã‚³ãƒ¼ãƒ‰ã§ã™ï¼

  å…·ä½“çš„ã«ã¯ã€ FungibleToken ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®`deploy`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ï¼ï¼

  æ›¸ãæ–¹ã¯ç‹¬ç‰¹ã§ã™ãŒã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä½œã£ã¦ã‹ã‚‰ç½²åï¼†é€ä¿¡ã¨ã„ã†æµã‚Œã¯ã“ã‚Œã¾ã§ã®ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã¨åŒã˜ã§ã™ï¼ï¼

  ```ts
  import * as dotenv from "dotenv";
  import {
    AccountUpdate,
    Bool,
    Mina,
    PrivateKey,
    PublicKey,
    UInt64,
    UInt8,
  } from "o1js";
  import { FungibleToken, FungibleTokenAdmin } from "./../index.js";

  dotenv.config();

  const {
    PRIVATE_KEY,
    TOKEN_PRIVATE_KEY,
    TOKEN_PUBLIC_KEY,
    ADMIN_PRIVATE_KEY,
  } = process.env;

  const Network = Mina.Network(
    "https://api.minascan.io/node/devnet/v1/graphql"
  );
  Mina.setActiveInstance(Network);

  class MyToken extends FungibleToken {}

  // comiple
  await FungibleTokenAdmin.compile();
  await FungibleToken.compile();
  await MyToken.compile();

  console.log("Compiling done");

  // ãƒˆãƒ¼ã‚¯ãƒ³ç”¨ã®ã‚­ãƒ¼ãƒšã‚¢ã‚’ç”Ÿæˆ
  const { privateKey: tokenKey, publicKey: tokenAddress } =
    PrivateKey.randomKeypair();

  console.log(`Token Private Key: ${tokenKey.toBase58()}`);
  console.log(`Token Public Key: ${tokenAddress.toBase58()}`);
  const token = new MyToken(tokenAddress);

  // adminç”¨ã®ã‚­ãƒ¼ãƒšã‚¢ã‚’ç”Ÿæˆ
  const { privateKey: adminKey, publicKey: adminAddress } =
    PrivateKey.randomKeypair();

  console.log(`AdminFungibleToken Private Key: ${adminKey.toBase58()}`);
  console.log(`AdminFungibleToken Public Key: ${adminAddress.toBase58()}`);

  // deployer
  const deployerKey = PrivateKey.fromBase58(PRIVATE_KEY!);
  const ownerKey = PrivateKey.fromBase58(PRIVATE_KEY!);
  const admin = PrivateKey.fromBase58(ADMIN_PRIVATE_KEY!);
  const owner = PublicKey.fromPrivateKey(ownerKey);
  const deployer = PublicKey.fromPrivateKey(deployerKey);
  const adminer = PublicKey.fromPrivateKey(admin);
  // ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‡ãƒ—ãƒ­ã‚¤
  const fungibleTokenAdmin = new FungibleTokenAdmin(adminAddress);
  // ãƒˆãƒ¼ã‚¯ãƒ³åã‚„åˆæœŸç™ºè¡Œé‡ãªã©ã‚’å®šç¾©
  const supply = UInt64.from(21_000_000);
  const symbol = "MashTN";
  const src =
    "https://github.com/MinaFoundation/mina-fungible-token/blob/main/FungibleToken.ts";

  const fee = 100_000_000;

  console.log("Deploying token");

  // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ãŸã‚ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹ã€‚
  const tx = await Mina.transaction({ sender: deployer, fee }, async () => {
    AccountUpdate.fundNewAccount(deployer, 3);
    // deployãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã€‚
    await fungibleTokenAdmin.deploy({ adminPublicKey: adminAddress });
    await token.deploy({
      symbol,
      src,
    });
    // initialeizeãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—
    await token.initialize(adminAddress, UInt8.from(9), Bool(false));
  });

  await tx.prove();
  // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã«ç½²åï¼†é€ä¿¡
  tx.sign([deployerKey, tokenKey, adminKey]);
  let pendingTransaction = await tx.send();

  if (pendingTransaction.status === "rejected") {
    console.log("error sending transaction (see above)");
    process.exit(0);
  }

  console.log(
    `See transaction at https://minascan.io/devnet/tx/${pendingTransaction.hash}`
  );
  console.log("Waiting for transaction to be included in a block");
  await pendingTransaction.wait();

  console.log("Token deployed!!!!");
  ```

- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒŸãƒ³ãƒˆã™ã‚‹ã‚³ãƒ¼ãƒ‰

  :::message
  examples/mint_devnet.ts ã®ä¸­èº«ã§ã™ï¼
  :::

  æ¬¡ã«ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸå¾Œã«å‘¼ã³å‡ºã™ãƒŸãƒ³ãƒˆç”¨ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ã‚³ãƒ¼ãƒ‰ã‚’è§£èª¬ã—ãŸã„ã¨æ€ã„ã¾ã™ï¼ï¼

  ```ts
  import * as dotenv from "dotenv";
  import { Mina, PrivateKey, PublicKey, UInt64 } from "o1js";
  import { FungibleToken, FungibleTokenAdmin } from "./../index.js";

  dotenv.config();

  const {
    PRIVATE_KEY,
    TOKEN_PRIVATE_KEY,
    TOKEN_PUBLIC_KEY,
    ADMIN_PRIVATE_KEY,
    ADMIN_PUBLIC_KEY,
  } = process.env;

  const Network = Mina.Network(
    "https://api.minascan.io/node/devnet/v1/graphql"
  );
  Mina.setActiveInstance(Network);

  class MyToken extends FungibleToken {}
  // comiple
  await FungibleTokenAdmin.compile();
  await FungibleToken.compile();
  await MyToken.compile();

  // ãƒˆãƒ¼ã‚¯ãƒ³ç”¨ã®ã‚­ãƒ¼æƒ…å ±ã‚’è¨­å®š
  const tokenKey = PrivateKey.fromBase58(TOKEN_PRIVATE_KEY!);
  const tokenAddress = PublicKey.fromBase58(TOKEN_PUBLIC_KEY!);
  // Adminã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆç”¨ã®ã‚­ãƒ¼æƒ…å ±ã‚’è¨­å®š
  const adminKey = PrivateKey.fromBase58(ADMIN_PRIVATE_KEY!);
  const adminAddress = PublicKey.fromBase58(ADMIN_PUBLIC_KEY!);

  // ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
  const token = new MyToken(tokenAddress);
  const fungibleTokenAdmin = new FungibleTokenAdmin(adminAddress);

  // deployer
  const deployerKey = PrivateKey.fromBase58(PRIVATE_KEY!);
  const ownerKey = PrivateKey.fromBase58(PRIVATE_KEY!);
  const owner = PublicKey.fromPrivateKey(ownerKey);

  const fee = 100_000_000;

  // ãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œå‰ã®ãƒˆãƒ¼ã‚¯ãƒ³ä¿æœ‰é‡ã‚’å–å¾—
  const ownerBalanceBeforeMint = (await token.getBalanceOf(owner)).toBigInt();
  console.log("owner balance before mint:", ownerBalanceBeforeMint);

  console.log("Minting token");

  // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒŸãƒ³ãƒˆã™ã‚‹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿
  const mintTx = await Mina.transaction(
    {
      sender: owner,
      fee,
    },
    async () => {
      //AccountUpdate.fundNewAccount(owner, 2);
      await token.mint(owner, new UInt64(2e9));
    }
  );

  await mintTx.prove();
  // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®ç½²åï¼†é€ä¿¡ã‚’è¡Œã†ã€‚
  mintTx.sign([ownerKey, adminKey]);
  const mintTxResult = await mintTx.send().then((v) => v.wait());
  console.log("Mint tx result:", mintTxResult.toPretty());

  console.log(
    `See transaction at https://minascan.io/devnet/tx/${mintTxResult.hash}`
  );

  console.log("Mint token done");

  // ãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œå¾Œã®ãƒˆãƒ¼ã‚¯ãƒ³ä¿æœ‰é‡ã‚’å–å¾—
  const ownerBalanceAfterMint = (await token.getBalanceOf(owner)).toBigInt();
  console.log("owner balance after mint:", ownerBalanceAfterMint);
  ```

- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€é‡‘ã™ã‚‹ã‚³ãƒ¼ãƒ‰

  :::message
  examples/transfer_devnet.ts ã®ä¸­èº«ã§ã™ï¼
  :::

  ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒŸãƒ³ãƒˆã—ãŸå¾Œã¯é€é‡‘å‡¦ç†ã‚’è¡Œã„ãŸã„ã®ã§ã€æ¬¡ã«é€é‡‘ç”¨ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç¢ºèªã—ã¦ã„ãã¾ã™ã€‚

  ```ts
  import * as dotenv from "dotenv";
  import { AccountUpdate, Mina, PrivateKey, PublicKey, UInt64 } from "o1js";
  import { FungibleToken, FungibleTokenAdmin } from "./../index.js";

  dotenv.config();

  const {
    PRIVATE_KEY,
    TOKEN_PRIVATE_KEY,
    TOKEN_PUBLIC_KEY,
    ADMIN_PRIVATE_KEY,
    ADMIN_PUBLIC_KEY,
  } = process.env;

  const Network = Mina.Network(
    "https://api.minascan.io/node/devnet/v1/graphql"
  );
  Mina.setActiveInstance(Network);

  class MyToken extends FungibleToken {}
  // comiple
  await FungibleTokenAdmin.compile();
  await FungibleToken.compile();
  await MyToken.compile();

  // ãƒˆãƒ¼ã‚¯ãƒ³ç”¨ã®ã‚­ãƒ¼æƒ…å ±ã‚’è¨­å®š
  const tokenKey = PrivateKey.fromBase58(TOKEN_PRIVATE_KEY!);
  const tokenAddress = PublicKey.fromBase58(TOKEN_PUBLIC_KEY!);
  // Adminã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆç”¨ã®ã‚­ãƒ¼æƒ…å ±ã‚’è¨­å®š
  const adminKey = PrivateKey.fromBase58(ADMIN_PRIVATE_KEY!);
  const adminAddress = PublicKey.fromBase58(ADMIN_PUBLIC_KEY!);

  // ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
  const token = new MyToken(tokenAddress);
  const fungibleTokenAdmin = new FungibleTokenAdmin(adminAddress);

  // deployer
  const deployerKey = PrivateKey.fromBase58(PRIVATE_KEY!);
  const ownerKey = PrivateKey.fromBase58(PRIVATE_KEY!);
  const owner = PublicKey.fromPrivateKey(ownerKey);

  const fee = 100_000_000;

  // ãƒˆãƒ¼ã‚¯ãƒ³ç§»è»¢å‰ã®ãƒˆãƒ¼ã‚¯ãƒ³ä¿æœ‰é‡ã‚’å–å¾—
  const ownerBalanceBeforeTransfer = (
    await token.getBalanceOf(owner)
  ).toBigInt();
  console.log("owner balance before transfer:", ownerBalanceBeforeTransfer);

  const adminBalanceBeforeTransfer = (
    await token.getBalanceOf(adminAddress)
  ).toBigInt();
  console.log("owner balance before transfer:", adminBalanceBeforeTransfer);

  console.log("Transferring tokens from owner to admin");
  const transferTx = await Mina.transaction(
    {
      sender: owner,
      fee,
    },
    async () => {
      AccountUpdate.fundNewAccount(owner, 1);
      await token.transfer(owner, adminAddress, new UInt64(1e9));
    }
  );
  await transferTx.prove();
  transferTx.sign([ownerKey]);
  const transferTxResult = await transferTx.send().then((v) => v.wait());
  console.log("Transfer tx result:", transferTxResult.toPretty());

  console.log(
    `See transaction at https://minascan.io/devnet/tx/${transferTxResult.hash}`
  );

  console.log("Transfer token done");

  // ãƒˆãƒ¼ã‚¯ãƒ³ç§»è»¢å¾Œã®ãƒˆãƒ¼ã‚¯ãƒ³ä¿æœ‰é‡ã‚’å–å¾—
  const ownerBalanceAfterTransfer = (
    await token.getBalanceOf(owner)
  ).toBigInt();
  console.log("owner balance before transfer:", ownerBalanceAfterTransfer);

  const adminBalanceAfterTransfer = (
    await token.getBalanceOf(adminAddress)
  ).toBigInt();
  console.log("owner balance before transfer:", adminBalanceAfterTransfer);
  ```

  é•·ã‹ã£ãŸã§ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã®è§£èª¬ã¯ã“ã“ã¾ã§ã«ãªã‚Šã¾ã™ï¼ï¼ï¼

## å‹•ã‹ã—æ–¹

ã“ã“ã‹ã‚‰ã¯å®Ÿéš›ã«ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ã¨ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å±¥æ­´ã‚’å…±æœ‰ã—ã¦ã„ãã¾ã™ï¼

:::message
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ `fungible-token-sample` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼
:::

- ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

  ```bash
  npm i
  ```

- æ–°ã—ã„éµãƒšã‚¢ã‚’ç”Ÿæˆã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•

  ```bash
  npm run task examples/generate_key.ts
  ```

- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ DevNet ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹æ–¹æ³•

  ```bash
  npm run task examples/deploy_devnet.ts
  ```

  ä»¥ä¸‹ã¯ã€å®Ÿéš›ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã¿ãŸãƒˆãƒ¼ã‚¯ãƒ³ã§ã™ï¼

https://minascan.io/devnet/token/xR7E8xvJo2bX2kFGLSqrA9XTrdZRq1L89BdLxt9N3gCGqonqyn/zk-txs

- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒŸãƒ³ãƒˆã™ã‚‹æ–¹æ³•

  ```bash
  npm run task examples/mint_devnet.ts
  ```

  ä»¥ä¸‹ã¯ã€ãƒŸãƒ³ãƒˆã—ãŸæ™‚ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚

https://minascan.io/devnet/tx/5Jur32w1Xc6juesY9hGNbV4AAfABsWxK22RrMNvUiWnNuzbatuwY

- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€é‡‘ã™ã‚‹æ–¹æ³•

  ```bash
  npm run task examples/transfer_devnet.ts
  ```

  ä»¥ä¸‹ã¯ã€é€é‡‘ã—ãŸæ™‚ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚

https://minascan.io/devnet/tx/5JumaqMFAF1MeygQHmCvb9662rGC6FtB43z9URbEpEMzvG2TtZFL

- ãƒˆãƒ¼ã‚¯ãƒ³ãƒ›ãƒ«ãƒ€ãƒ¼ã®ç¢ºèªæ–¹æ³•

  ä»¥ä¸‹ã®ãƒšãƒ¼ã‚¸ã§ã“ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿æœ‰ã—ã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ä¸€è¦§ãŒç¢ºèªã§ãã¾ã™ã€‚

https://minascan.io/devnet/token/xR7E8xvJo2bX2kFGLSqrA9XTrdZRq1L89BdLxt9N3gCGqonqyn/holders

## ã‚‚ã£ã¨ MinaProtocol ã‚’å­¦ã³ãŸã„äººã¯ãƒ»ãƒ»ãƒ»

ã“ã®è¨˜äº‹ã‚’èª­ã‚“ã§ã‚‚ã£ã¨ **MinaProtocol** ã‚’å‹‰å¼·ã—ãŸã„ã¨æ€ã£ãŸäººã¯ä»¥ä¸‹ã® **Youtube** ãŒå‚è€ƒã«ãªã‚Šã¾ã™ï¼

https://www.youtube.com/watch?v=LLule5GUkkg&t=4116s

https://www.youtube.com/watch?v=hEHxBJNWkJo

https://www.youtube.com/live/_sklhKIPobM

## å‚è€ƒæ–‡çŒ®

ä»Šå›ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ä¸Šã§å‚è€ƒã«ãªã£ãŸæ–‡çŒ®ã®ãƒªãƒ³ã‚¯ã‚’å…±æœ‰ã—ã¾ã™ï¼

1. [writing-a-zkapp](https://docs.minaprotocol.com/zkapps/writing-a-zkapp)
2. [zkapp-development-frameworks](https://docs.minaprotocol.com/zkapps/zkapp-development-frameworks)
3. [GitHub - mina-fungible-token](https://github.com/MinaFoundation/mina-fungible-token)
4. [Mina Fungible Token Documentation](https://minafoundation.github.io/mina-fungible-token/deploy.html)
5. [examples/zkapps/](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/)
6. [Mina Foundation Online Workshop for Building ZKApps with o1js](https://www.youtube.com/watch?v=LLule5GUkkg&t=4116s)
7. [ä½œæˆã—ãŸé–‹ç™ºç”¨ã‚¦ã‚©ãƒ¬ãƒƒãƒˆ](https://minascan.io/devnet/tx/5JuPC4hhNb83ufKmuRtj97jSSbdDURLTwTb6vmJL6k3Bv7Zi6uA7)
8. [ãƒ•ã‚¡ã‚¦ã‚»ãƒƒãƒˆç”¨ãƒªãƒ³ã‚¯](https://faucet.minaprotocol.com/?address=B62qoFHxcia11kauLdy6f9B8yfB9QUkMRDTJhrXoKEgkuDzDSGU9MgU&explorer=minascan)
9. [mina-fungible-token Docs](https://minafoundation.github.io/mina-fungible-token/)
10. [interacting-with-zkapps-server-side](https://docs.minaprotocol.com/zkapps/tutorials/interacting-with-zkapps-server-side)
11. [Tutorial 4: Build a zkApp UI in the Browser with React](https://docs.minaprotocol.com/zkapps/tutorials/zkapp-ui-with-react)
12. [GitHub - o1-labs-XT/workshop-slides](https://github.com/o1-labs-XT/workshop-slides/tree/main)
