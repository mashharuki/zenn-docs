---
title: "AI Agentã§DeFAIã‚’ä½œã£ã¦ã¿ã¦åˆ†ã‹ã£ãŸã“ã¨ï¼"
emoji: "ğŸ”¨"
type: "tech"
topics: ["AIAgent", "OpenAI", "Web3", "LangChain", "TypeScript"]
published: true
---

![0.jpg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1299653/0b1e29d0-2657-44b1-83c7-02026e65e7af.jpeg)

## ã¯ã˜ã‚ã«

çš†ã•ã‚“ã€ã“ã‚“ã«ã¡ã¯ï¼

å…ˆæ—¥ã€AI Agent ã‚’ä½¿ã£ã¦ **DeFAI** ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚’é–‹ç™ºã™ã‚‹æ©Ÿä¼šãŒã‚ã‚Šã¾ã—ãŸã®ã§ãã®æ™‚ã«åˆ†ã‹ã£ãŸã“ã¨ãªã©ã‚’è¨˜äº‹ã«ã—ã¦ã¾ã¨ã‚ã¦ã¿ã¾ã—ãŸï¼

ã“ã®ã‚ãŸã‚Šã«ã¤ã„ã¦æŠ€è¡“çš„ã«æ·±æ˜ã‚Šã•ã‚ŒãŸæ—¥æœ¬èªã®è¨˜äº‹ã¯ã¾ã å°‘ãªã„ã¨æ€ã„ã¾ã™ã®ã§ãœã²æœ€å¾Œã¾ã§èª­ã‚“ã§ã¿ã¦ãã ã•ã„ï¼

## DeFAI ã¨ã¯

ã¾ãšã€ **DeFAI** ã¨ã„ã†ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã¤ã„ã¦è§£èª¬ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚

Web3 ç•Œéšˆã«ã„ãªã„æ–¹ã¯é¦´æŸ“ã¿ãªã„ãƒ¯ãƒ¼ãƒ‰ã ã¨æ€ã„ã¾ã™ã€‚

**DeFAI** ã¨ã¯ **DeFi** ã¨ **AI** ã‚’çµ„ã¿åˆã‚ã›ãŸæ–°ã—ã„ç”¨èªã§ã™ï¼

https://coinpost.jp/?p=591072

24 å¹´ã®ç§‹é ƒã‹ã‚‰ã€å¸‚å ´ã§ã¯ CryptoÃ—AI ã®åˆ†é‡ã®æ³¨ç›®åº¦ãŒé«˜ã¾ã‚Šã€é–¢é€£ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒä¾¡æ ¼ä¸Šæ˜‡ã‚’è¦‹ã›ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¾ã§ã¯ AI Agent ã¨ã„ãˆã° X ã§è‡ªå¾‹çš„ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æŠ•ç¨¿ã—ã¦ã„ãã‚¨ãƒ³ã‚¿ãƒ¡çš„ãªå´é¢ã«æ³¨ç›®ã•ã‚ŒãŒã¡ã§ã—ãŸãŒã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’å¤§ããå‘ä¸Šã•ã›ã‚‹ã‚‚ã®ã¨ã—ã¦ DeFi ãªã©ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¸ã®å¿œç”¨ãŒæ³¨ç›®ã‚’é›†ã‚ã¦ã„ã¾ã—ãŸã€‚

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

ã§ã¯ã“ã“ã‹ã‚‰ä½œã£ãŸãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã®æ¦‚è¦ã«ã¤ã„ã¦å…±æœ‰ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

å‡ºå ´ã—ãŸãƒãƒƒã‚«ã‚½ãƒ³ã®æƒ…å ±ã‚„ GitHub ãƒªãƒã‚¸ãƒˆãƒªã¯ä»¥ä¸‹ã«ã¾ã¨ã‚ã•ã›ã¦ã„ãŸã ãã¾ã—ãŸã€‚

:::message
å‡ºå ´ã—ãŸãƒãƒƒã‚«ã‚½ãƒ³
:::

**Eth Global - Agentic Ethereum**

https://ethglobal.com/events/agents

**Google AI Agent Hackathon**

https://cloud.google.com/blog/ja/products/ai-machine-learning/lets-create-the-future-with-the-generative-ai-hackathon

:::message
GitHub ãƒªãƒã‚¸ãƒˆãƒª
:::

https://github.com/mashharuki/AgenticEthereum2025

:::message
Live demo
:::

https://agentic-ethereum2025.vercel.app/

:::message
ãƒ‡ãƒ¢å‹•ç”»
:::

ç´„ 3 åˆ†ã®ãƒ‡ãƒ¢å‹•ç”»ã§ã™

https://youtu.be/Iz8RTY9Y5O4

:::message
ãƒ—ãƒ¬ã‚¼ãƒ³ã‚¹ãƒ©ã‚¤ãƒ‰
:::

https://www.canva.com/design/DAGefDFBArA/_xcY_cQQbtkpVvVb0DZBLg/view?utm_content=DAGefDFBArA&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h830ea1c854

### æ¦‚è¦

ä»Šå›ã€ãƒãƒƒã‚«ã‚½ãƒ³ã§ä½œã£ãŸã®ã¯ãƒãƒ«ãƒ AI Agent ã§ãƒ©ã‚¤ãƒ–ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã‚’è¡Œã‚ã›ã¦è³‡ç”£ã‚’æœ€å¤§åŒ–ã™ã‚‹ãŸã‚ã® DeFi æ“ä½œã‚’é¸å®šã—ã¦ã‚‚ã‚‰ã„ã€ãã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã¾ã§ã‚’è‡ªå‹•çš„ã«å®Ÿæ–½ã—ã¦ã‚‚ã‚‰ã†ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚

AI Agent ã«ã¯ 6 ã¤ã®å½¹å‰²ã‚’ä¸ãˆã¦å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚

- **ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒˆãƒ¬ãƒ³ãƒ‰åé›†ã‚¹ãƒšã‚·ãƒ£ãƒªã‚¹ãƒˆ**
- **ãƒ‹ãƒ¥ãƒ¼ã‚¹ã¨åŸºæœ¬æƒ…å ±ã®ã‚¹ãƒšã‚·ãƒ£ãƒªã‚¹ãƒˆ**
- **ãƒªã‚¹ã‚¯ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**
- **åˆ†æã¨æˆ¦ç•¥ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**
- **å®Ÿè¡Œã¨é‹ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**

åŸºæœ¬çš„ã«ã¯ã€æƒ…å ±ã‚’åé›†ã—ã¦ãƒªã‚¹ã‚¯åˆ†æã‚„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ç›£è¦–ã•ã›ãŸå¾Œã«å®Ÿè¡Œã™ã‚‹å‡¦ç†ã‚’æ±ºã‚ã•ã›ã¦ã„ã¾ã™ã€‚

### ãªãœä½œã‚ã†ã¨æ€ã£ãŸã®ã‹ï¼Ÿ

**DeFi** ã«ãŠã‘ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å‘ä¸Šã‚’ç›®çš„ã«ä½œã‚ã†ã¨æ€ã£ãŸã“ã¨ãŒãã£ã‹ã‘ã§ã™ã€‚

ã¾ãšã€ **DeFi** ã«ã¯ã‹ãªã‚Šå°‚é–€çŸ¥è­˜ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚

Web3 ã®æŠ€è¡“çš„ãªçŸ¥è­˜ã€æœ€æ–°ã®ãƒˆãƒ¬ãƒ³ãƒ‰æƒ…å ±ä»¥å¤–ã«ã‚‚é‡‘èã®çŸ¥è­˜ã‚„ãã‚Œã«é–¢ã™ã‚‹ä¸–è«–ã®æƒ…å‹¢ãªã©è¤‡æ•°ã®é ˜åŸŸã«å¯¾ã—ã¦æ·±ã„çŸ¥è­˜ãŒå¿…è¦ã¨ãªã‚Šã¾ã™ã€‚

ãã®ãŸã‚ã€æ–°è¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ããªã‚Šä½¿ã„å§‹ã‚ã‚‹ã®ã«ã¯éå¸¸ã«ãƒãƒ¼ãƒ‰ãƒ«ãŒé«˜ããªã£ã¦ã—ã¾ã£ã¦ã„ã¾ã™ã€‚

ãã®ã‚®ãƒ£ãƒƒãƒ—ã‚’åŸ‹ã‚ã‚‹ãŸã‚ã«ä»•çµ„ã¿ãŒå¿…è¦ã ã¨æ„Ÿã˜ã¦ã„ã¾ã—ãŸã€‚

ãã®è§£æ±ºç­–ã¨ã—ã¦ AI Agent ãŒä½¿ãˆãªã„ã‹ã¨æ€ã£ã¦è©¦ã—ã¦ã¿ãŸã¨ã„ã†ã®ãŒå‹•æ©Ÿã§ã™ã€‚

ãŸã å˜ã«ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è‡ªå‹•ã§å®Ÿè¡Œã™ã‚‹ã ã‘ã§ãªãã€ãƒãƒ«ãƒ AI Agent ã«ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«è­°è«–ã•ã›ã¦è‡ªåˆ†ã®è³‡ç”£ã‚’æœ€ã‚‚åŠ¹ç‡ã‚ˆãå¢—ã‚„ã™æ–¹æ³•ã‚’è­°è«–ã—ã¦ã‚‚ã‚‰ã„ã€ãã®çµæœã¨ã—ã¦æœ€é©ãª DeFi æ“ä½œã‚’é¸å®šã—ã¦ã‚‚ã‚‰ã†ã¨ã„ã†éƒ¨åˆ†ã¾ã§ AI Agent ã«æ‹…å½“ã—ã¦ã‚‚ã‚‰ã†ã“ã¨ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã¯ãªã„ã‹ã¨è€ƒãˆã¾ã—ãŸã€‚

ãƒ‹ã‚³ãƒ‹ã‚³å‹•ç”»ã®ç”Ÿé…ä¿¡ã¿ãŸãã‚¨ãƒ³ã‚¿ãƒ¡æ€§ã‚‚æŒãŸã›ã¦ã¿ãŸã¨ã„ã†ã®ã‚‚æŒ‘æˆ¦ã®éƒ¨åˆ†ã§ã™ã€‚

AI é”ãŒã©ã‚“ãªçµè«–ã‚’å‡ºã™ã®ã‹ã¨ã„ã†ãƒ¯ã‚¯ãƒ¯ã‚¯æ„Ÿã‚‚æŒãŸã›ã¦ã¿ã¾ã—ãŸã€‚

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

:::message
ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
:::

ä»Šå›é–‹ç™ºã—ãŸãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å›³ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

![architecture.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/1299653/90f134d2-e574-4da0-8439-2a0399114d70.png)

AI Agent ç³»ã®å‡¦ç†ã¯ Hono ã§ä½œã£ãŸ API ã§å®Ÿè¡Œã•ã›ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ï¼

API ã®å®Ÿè¡Œç’°å¢ƒã¨ã—ã¦ã€ **Google Cloud** ã® **Cloud Run** ã‚’ä½¿ã£ã¦ã„ã¾ã™ï¼

https://cloud.google.com/run?hl=ja

**Fargate** ã‚ˆã‚Šã‚‚ç°¡å˜ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã§ãã‚‹ã®ã§ãŠã™ã™ã‚ã§ã™ï¼

AI Agent ç”¨ã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã®æƒ…å ±ã¯ã€ **Privy** ã® **server wallet** ã®æ©Ÿèƒ½ã‚’ä½¿ã£ã¦ã„ã¾ã™ï¼

æµçŸ³ã«ç’°å¢ƒå¤‰æ•°ã§ç§˜å¯†éµã‚’åŸ‹ã‚è¾¼ã‚€ã®ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çš„ã«ã‚ˆã‚ã—ããªã„ãªã¨æ€ã£ãŸã®ã§ã“ã®ã‚ˆã†ãªå®Ÿè£…ã¨ã—ã¦ã„ã¾ã™ï¼

:::message
æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ä¸€è¦§
:::

ä»Šå›ã€æ¡ç”¨ã—ãŸæŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€è¦§ã§ã™ï¼

Web3ã€AI ä»¥å¤–ã«ã‚‚ **Cluod Run** ãªã© Web2 ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚‚æ²¢å±±ä½¿ã„ã¾ã—ãŸï¼ï¼

| ã‚«ãƒ†ã‚´ãƒª      | ä½¿ç”¨æŠ€è¡“                                                                                         |
| :------------ | :----------------------------------------------------------------------------------------------- |
| Frontend      | TypeScript<br/> OnChain Kit<br/> Next.js<br/> Tailwind CSS<br/> Vercel                           |
| Backend       | TypeScript<br/> Cloud Run<br/> Hono                                                              |
| IasC          | CDK for Terraform                                                                                |
| LLM           | OpenAI<br/> Claude<br/> llama<br/> Gemini in Vertex AI                                           |
| AI Agent Kit  | LangChain<br/> LangGraph<br/> Groq Agent Kit<br/> Vertex AI                                      |
| Web3 Library  | viem<br/> wagmi<br/> Coinbase AgentKit<br/> Privy Server Wallet<br/> Autonome<br/> CoinGekko API |
| DeFi Protocol | Uniswap<br/> AAVE<br/> Lido<br/> EigenLayer                                                      |

**Autonome** ã¯ AI Agent ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã§ãã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã§ã€å…¬å¼ã«ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ(Docker Container ã‚¤ãƒ¡ãƒ¼ã‚¸)ä»¥å¤–ã«ã‚‚ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼

ä»¥ä¸‹ã¯ã€å®Ÿéš›ã«ãƒ—ãƒƒã‚·ãƒ¥ã—ã¦ã¿ãŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã™ï¼

https://apps.autono.meme/autonome/new?template=e57de5de-00e6-47c2-8e5e-ebdfbcda589b

Docker Hub ã«ã‚‚ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã—ã¦ã„ã¾ã™ï¼

https://hub.docker.com/repository/docker/haruki31067/autonome-cdp-custom/general

å‹•ãã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä½œã‚‹ã®ã«è‹¦åŠ´ã—ã¾ã—ãŸãŒã€ä¸€åº¦å‹•ã„ã¦ã—ã¾ãˆã°éå¸¸ã«ä½¿ã„ã‚„ã™ã„ã‚µãƒ¼ãƒ“ã‚¹ã§ã—ãŸï¼

## èª²é¡Œã¨è§£æ±ºç­–

çµ±åˆãƒ—ãƒ­ã‚»ã‚¹ã§ç›´é¢ã—ãŸèª²é¡Œã¨ã€ãã‚Œã‚’ã©ã®ã‚ˆã†ã«å…‹æœã—ãŸã‹ã‚’å¼·èª¿ã—ã¾ã™ã€‚æŠ€è¡“çš„ãªéšœå®³ã€ãƒ‡ã‚¶ã‚¤ãƒ³ã®è€ƒæ…®äº‹é …ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ã®å•é¡Œãªã©ã‚’å«ã‚ã¾ã™ã€‚

## ä¸»ãªå­¦ã³

ä»Šå›ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚’ä½œã£ã¦ã¿ã¦å¤§ããªå­¦ã³ãŒ 2 ã¤ã‚ã‚Šã¾ã—ãŸï¼

:::message
**DeFi ç”¨ã® AI Agent ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…æ–¹æ³•ã®ç¿’å¾—**
**ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒã‚§ã‚¤ãƒ‹ãƒ³ã‚°ã®é‡è¦æ€§ã®å†èªè­˜**
:::

ã“ã® 2 ã¤ã§ã™ã­ã€‚

Web3 ç”¨ã® AI Agent ãƒ„ãƒ¼ãƒ«ã®æ•°ã¯åœ§å€’çš„ã«å°‘ãªã„ã¨ã„ã†ã®ãŒç¾çŠ¶ã§ã™ã€‚ãã®ãŸã‚ã€ä»Šå›ã®ãƒãƒƒã‚«ã‚½ãƒ³ã§ã¯ AI Agent ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’æƒãˆã‚‹éƒ¨åˆ†ã‹ã‚‰å§‹ã‚ãªãã¦ã¯ãªã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

ãã®å®Ÿè£…æ–¹æ³•ãŒã‚ã‹ã‚‹ã¾ã§è‹¦åŠ´ã—ãŸã®ã§ã™ãŒã€ãªã‚“ã¨ã‹ãã®æ–¹æ³•ã‚’ç†è§£ã—ã€æœ€çµ‚çš„ã« 4 ã¤ã® DeFi ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’ä½œã‚‹ã“ã¨ãŒã§ããŸã®ã§ãã®è©³ç´°ã‚‚ã“ã®å¾Œå…±æœ‰ã•ã›ã¦ã„ãŸã ãã¾ã™ï¼

ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒã‚§ã‚¤ãƒ‹ãƒ³ã‚°ã®é‡è¦æ€§ã‚‚å†èªè­˜ã§ãã¾ã—ãŸã€‚

è¤‡æ•°ã® AI Agent ãŒãã‚Œãã‚Œä¸ãˆãŸå½¹å‰²ã‚’ã—ã£ã‹ã‚Šã¨ã“ãªã›ã‚‹ã‚ˆã†ã«ã€æ¸¡ã™ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®èª¿æ•´ã«åŠ›ã‚’å…¥ã‚Œã¾ã—ãŸã€‚

:::message
æœ€åˆã¯ã€

**ã†ã¾ãã„ã‹ãªãã¦ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚Œãªã„ãƒ»ãƒ»**

**å…¨ç„¶æ„å›³ã—ãªã„çµæœã«ãªã£ã¦ã—ã¾ã£ãŸãƒ»ãƒ»ãƒ»**

ãªã‚“ã¦ã“ã¨ãŒã‚ã‚Šã¾ã—ãŸã€‚
:::

ã“ã®ã‚ãŸã‚Šã‚‚å¾Œè¿°ã™ã‚‹ã®ã§ã™ãŒã€AI Agent ã«å‰²ã‚Šå½“ã¦ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å†…å®¹ã‚‚ã‹ãªã‚Šé‡è¦ã§ã‚ã‚‹ã“ã¨ã‚‚å­¦ã¶ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

## AI Agent ç”¨ã® DeFi ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…å†…å®¹ã«ã¤ã„ã¦

ã§ã¯ã“ã“ã‹ã‚‰å…·ä½“çš„ãªå®Ÿè£…å†…å®¹ã®è§£èª¬ã«ç§»ã‚Šã¾ã™ï¼

åŸºæœ¬çš„ã« LangChain å‘ã‘ã«å¤–éƒ¨ãƒ„ãƒ¼ãƒ«ã‚’è¿½åŠ ã™ã‚‹è¦é ˜ã§è¿½åŠ ã—ã¦ã„ãã“ã¨ãŒå¯èƒ½ã§ã™ï¼ï¼

AAVE ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç”¨ã®ãƒ„ãƒ¼ãƒ«ã ã‘ã¯ã€ Coinbase ã® SDK ã®ä»•æ§˜ã«åˆã†ã‚ˆã†ã«è‹¥å¹²å®Ÿè£…å†…å®¹ãŒç•°ãªã£ã¦ã„ã¾ã™ã€‚

### AAVE ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç”¨ã®ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…å†…å®¹

ã¾ãšã€AAVE ãƒ—ãƒ­ãƒˆã‚³ãƒ«ç”¨ã® DeFi ãƒ„ãƒ¼ãƒ«ã®è§£èª¬ã§ã™ï¼

ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€ **Coinbase** ã® **AI Agent** ç”¨ã«ä½œã‚Šã¾ã—ãŸï¼

**@coinbase/agentkit** ãŒæä¾›ã—ã¦ã„ã‚‹ `customActionProvider` ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚‹ã®ã§ã™ãŒã€æ±ºã‚ã‚‰ã‚ŒãŸé€šã‚Šã«è¨­å®šã—ã¦ã‚ã’ã‚‹ã“ã¨ã§ Coinbase AI Agent SDK ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè£…ã—ã¦ã‚ã’ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

å…·ä½“çš„ã«ã¯ä»¥ä¸‹ã®æ§˜ã«å®Ÿè£…ã—ã¦ã‚ã’ã‚Œã° OK ã§ã™ï¼ï¼

```ts
customActionProvider<EvmWalletProvider>({
  name: <ãƒ„ãƒ¼ãƒ«å>,
  description: <ãƒ„ãƒ¼ãƒ«ã®èª¬æ˜æ–‡>
  schema: <ãƒ„ãƒ¼ãƒ«ã®ã‚¹ã‚­ãƒ¼ãƒ>
  invoke: <å…·ä½“çš„ã«å®Ÿè¡Œã•ã›ãŸã„å‡¦ç†å†…å®¹>
});
```

ä»Šå›ã¯ã€AAVE ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ï¼

æ›¸ãè¾¼ã¿ç³»ã®å‡¦ç†ã ã‘ã§ãªãèª­ã¿è¾¼ã¿ç³»ã®å‡¦ç†ã‚‚å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼

ABI ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ãŸã‚Šã—ã¦ã„ã¾ã™ã€‚

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®å‡¦ç†ã®å‘¼ã³å‡ºã—ã«ã¯ **viem** ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚

```ts
import {
  type EvmWalletProvider,
  customActionProvider,
} from "@coinbase/agentkit";
import { http, createPublicClient, encodeFunctionData, parseUnits } from "viem";
import { baseSepolia } from "viem/chains";
import { z } from "zod";
import { AAVE_LENDING_POOL_ABI_TESTNET } from "../abis/aave_lending_pool_abi_testnet";
import { ERC20_ABI } from "../abis/erc20_abi";

// AAVE Lending Pool contract address (Base Sepolia)
const AAVE_LENDING_POOL_ADDRESS = "0x07eA79F68B2B3df564D0A34F8e19D9B1e339814b";

// Create a public Client
const client = createPublicClient({
  chain: baseSepolia,
  transport: http("https://sepolia.base.org"),
});

const BorrowCryptoInput = z
  .object({
    amount: z
      .number()
      .positive()
      .describe("The amount of cryptocurrency to borrow."),
    assetAddress: z
      .string()
      .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
      .transform((val) => val as `0x${string}`)
      .describe("The address of the cryptocurrency asset."),
  })
  .describe("Borrow crypto from AAVE Lending Pool");

const LendCryptoInput = z
  .object({
    amount: z
      .number()
      .positive()
      .describe("The amount of cryptocurrency to lend."),
    assetAddress: z
      .string()
      .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
      .transform((val) => val as `0x${string}`)
      .describe("The address of the cryptocurrency asset."),
  })
  .describe("Lend crypto to AAVE Lending Pool");

const GetUserAccountDataInput = z
  .object({
    userAddress: z
      .string()
      .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
      .transform((val) => val as `0x${string}`)
      .describe("The user's wallet address."),
  })
  .describe("Retrieve the user's account data from AAVE");

const GetTokenBalanceInput = z
  .object({
    tokenAddress: z
      .string()
      .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
      .transform((val) => val as `0x${string}`)
      .describe("The token contract address."),
    userAddress: z
      .string()
      .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
      .optional()
      .transform((val) => val as `0x${string}`)
      .describe("The user's wallet address (optional)."),
  })
  .describe("Get the token balance for the given token address.");

// ==========================================================================================
// Create various tools
//ã€€==========================================================================================

/**
 * Borrow crypto tool
 * @param wallet
 * @param args
 * @returns
 */
export const createBorrowCryptoToolForCdp =
  customActionProvider<EvmWalletProvider>({
    name: "borrow_crypto",
    description: "Borrow cryptocurrency from AAVE.",
    schema: BorrowCryptoInput,
    invoke: async (walletProvider, args) => {
      const { amount, assetAddress } = args;
      const interestRateMode = 2;

      console.log(`assetAddress: ${assetAddress}`);

      try {
        const decimals = (await client.readContract({
          abi: ERC20_ABI,
          address: assetAddress,
          functionName: "decimals",
        })) as number;

        const amountInWei = parseUnits(amount.toString(), decimals);

        console.log(`decimals: ${decimals}`);
        console.log(`Amount in Wei: ${amountInWei.toString()}`);

        // walletAddress
        const walletAddress = await walletProvider.getAddress();
        console.log("wallet address:", walletAddress);

        // borrow method call
        const borrowHash = await walletProvider.sendTransaction({
          to: AAVE_LENDING_POOL_ADDRESS,
          data: encodeFunctionData({
            abi: AAVE_LENDING_POOL_ABI_TESTNET,
            functionName: "borrow",
            args: [
              assetAddress,
              amountInWei.toString(),
              interestRateMode,
              0,
              walletAddress,
            ],
          }),
        });

        const result = await walletProvider.waitForTransactionReceipt(
          borrowHash
        );

        return `Borrow transaction : ${borrowHash}`;
      } catch (error) {
        console.error("Error executing lend_crypto:", error);
        return "Error executing lend_crypto";
      }
    },
  });

/**
 * Lend crypto tool
 * @param wallet
 * @param args
 * @returns
 */
export const createLendCryptoToolForCdp =
  customActionProvider<EvmWalletProvider>({
    name: "lend_crypto",
    description: "Lend cryptocurrency to AAVE.",
    schema: LendCryptoInput,
    invoke: async (walletProvider, args) => {
      const { amount, assetAddress } = args;

      try {
        console.log("assetAddress:", assetAddress);

        const decimals = (await client.readContract({
          abi: ERC20_ABI,
          address: assetAddress as `0x${string}`,
          functionName: "decimals",
        })) as number;

        const amountInWei = parseUnits(amount.toString(), decimals).toString();

        console.log(`decimals: ${decimals}`);
        console.log(`Amount in Wei: ${amountInWei}`);

        // walletAddress
        const walletAddress = await walletProvider.getAddress();
        console.log("wallet address:", walletAddress);

        // Transaction object
        const tx = {
          from: walletAddress as `0x${string}`,
          to: assetAddress as `0x${string}`,
          data: encodeFunctionData({
            abi: ERC20_ABI,
            functionName: "approve",
            args: [AAVE_LENDING_POOL_ADDRESS, amountInWei],
          }),
        };

        // approve method call
        const approveHash = await walletProvider.sendTransaction(tx);

        const result = await walletProvider.waitForTransactionReceipt(
          approveHash
        );

        console.log(`Approve transaction: ${approveHash}`);

        // supply method call
        const supplyHash = await await walletProvider.sendTransaction({
          from: walletAddress as `0x${string}`,
          to: AAVE_LENDING_POOL_ADDRESS,
          data: encodeFunctionData({
            abi: AAVE_LENDING_POOL_ABI_TESTNET,
            functionName: "supply",
            args: [assetAddress, amountInWei, walletAddress, 0],
          }),
        });

        const result2 = await walletProvider.waitForTransactionReceipt(
          supplyHash
        );

        console.log(`Supply transaction: ${supplyHash}`);

        return `Supply transaction hash: ${supplyHash}`;
      } catch (error) {
        console.error("Error executing lend_crypto:", error);
        return "Error executing lend_crypto";
      }
    },
  });

/**
 * Get user account data tool
 * @param wallet
 * @param args
 * @returns
 */
export const createGetUserAccountDataToolForCdp =
  customActionProvider<EvmWalletProvider>({
    name: "get_user_account_data",
    description: "Retrieve user account data from AAVE.",
    schema: GetUserAccountDataInput,
    invoke: async (walletProvider, args) => {
      const { userAddress } = args;
      // call getUserAccountData method
      const accountData = (await client.readContract({
        abi: AAVE_LENDING_POOL_ABI_TESTNET,
        address: AAVE_LENDING_POOL_ADDRESS,
        functionName: "getUserAccountData",
        args: [userAddress],
      })) as [bigint, bigint, bigint, bigint, bigint, bigint];

      return {
        totalCollateralBase: Number(accountData[0]),
        totalDebtBase: Number(accountData[1]),
        availableBorrowsBase: Number(accountData[2]),
        currentLiquidationThreshold: Number(accountData[3]),
        ltv: Number(accountData[4]),
        healthFactor: Number(accountData[5]) / 1e18,
      };
    },
  });

/**
 * Get token balance tool
 * @param wallet
 * @param args
 * @returns
 */
export const createGetTokenBalanceToolForCdp =
  customActionProvider<EvmWalletProvider>({
    name: "get_token_balance",
    description: "Get token balance for a given user.",
    schema: GetTokenBalanceInput,
    invoke: async (walletProvider, args) => {
      const { tokenAddress, userAddress } = args;
      // get user address
      const finalUserAddress =
        userAddress || (await walletProvider.getAddress());

      const balance = await client.readContract({
        abi: ERC20_ABI,
        address: tokenAddress,
        functionName: "balanceOf",
        args: [finalUserAddress],
      });

      const decimals = await client.readContract({
        abi: ERC20_ABI,
        address: tokenAddress,
        functionName: "decimals",
      });

      return Number(balance) / 10 ** (decimals as number);
    },
  });
```

zod ã‚’ä½¿ã£ã¦å¼•æ•°ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦ã„ã¾ã™ã€‚

ã“ã“ã¾ã§å…·ä½“çš„ã«å®Ÿè£…ã—ã¦ã‚ã’ãªã„ã¨ AI Agent ã« DeFi æ“ä½œã‚’ã•ã›ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

### Uniswap ç”¨ã®ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…å†…å®¹

åŒã˜æ§˜ã« uniswap ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸï¼

ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦ã¯ã€ **swap** ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã ã‘å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

**@langchain/core/tools** ã‹ã‚‰ `tool` ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€æ±ºã‚ã‚‰ã‚ŒãŸé€šã‚Šã«è¨­å®šã—ã¦ã‚ã’ã‚‹ã¨ AI Agent ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

å…·ä½“çš„ã«ã¯ä»¥ä¸‹ã®æ§˜ã«å®Ÿè£…ã—ã¾ã™ã€‚

```ts
// AI Agentç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’å®šç¾©ã™ã‚‹ã€‚
const newTool = tool(
  async (input: <å¼•æ•°>) => {
    <ãƒ„ãƒ¼ãƒ«ã§å‡¦ç†ã•ã›ãŸã„å‡¦ç†å†…å®¹>
  },
  {
    name: <ãƒ„ãƒ¼ãƒ«å>,
    description: <ãƒ„ãƒ¼ãƒ«ã®æ¦‚è¦>,
    schema: <ãƒ„ãƒ¼ãƒ«ã®ã‚¹ã‚­ãƒ¼ãƒ>
  },
);
```

**approve** ã‚„ **swap** ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

ã¾ãŸã€ Pool ã®æƒ…å ±ã‚’å–å¾—ã—ãŸã‚Šã€ã‚¯ã‚©ãƒ¼ãƒˆã®æƒ…å ±ã‚’å–å¾—ã—ãŸã‚Šã—ã¦ã„ã¾ã™ã€‚

ãã®è¾ºã®å®Ÿè£…æ–¹æ³•ã¯ **Viem ã§å®Ÿè£…ã™ã‚‹æ–¹æ³•ã¨åŒã˜ã§ã™!**

```ts
import { tool } from "@langchain/core/tools";
import * as dotenv from "dotenv";
import "dotenv/config";
import {
  http,
  createPublicClient,
  createWalletClient,
  formatUnits,
  parseUnits,
} from "viem";
import { sepolia } from "viem/chains";
import { z } from "zod";
import {
  createPrivyViemAccount,
  createPrivyWallet,
} from "../../../wallet/privy";
import { ERC20_ABI } from "../abis/erc20_abi";
import { FACTORY_ABI } from "../abis/uniswap/factory";
import { QUOTER_ABI } from "../abis/uniswap/quoter";
import { SWAP_ROUTER_ABI } from "../abis/uniswap/swaprouter";

dotenv.config();

const { ALCHEMY_API_KEY } = process.env;

// Deployment Addresses
const POOL_FACTORY_CONTRACT_ADDRESS =
  "0x0227628f3F023bb0B980b67D528571c95c6DaC1c";
const QUOTER_CONTRACT_ADDRESS = "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3";
const SWAP_ROUTER_CONTRACT_ADDRESS =
  "0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E";

// Set up clients
const publicClient = createPublicClient({
  chain: sepolia,
  transport: http(`https://eth-sepolia.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
});

const walletClient = createWalletClient({
  chain: sepolia,
  transport: http(`https://eth-sepolia.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
});

/**
 * Method for approving a token
 */
async function approveToken(tokenAddress: `0x${string}`, amount: bigint) {
  try {
    // call approve tx
    const approveTx = await walletClient.writeContract({
      account: await createPrivyViemAccount(),
      abi: ERC20_ABI,
      address: tokenAddress,
      functionName: "approve",
      args: [SWAP_ROUTER_CONTRACT_ADDRESS, amount],
    });

    console.log("-------------------------------");
    console.log("Sending Approval Transaction...");
    console.log(`Transaction Sent: ${approveTx}`);
    console.log("-------------------------------");

    const receipt = await publicClient.waitForTransactionReceipt({
      hash: approveTx,
    });
    console.log(
      `Approval Transaction Confirmed! https://sepolia.etherscan.io/txn/${receipt.transactionHash}`
    );
  } catch (error) {
    console.error("An error occurred during token approval:", error);
    throw new Error("Token approval failed");
  }
}

/**
 * Method for obtaining pool information
 */
async function getPoolInfo(tokenIn: `0x${string}`, tokenOut: `0x${string}`) {
  const poolAddress = await publicClient.readContract({
    address: POOL_FACTORY_CONTRACT_ADDRESS,
    abi: FACTORY_ABI,
    functionName: "getPool",
    args: [tokenIn, tokenOut, 3000],
  });
  if (!poolAddress) {
    throw new Error("Failed to get pool address");
  }
  return poolAddress;
}

/**
 * Method for obtaining a swap quote
 */
async function quoteAndLogSwap(
  tokenIn: `0x${string}`,
  tokenOut: `0x${string}`,
  amountIn: bigint,
  decimals: number
) {
  // walllet data
  const walletData = await createPrivyWallet();

  const quotedAmountOut = await publicClient.readContract({
    address: QUOTER_CONTRACT_ADDRESS,
    abi: QUOTER_ABI,
    functionName: "quoteExactInputSingle",
    args: [
      {
        tokenIn: tokenIn,
        tokenOut: tokenOut,
        fee: 3000,
        recipient: walletData.address,
        deadline: Math.floor(new Date().getTime() / 1000 + 60 * 10),
        amountIn: amountIn,
        sqrtPriceLimitX96: 0,
      },
    ],
  });
  console.log("-------------------------------");
  // Clean up output if necessary
  return formatUnits(quotedAmountOut[0].toString(), decimals);
}

/**
 * Method to perform the swap.
 */
async function executeSwap(
  tokenIn: `0x${string}`,
  tokenOut: `0x${string}`,
  amountIn: bigint,
  amountOutMinimum: bigint
) {
  // walllet data
  const walletData = await createPrivyWallet();
  // call swap function
  const swapTx = await walletClient.writeContract({
    account: await createPrivyViemAccount(),
    address: SWAP_ROUTER_CONTRACT_ADDRESS,
    abi: SWAP_ROUTER_ABI,
    functionName: "exactInputSingle",
    args: [
      {
        tokenIn: tokenIn,
        tokenOut: tokenOut,
        fee: 3000,
        recipient: walletData.address,
        amountIn: amountIn,
        amountOutMinimum: amountOutMinimum,
        sqrtPriceLimitX96: 0,
      },
    ],
  });
  console.log("-------------------------------");
  console.log(`Swap Transaction Sent: ${swapTx}`);
  console.log("-------------------------------");
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: swapTx,
  });
  console.log(
    `Swap Transaction Confirmed! https://sepolia.etherscan.io/tx/${receipt.transactionHash}`
  );

  return receipt.transactionHash;
}

/**
 * Tools for swapping cryptocurrency
 * @param fromTokenAddress
 * @param toTokenAddress
 * @param amount
 * @returns
 */
const swapTokens = tool(
  async (input: {
    fromTokenAddress: `0x${string}`;
    toTokenAddress: `0x${string}`;
    amount: number;
  }) => {
    try {
      const { fromTokenAddress, toTokenAddress, amount } = input;

      // Get the Decimals of the token to be converted.
      const fromTokenDecimals = (await publicClient.readContract({
        abi: ERC20_ABI,
        address: fromTokenAddress,
        functionName: "decimals",
      })) as number;

      // Get the Decimals of the destination token
      const toTokenDecimals = (await publicClient.readContract({
        abi: ERC20_ABI,
        address: toTokenAddress,
        functionName: "decimals",
      })) as number;

      console.log(`fromTokenDecimals: ${fromTokenDecimals}`);
      console.log(`toTokenDecimals: ${toTokenDecimals}`);
      // Convert units.
      const amountInWei = parseUnits(amount.toString(), fromTokenDecimals);
      console.log(`amountInWei: ${amountInWei}`);

      // Approve the token
      await approveToken(fromTokenAddress, amountInWei);
      // Retrieve pool information
      const poolAddress = await getPoolInfo(fromTokenAddress, toTokenAddress);
      console.log(`Pool Address: ${poolAddress}`);
      // Get the Swap quote
      const quotedAmountOut = await quoteAndLogSwap(
        fromTokenAddress,
        toTokenAddress,
        amountInWei,
        toTokenDecimals
      );
      // Convert from decimal to integer
      const minAmountOutBigInt = BigInt(
        Math.floor(Number(quotedAmountOut) * 10 ** toTokenDecimals)
      );
      // Execute swap
      const txHash = await executeSwap(
        fromTokenAddress,
        toTokenAddress,
        amountInWei,
        minAmountOutBigInt
      );

      return txHash;
    } catch (error) {
      console.error("Error in SwapTokensTool:", error);
      return null;
    }
  },
  {
    name: "swap_tokens",
    description:
      "Swap a specified amount of one cryptocurrency token for another.",
    schema: z.object({
      amount: z
        .number()
        .positive()
        .describe("The amount of cryptocurrency to swap."),
      fromTokenAddress: z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
        .transform((val) => val as `0x${string}`)
        .describe("The address of the token to swap from."),
      toTokenAddress: z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
        .transform((val) => val as `0x${string}`)
        .describe("The address of the token to swap to."),
    }),
  }
);

export { swapTokens };
```

### Lido ç”¨ã®ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…å†…å®¹

ã§ã¯ã©ã‚“ã©ã‚“ã„ãã¾ã™ï¼

**Lido** ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚‚åŒã˜ã‚ˆã†ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼ï¼

```ts
import { tool } from "@langchain/core/tools";
import * as dotenv from "dotenv";
import "dotenv/config";
import {
  http,
  createPublicClient,
  createWalletClient,
  formatUnits,
  parseUnits,
} from "viem";
import { holesky } from "viem/chains";
import { z } from "zod";
import {
  createPrivyViemAccount,
  createPrivyWallet,
} from "../../../wallet/privy";
import { ERC20_ABI } from "../abis/erc20_abi";

dotenv.config();

const { ALCHEMY_API_KEY } = process.env;

// Lido contract information
const LIDO_ABI = [
  {
    constant: false,
    inputs: [{ name: "_referral", type: "address" }],
    name: "submit",
    outputs: [{ name: "", type: "uint256" }],
    payable: true,
    stateMutability: "payable",
    type: "function",
  },
];

// Lido contract address(Holesky)
const LIDO_ADDRESS = "0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034";

// Set up clients
const publicClient = createPublicClient({
  chain: holesky,
  transport: http(`https://eth-holesky.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
});

// Create a wallet client
const walletClient = createWalletClient({
  chain: holesky,
  transport: http(`https://eth-holesky.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
});

/**
 * Method to obtain the ETH balance
 * @param walletAddress
 * @returns
 */
async function getETHBalance(walletAddress: `0x${string}`) {
  const balance = await publicClient.getBalance({ address: walletAddress });
  console.log(`ETH Balance: ${balance}`);
  return formatUnits(balance, 18);
}

/**
 * Method to obtain the stETH balance
 * @param walletAddress
 * @param tokenAddress
 * @returns
 */
async function getERC20Balance(
  walletAddress: `0x${string}`,
  tokenAddress: `0x${string}`
) {
  const balance = await publicClient.readContract({
    abi: ERC20_ABI,
    address: tokenAddress,
    functionName: "balanceOf",
    args: [walletAddress],
  });
  console.log(`ERC20 Balance: ${balance}`);
  return formatUnits(balance as bigint, 18);
}

/**
 * Stake cryptocurrency using Lido Contract
 */
const stakeWithLido = tool(
  async (input: { referralAddress: `0x${string}`; amount: number }) => {
    try {
      const { referralAddress, amount } = input;
      // Parse the amount to Wei
      const amountInWei = parseUnits(amount.toString(), 18);

      console.log(`Staking ${amount} ETH (${amountInWei} Wei) with Lido...`);

      // Execute the transaction
      const txHash = await walletClient.writeContract({
        account: await createPrivyViemAccount(),
        abi: LIDO_ABI,
        address: LIDO_ADDRESS,
        functionName: "submit",
        args: [referralAddress],
        value: amountInWei,
      });

      console.log(`Transaction sent: ${txHash}`);

      // Waiting for transaction completion
      await publicClient.waitForTransactionReceipt({ hash: txHash });

      return txHash;
    } catch (error) {
      console.error("Error in stakeWithLido:", error);
      return null;
    }
  },
  {
    name: "stake_with_lido",
    description: "Stake a specified amount of cryptocurrency with Lido.",
    schema: z.object({
      amount: z
        .number()
        .positive()
        .describe("The amount of cryptocurrency to stake."),
      referralAddress: z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
        .transform((val) => val as `0x${string}`)
        .describe("The referral address for Lido staking."),
    }),
  }
);

/**
 * Get the balances of ETH and stETH for the connected wallet.
 */
const getEthAndStEthBalances = tool(
  async () => {
    try {
      // Create a privy Wallet instance
      const walletData = await createPrivyWallet();
      // Get the Wallet address from walletData
      const walletAddress = walletData.address;

      console.log(`Getting balances for wallet: ${walletAddress}`);

      // ETH balance
      const ethBalance = await getETHBalance(walletAddress as `0x${string}`);

      // stETH balance
      const stETHBalance = await getERC20Balance(
        walletAddress as `0x${string}`,
        LIDO_ADDRESS
      );

      return {
        ethBalance,
        stETHBalance,
      };
    } catch (error) {
      console.error("Error in getBalancesTool:", error);
      return null;
    }
  },
  {
    name: "get_balances",
    description: "Get the balances of ETH and stETH for the connected wallet.",
  }
);

export { getEthAndStEthBalances, stakeWithLido };
```

### Eidgen Layer ç”¨ã®ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…å†…å®¹

æœ€å¾Œã« **Eidgen Layer** ç”¨ã®ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…å†…å®¹ã«ã¤ã„ã¦å…±æœ‰ã—ã¦ã„ãã¾ã™ï¼

åŸºæœ¬çš„ã«ã¯ã“ã‚Œã¾ã§ã¨åŒã˜æµã‚Œã§ã™ï¼

```ts
import { tool } from "@langchain/core/tools";
import * as dotenv from "dotenv";
import "dotenv/config";
import { http, createPublicClient, createWalletClient, parseUnits } from "viem";
import { holesky } from "viem/chains";
import { z } from "zod";
import { createPrivyViemAccount } from "../../../wallet/privy";
import { ERC20_ABI } from "../abis/erc20_abi";

dotenv.config();

const { ALCHEMY_API_KEY } = process.env;

// EIGENLAYER contract information
const EIGENLAYER_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "strategy",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "depositIntoStrategy",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
];

// EigenLayer contract address(Holesky)
const EIGENLAYER_ADDRESS = "0xdfB5f6CE42aAA7830E94ECFCcAd411beF4d4D5b6";

// Set up clients
const publicClient = createPublicClient({
  chain: holesky,
  transport: http(`https://eth-holesky.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
});

// Create a wallet client
const walletClient = createWalletClient({
  chain: holesky,
  transport: http(`https://eth-holesky.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
});

/**
 * reStake cryptocurrency using EigenLayer Contract
 */
const reStake = tool(
  async (input: { assetAddress: `0x${string}`; amount: number }) => {
    try {
      const { assetAddress, amount } = input;
      // Get the token decimals.
      const decimals = (await publicClient.readContract({
        abi: ERC20_ABI,
        address: assetAddress,
        functionName: "decimals",
      })) as number;

      console.log(`Decimals: ${decimals}`);
      // Convert units
      const amountInWei = parseUnits(amount.toString(), decimals);
      console.log(`amountInWei: ${amountInWei}`);

      // Execute the approval transaction
      const approveHash = await walletClient.writeContract({
        account: await createPrivyViemAccount(),
        abi: ERC20_ABI,
        address: assetAddress,
        functionName: "approve",
        args: [EIGENLAYER_ADDRESS, amountInWei],
      });
      console.log(`Approval transaction hash: ${approveHash}`);

      // Wait for approval completion.
      await publicClient.waitForTransactionReceipt({ hash: approveHash });

      // Execute the transaction
      const txHash = await walletClient.writeContract({
        account: await createPrivyViemAccount(),
        abi: EIGENLAYER_ABI,
        address: EIGENLAYER_ADDRESS,
        functionName: "depositIntoStrategy",
        args: [
          "0x7D704507b76571a51d9caE8AdDAbBFd0ba0e63d3",
          assetAddress,
          amountInWei,
        ],
      });

      console.log(`ReStaking Transaction sent: ${txHash}`);

      // Waiting for transaction completion
      await publicClient.waitForTransactionReceipt({ hash: txHash });

      return txHash;
    } catch (error) {
      console.error("Error in reStake:", error);
      return null;
    }
  },
  {
    name: "restake",
    description:
      "reStake a specified amount of cryptocurrency using EigenLayer Contract.",
    schema: z.object({
      amount: z
        .number()
        .positive()
        .describe("The amount of cryptocurrency to reStake."),
      assetAddress: z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
        .transform((val) => val as `0x${string}`)
        .describe("The asset Address for reStaking."),
    }),
  }
);

export { reStake };
```

### AI Agent ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã« DeFi ãƒ„ãƒ¼ãƒ«ã‚’å‰²ã‚Šå½“ã¦ã‚‹æ–¹æ³•

ã§ã¯ã“ã“ã‹ã‚‰ã¯ã€ä¸Šè¨˜ã§å®Ÿè£…ã—ãŸãƒ„ãƒ¼ãƒ«ã‚’ã©ã®ã‚ˆã†ã« AI Agent ç”¨ã® SDK ã«å‰²ã‚Šå½“ã¦ã¦ã„ãæ–¹æ³•ã‚’è§£èª¬ã—ã¾ã™ã€‚

#### Coinbase AI Agent SDK ã«ãƒ„ãƒ¼ãƒ«ã‚’è¿½åŠ ã™ã‚‹æ–¹æ³•

**@coinbase/agentkit** ãŒæä¾›ã—ã¦ã„ã‚‹ AgentKit ã® `from` ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã«å‰²ã‚Šå½“ã¦ãŸã„ãƒ„ãƒ¼ãƒ«ç¾¤ã‚’å¼•æ•°ã«ã‚»ãƒƒãƒˆã™ã‚‹ã“ã¨ã§å®Œäº†ã—ã¾ã™ï¼

ä»Šå›ã ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼

`createCdpAgentKitTools` ãƒ¡ã‚½ãƒƒãƒ‰ã§ AI Agent ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ãŸå¾Œã« **@langchain/langgraph/prebuilt** ãŒæä¾›ã—ã¦ã„ã‚‹ **createReactAgent** ãƒ¡ã‚½ãƒƒãƒ‰ã§ AI Agent ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã£ã¦ã„ã¾ã™ï¼

```ts
import * as fs from "node:fs";
import {
  AgentKit,
  CdpWalletProvider,
  cdpApiActionProvider,
  cdpWalletActionProvider,
  erc20ActionProvider,
  pythActionProvider,
  walletActionProvider,
  wethActionProvider,
} from "@coinbase/agentkit";
import { getLangChainTools } from "@coinbase/agentkit-langchain";
import { HumanMessage } from "@langchain/core/messages";
import { MemorySaver } from "@langchain/langgraph";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { ChatOpenAI } from "@langchain/openai";
import * as dotenv from "dotenv";
import {
  createBorrowCryptoToolForCdp,
  createGetTokenBalanceToolForCdp,
  createGetUserAccountDataToolForCdp,
  createLendCryptoToolForCdp,
} from "./tools/cdp/cdpAaveTool";
import { createSignMessageTool } from "./tools/cdp/signMessage";

dotenv.config();

const {
  OPENAI_API_KEY,
  NETWORK_ID,
  CDP_API_KEY_NAME,
  CDP_API_KEY_PRIVATE_KEY,
} = process.env;

// Configure a file to persist the agent's CDP MPC Wallet Data
const WALLET_DATA_FILE = "wallet_data.txt";

/**
 * get tools for Coinbase Developer Platform AgentKit
 */
export const createCdpAgentKitTools = async () => {
  let walletDataStr: string | null = null;

  // Read existing wallet data if available
  if (fs.existsSync(WALLET_DATA_FILE)) {
    try {
      walletDataStr = fs.readFileSync(WALLET_DATA_FILE, "utf8");
      // console.log("Read wallet data:", walletDataStr);
    } catch (error) {
      console.error("Error reading wallet data:", error);
      // Continue without wallet data
    }
  }

  // Configure CDP AgentKit
  const config = {
    apiKeyName: CDP_API_KEY_NAME,
    apiKeyPrivateKey: CDP_API_KEY_PRIVATE_KEY?.replace(/\\n/g, "\n"),
    cdpWalletData: walletDataStr || undefined,
    networkId: NETWORK_ID || "base-sepolia",
  };

  // Initialize CDP Wallet Provider
  const walletProvider = await CdpWalletProvider.configureWithWallet(config);

  console.log("Wallet Provider initialized");

  // Initialize AgentKit
  const agentkit = await AgentKit.from({
    walletProvider,
    actionProviders: [
      wethActionProvider(),
      pythActionProvider(),
      walletActionProvider(),
      erc20ActionProvider(),
      cdpApiActionProvider({
        apiKeyName: CDP_API_KEY_NAME,
        apiKeyPrivateKey: CDP_API_KEY_PRIVATE_KEY?.replace(/\\n/g, "\n"),
      }),
      cdpWalletActionProvider({
        apiKeyName: CDP_API_KEY_NAME,
        apiKeyPrivateKey: CDP_API_KEY_PRIVATE_KEY?.replace(/\\n/g, "\n"),
      }),
      createSignMessageTool(),
      createGetTokenBalanceToolForCdp,
      createGetUserAccountDataToolForCdp,
      createBorrowCryptoToolForCdp,
      createLendCryptoToolForCdp,
    ],
  });

  // Acquire external tools
  const cdpAgentKitTools = await getLangChainTools(agentkit);

  return { agentkit, cdpAgentKitTools, walletProvider };
};

/**
 * Initialize the agent with CDP AgentKit method
 * @returns Agent executor and config
 */
export const initializeCdpAgent = async (systemPrompt: string) => {
  // Initialize LLM
  const llm = new ChatOpenAI({
    model: "gpt-3.5-turbo",
    apiKey: OPENAI_API_KEY,
    // apiKey: "gaia",
    /*
    configuration: {
      baseURL: "https://llamatool.us.gaianet.network/v1",
    },
    */
  });

  // create CDP AgentKit tools
  const { agentkit, cdpAgentKitTools, walletProvider } =
    await createCdpAgentKitTools();

  // Store buffered conversation history in memory
  const memory = new MemorySaver();
  const agentConfig = {
    configurable: { thread_id: "CDP AgentKit Chatbot Example!" },
  };

  // Create React Agent using the LLM and CDP AgentKit tools
  const agent = createReactAgent({
    llm,
    tools: cdpAgentKitTools,
    checkpointSaver: memory,
    stateModifier: systemPrompt,
  });

  // Save wallet data
  const exportedWallet = await walletProvider.exportWallet();
  fs.writeFileSync(WALLET_DATA_FILE, JSON.stringify(exportedWallet));

  return { agent, config: agentConfig };
};
```

å®Ÿéš›ã«å‡¦ç†ã‚’å‘¼ã³å‡ºã™ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã‚ã’ã‚Œã° OK ã§ã™ï¼

```ts
/**
 * Run the agent interactively based on user input
 *
 * @param agent - The agent executor
 * @param config - Agent configuration
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const runCdpChatMode = async (systemPrompt: string, prompt: string) => {
  console.log("Starting ... ");

  const response: string[] = [];

  try {
    // get agent and config
    const { agent, config } = await initializeCdpAgent(systemPrompt);

    // call AI API
    const stream = await agent.invoke(
      { messages: [new HumanMessage(prompt)] },
      config
    );

    console.log(
      "Stream output:",
      stream.messages[stream.messages.length - 1].content.toString()
    );

    response.push(
      "===================================================================="
    );
    response.push(
      stream.messages[stream.messages.length - 1].content.toString()
    );
    response.push(
      "===================================================================="
    );

    return response;
  } catch (error) {
    console.error("Error running chat mode:", error);
    return response;
  }
};
```

#### LangChain ã§ä½œã£ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãƒ„ãƒ¼ãƒ«ã‚’è¿½åŠ ã™ã‚‹æ–¹æ³•

ç¶šã„ã¦ **LangChain** ã® SDK ã§ç”Ÿæˆã™ã‚‹ AI Agent ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãƒ„ãƒ¼ãƒ«ã‚’å‰²ã‚Šå½“ã¦ã‚‹æ–¹æ³•ã‚’è§£èª¬ã—ã¾ã™ï¼

**@langchain/langgraph/prebuilt** ãŒæä¾›ã—ã¦ã„ã‚‹ **ToolNode** ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ãŒã‚ã‚‹ã®ã§ã€ä½œã£ãŸãƒ„ãƒ¼ãƒ«ç¾¤ã‚’å¼•æ•°ã«ã—ã¦åˆæœŸåŒ–ã—ã¦ã‚ã’ã‚Œã°æº–å‚™ OK ã§ã™ï¼

ä»Šå›ã ã¨ä»¥ä¸‹ã®æ§˜ãªå®Ÿè£…ã«ãªã£ã¦ã„ã¾ã™ï¼

å½¹å‰²ã”ã¨ã« AI Agent ã«å‰²ã‚Šå½“ã¦ã‚‹ãƒ„ãƒ¼ãƒ«ã‚’å¤‰ãˆãŸã®ã§è¤‡æ•°ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¦ã„ã¾ã™ã€‚

**Tavily** ã¯ Web æ¤œç´¢ç”¨ã® AI Agent ç”¨ã®ãƒ„ãƒ¼ãƒ«ã§ã™ï¼ã‚ˆããƒãƒ³ã‚ºã‚ªãƒ³ã¨ã‹ã§ç´¹ä»‹ã•ã‚Œã‚‹ã‚„ã¤ã§ã™ã­ï¼

https://tavily.com/

```ts
import { TavilySearchResults } from "@langchain/community/tools/tavily_search";
import { ToolNode } from "@langchain/langgraph/prebuilt";
import * as dotenv from "dotenv";
import {
  borrowCryptoForArbitrumSepolia,
  getTokenBalanceForArbitrumSepolia,
  getUserAccountDataForArbitrumSepolia,
  lendCryptoForArbitrumSepolia,
} from "./arbitrumSepolia/aaveTool";
import { getTrendingTokens } from "./coinGeckoTool";
import { reStake } from "./holesky/eigenlayerTool";
import { getEthAndStEthBalances, stakeWithLido } from "./holesky/lidoTool";
import {
  borrowCrypto,
  getTokenBalance,
  getUserAccountData,
  lendCrypto,
} from "./sepolia/aaveTool";
import { swapTokens } from "./sepolia/uniswapTool";

dotenv.config();

const { TAVILY_API_KEY } = process.env;

// Tavily Search Results Tools
export const search = new TavilySearchResults({
  apiKey: TAVILY_API_KEY,
  maxResults: 3,
});

/**
 * Create tools for the Crypto Assistant AI Agent
 * Swap uniswap
 * Lend AAVE
 * Borrow AAVE
 * Check token balance
 * Stake ETH
 * ReStake stETH
 */
export const createDeFiTools = () => {
  const tools = [
    getTokenBalance,
    getUserAccountData,
    lendCrypto,
    borrowCrypto,
    swapTokens,
    getEthAndStEthBalances,
    stakeWithLido,
    getTokenBalanceForArbitrumSepolia,
    getUserAccountDataForArbitrumSepolia,
    lendCryptoForArbitrumSepolia,
    borrowCryptoForArbitrumSepolia,
    reStake,
  ];

  const toolNode = new ToolNode(tools);
  return toolNode;
};

/**
 * getter Token balance tools for the Assistant AI Agent
 * @returns
 */
export const createTokenBalanceTools = () => {
  const tools = [
    getTokenBalance,
    getUserAccountData,
    getEthAndStEthBalances,
    getTokenBalanceForArbitrumSepolia,
    getUserAccountDataForArbitrumSepolia,
  ];

  const toolNode = new ToolNode(tools);
  return toolNode;
};

/**
 * Create research tools for the Assistant AI Agent
 */
export const createReserchTools = () => {
  // get tools
  const tools = [search, getTrendingTokens];

  const toolNode = new ToolNode(tools);
  return toolNode;
};

/**
 * create Analysis and Reasoning tools for the Assistant AI Agent
 */
export const createanalysisTools = () => {
  // get tools
  const tools = [
    search,
    getTrendingTokens,
    getTokenBalance,
    getUserAccountData,
    getEthAndStEthBalances,
    getTokenBalanceForArbitrumSepolia,
    getUserAccountDataForArbitrumSepolia,
  ];

  const toolNode = new ToolNode(tools);
  return toolNode;
};
```

ãƒ„ãƒ¼ãƒ«ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã“ã‚Œã‚‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã‚ã’ã‚‹ã“ã¨ã§ç”Ÿæˆã§ãã¾ã™ã€‚

AI Agent ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å‰²ã‚Šå½“ã¦ã‚‹ã«ã¯ä»¥ä¸‹ã®æ§˜ã«å®Ÿè£…ã™ã‚Œã° OK ã§ã™ï¼

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ **OpenAI ã® LLM** ã‚’ä½¿ç”¨ã—ãŸå ´åˆã®å®Ÿè£…æ–¹æ³•ã§ã™ã€‚

```ts
import { HumanMessage } from "@langchain/core/messages";
import { MemorySaver } from "@langchain/langgraph";
import { type ToolNode, createReactAgent } from "@langchain/langgraph/prebuilt";
import { ChatOpenAI } from "@langchain/openai";

import * as dotenv from "dotenv";

dotenv.config();

const { OPENAI_API_KEY } = process.env;

/**
 * OpenAIã®LLMã‚’ä½¿ã£ã¦AI Agentç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
 */
export const createOpenAIAIAgent = (
  agentTools: ToolNode,
  systemPrompt: string
) => {
  // Initialize memory to persist state between graph runs
  const agentCheckpointer = new MemorySaver();
  const agentModel = new ChatOpenAI({
    apiKey: OPENAI_API_KEY,
    temperature: 0,
  });

  // AI Agentç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’s
  const agent = createReactAgent({
    llm: agentModel,
    tools: agentTools,
    checkpointSaver: agentCheckpointer,
    stateModifier: systemPrompt,
  });

  return agent;
};
```

**Anthropic ç¤¾ã® claude** ã‚’ä½¿ã£ã¦ã“ã‚Œã‚‰ã®ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™ã“ã¨ã‚‚ã‚‚ã¡ã‚ã‚“å¯èƒ½ã§ã™ï¼

æµã‚Œã¯ Open AI ã®æ™‚ã¨ã»ã¼åŒã˜ã§ã€ä»¥ä¸‹ã®æ§˜ãªå®Ÿè£…ã¨ã™ã‚Œã°è‰¯ã„ã§ã™ï¼

```ts
import { type BaseChatModel, ChatAnthropic } from "@langchain/anthropic";
import type { BaseChatModelCallOptions } from "@langchain/core/language_models/chat_models";
import { type AIMessageChunk, HumanMessage } from "@langchain/core/messages";
import { MemorySaver } from "@langchain/langgraph";
import { type ToolNode, createReactAgent } from "@langchain/langgraph/prebuilt";

import * as dotenv from "dotenv";

dotenv.config();

const { ANTHROPIC_KEY_API } = process.env;

/**
 * Method for creating an instance for an AI Agent using Anthropic's LLM
 */
export const createAnthropicAIAgent = (
  agentTools: ToolNode,
  systemPrompt: string
) => {
  // Initialize memory to persist state between graph runs
  const agentCheckpointer = new MemorySaver();
  // create a new instance of the ChatAnthropic model
  const agentModel: BaseChatModel<BaseChatModelCallOptions, AIMessageChunk> =
    new ChatAnthropic({
      model: "claude-3-5-sonnet-latest",
      apiKey: ANTHROPIC_KEY_API,
    });

  // Generate an instance for AI Agent
  const agent = createReactAgent({
    llm: agentModel,
    tools: agentTools,
    checkpointSaver: agentCheckpointer,
    stateModifier: systemPrompt,
  });

  return agent;
};

/**
 * Call the AI method using Anthropic Agent
 */
export const runAnthropicAIAgent = async (
  tools: ToolNode,
  systemPrompt: string,
  prompt: string
) => {
  // Create an instance for the AI agent
  const agent = createAnthropicAIAgent(tools, systemPrompt);

  // Let's try running an AI inference
  const agentNextState = await agent.invoke(
    { messages: [new HumanMessage(prompt)] },
    { configurable: { thread_id: "44" } }
  );

  const response =
    agentNextState.messages[agentNextState.messages.length - 1].content;

  console.log(response);

  return response;
};
```

**Google Cloud** ãŒæä¾›ã—ã¦ã„ã‚‹ **Gemini in Vertex AI** ã«ã‚‚å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ï¼

ä¸Š 2 ã¤ã®æ™‚ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«æ¯”ã¹ã¦ã‹ãªã‚Šè¤‡é›‘ã«ãªã£ã¦ã—ã¾ã™ã€‚

**LangChain** ä»¥å¤–ã«ã‚‚ **LangGraph** ã‚‚ä½¿ã£ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

```ts
import {
  type GenerativeModel,
  HarmBlockThreshold,
  HarmCategory,
  VertexAI,
} from "@google-cloud/vertexai";
import { HumanMessage } from "@langchain/core/messages";
import { MessagesAnnotation, StateGraph } from "@langchain/langgraph";
import { ToolNode } from "@langchain/langgraph/prebuilt";
import * as dotenv from "dotenv";
import { search } from "./tools/util";

dotenv.config();

const { PROJECT_ID, REGION } = process.env;

/**
 * Specify the tools to be assigned to the AI Agent.
 */
export const createTools = () => {
  const tools = [search];
  const toolNode = new ToolNode(tools);

  return toolNode;
};

/**
 *ã€€Method for creating an instance for an AI Agent using the LLM provided by Vertex AI
 */
export const createVertexAIAIAgent = (systemPrompt: string) => {
  // Instantiate VertexAI models
  const vertexAI = new VertexAI({
    project: PROJECT_ID,
    location: REGION,
  });

  // Instantiate Gemini models
  const agent = vertexAI.getGenerativeModel({
    model: "gemini-1.5-flash",
    safetySettings: [
      {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
      },
    ],
    generationConfig: {
      maxOutputTokens: 2048,
    },
    systemInstruction: {
      role: "system",
      parts: [
        {
          text: systemPrompt,
        },
      ],
    },
  });

  return agent;
};

/**
 * Methods for defining the workflow and tasks to be executed by the AI Agent
 * @parma AI Agent instance
 * @param toolNode Third-Party Tools
 */
export const createAgentTask = async (
  agent: GenerativeModel | VertexAI,
  toolNode: ToolNode
) => {
  /**
   * Define the function that determines whether to continue or not
   * @param param0
   * @returns
   */
  function shouldContinue({ messages }: typeof MessagesAnnotation.State) {
    const lastMessage = messages[messages.length - 1];

    // If the LLM makes a tool call, then we route to the "tools" node
    if (lastMessage.additional_kwargs.tool_calls) {
      return "tools";
    }
    // Otherwise, we stop (reply to the user) using the special "__end__" node
    return "__end__";
  }

  /**
   * Define the function that calls the model
   * @param state
   * @returns
   */
  async function callModel(state: typeof MessagesAnnotation.State) {
    // Let AI make inferences
    const response = await (agent as GenerativeModel).generateContent({
      contents: [
        {
          role: "model",
          parts: [
            {
              text: `${state.messages[
                state.messages.length - 1
              ].content.toString()}`,
            },
          ],
        },
      ],
    });

    // Extract the first candidate's content
    const content = response.response.candidates?.[0].content;
    // Create a HumanMessage object
    const message = new HumanMessage(content?.parts[0].text as string);
    // console.log("message:", message)
    return { messages: [message] };
  }

  // Establish a workflow.
  const workflow = new StateGraph(MessagesAnnotation)
    .addNode("agent", callModel)
    .addEdge("__start__", "agent") // __start__ is a special name for the entrypoint
    .addNode("tools", toolNode)
    .addEdge("tools", "agent")
    .addConditionalEdges("agent", shouldContinue);

  // Finally, we compile it into a LangChain Runnable.
  const app = workflow.compile();

  return app;
};
```

**LangChain** ãŒä¾¿åˆ©ã™ãã¦ãƒ¤ãƒã„ã§ã™ãƒ»ãƒ»ãƒ»ç¬‘

ãŸã ã€ç¾çŠ¶ã ã¨ **ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãŒé ‘å¼µã£ã¦å®Ÿè£…ã—ã¦ã‚ã’ãªã„ã¨ãã‚Œä»¥ä¸Šã®ã“ã¨ã¯å‡ºæ¥ãªã„** ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ã“ã®è¾ºã‚Šã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒæ•´ã£ã¦ã“ãªã„ã¨ãªã‹ãªã‹é›£ã—ãã†ã§ã™ãƒ»ãƒ»ãƒ»ã€‚

### AI Agent ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å‰²ã‚Šå½“ã¦ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ

**AI Agent** ç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–ã™ã‚‹éš›ã«ãƒ„ãƒ¼ãƒ«ä»¥å¤–ã«ã‚‚é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã¨ã—ã¦ **ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ** ãŒã‚ã‚Šã¾ã™ã€‚

AI Agent ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã•ã›ã‚‹æ™‚ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹éš›ã«ã€ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã—ã£ã‹ã‚Šè¨­å®šã•ã‚Œã¦ã„ãªã„ã¨ã†ã¾ãå‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚

ä»Šå›ã ã¨ 6 ã¤ã®å½¹å‰²ãã‚Œãã‚Œã«ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”¨æ„ã—ã¾ã—ãŸã€‚å…·ä½“çš„ã«ã¯ä»¥ä¸‹ã®æ§˜ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

```ts
/**
 * This file contains the configuration for the AI assistant.
 */

// socialTrendSpecialist system prompt
export const socialTrendSpecialistSystemPrompt = `
  You are the "Social Trend Collection Specialist" of the cryptocurrency investment team.

  [Key Tools You Use]
    Tavily API: Specialized in crawling websites for research
    Coingecko API: Retrieves trending tokens, market cap rankings, and more

  [Your Primary Responsibilities]
    Analyze mentions and sentiment on websites to quickly identify trending tokens and topics.
    Use the Coingecko API to gather lists of trending tokens and obtain the prices and market caps of major cryptocurrencies.
    Summarize this information and report it to other agents (News Specialist, Analysis Specialist, and Execution Specialist).

  [Specific Tasks]
    List tokens or hashtags with a sharp increase in mentions on websites, and provide a brief summary of the positive/negative sentiment ratios.
    Retrieve trending tokens and top-ranked coins from Coingecko, and organize data such as price changes (24h/7d) and market cap.
    Identify particularly noteworthy tokens (e.g., those with significant price surges or drops).
    Present key points in bullet points or concise report format to share the latest market sentiment with the team.

  [Output Examples]
    Always provide the output in this format:
    - Trend1: {}
    - Trend2: {}
    - Trend3: {}

  Based on these points, please create swift and accurate reports for the cryptocurrency investment team.
`;

// System prompt for the News and Fundamental Information Specialist
export const newsAndFundamentalInformationSpecialistSystemPrompt = `
  You are the "News and Fundamental Information Specialist" of the cryptocurrency investment team.

  [Key Tools You Use]
   - Vertex Agent: Capable of performing Google searches
   - Tavily API: Specialized in crawling websites for research
   - Coingecko API: Retrieves trending tokens and market cap rankings

  [Your Primary Responsibilities]
   Research the latest news and official information through Google searches about tokens highlighted by the Social Trend Specialist or those the team is currently monitoring.
   Collect and summarize information on project whitepapers, development teams, roadmaps, partnerships, and listing updates.
   Report promptly on negative news, such as hacks, misuse of funds, or regulatory risks.

  [Specific Tasks]
   Use Vertex Agent to conduct Google searches and verify information from top reliable sources, such as official websites, media reports, and GitHub repositories.
   Treat unverified information as "rumors" and clearly distinguish it from confirmed facts.
   Summarize fundamental aspects, such as long-term development plans and community engagement, in an easy-to-understand manner.

  [Output Examples]
    Always provide the output in this format:
    - News1: {}
    - News2: {}
    - News3: {}

  Organize this information clearly and create reports to assist the Analysis and Strategy Specialist in making informed decisions.
`;

// System prompt for the Risk Management Specialist
export const riskManagementSpecialistSystemPrompt = `
  You are the "Risk Management Agent" of the cryptocurrency investment team.

  [Key Tools You Use]
   - Tavily API: Specialized in crawling websites for research
   - createTokenBalanceTools: Verifies token balances and liquidity status

  [Your Primary Responsibilities]
   - Analyze potential risks such as market volatility, token liquidity, and rising gas fees.
   - Assess the risk of investment strategies and propose risk mitigation measures.
   - Review risk factors related to stop-loss levels, capital reduction strategies, and token selection.

  [Specific Tasks]
   Identify risk factors based on each token's volatility, liquidity, and past market performance.
   For strategies proposed by the Analysis and Strategy Specialist, identify the associated risks and provide mitigation measures.
   Suggest specific actions to take if gas fees rise or if market instability increases.

  [Output Examples]
    Always provide the output in this format:
    - riskFactor: {Description of the risk}
    - suggestedMitigation: {Suggested risk mitigation measures}
    - adjustment: {Proposed adjustment to the strategy}
`;

// system prompt for the Analysis and Strategy Specialist
export const performanceMonitoringSpecialistSystemPrompt = `
  You are the "Performance Monitoring Agent" of the cryptocurrency investment team.

  [Key Tools You Use]
    - Tavily API: Specialized in crawling websites for research
    - createTokenBalanceTools: Verifies token balances and liquidity status

  [Your Primary Responsibilities]
    Monitor trade results and portfolio performance in real-time.
    Analyze KPIs such as profit margins, fees, and liquidity changes, and suggest strategy improvements.
    Provide feedback to the "Analysis and Strategy Agent" as needed and prompt for a reevaluation of investment strategies.

  [Specific Tasks]
    Evaluate the success or failure of executed transactions.
    Analyze profit margins, swap fees, lending rates, etc., and propose improvements for performance.
    Identify portfolio imbalances or excessive risk and suggest corrective actions.

  [Output Examples]
    Always provide the output in this format:
    KPI: {Profit margin, fees, lending rates, etc.}
    suggestedImprovement: {Suggested improvements to the strategy}
`;

// System prompt for the Analysis and Strategy Specialist
export const analysisAndStrategySpecialistSystemPrompt = `
  You are the "Analysis and Strategy Agent" of the cryptocurrency investment team.

  [Key Tools You Use]
   - OpenAI Agent: Models like GPT-4 and GPT-4-mini with strong reasoning and language comprehension skills
   - CryptoDeFiTools: A tool for retrieving token balance information

  [Your Primary Responsibilities]
   Conduct a comprehensive analysis of the information provided by the "Social & Trend Collection Agent" and the "News & Fundamental Information Collection Agent."
   Predict short-to-medium-term price trends and assess risks, proposing investment strategies and portfolio allocations.
   Review technical indicators (such as moving averages, RSI, MACD) and risk management (such as investment ratios, stop-loss lines) for individual tokens as needed.
   Provide clear instructions to the "Execution & Operation Agent" for specific actions (swap, staking, lending).

  [Specific Tasks]
   Based on the received social sentiment, news, and fundamental information, provide buy/sell/hold recommendations.
   Evaluate whether swapping on Uniswap, staking on Lido, or lending on Aave is the most suitable strategy.
   Choose the optimal blockchain network (Sepolia, Holesky, Base Sepolia, or Arbitrum Sepolia).
   Provide specific recommendations on how much capital should be allocated, depending on the risk tolerance (e.g., allocate X% of funds to ETH staking, Y% to lending, etc.).

  [Important Notes]
    Also, always ensure that the amount for cryptocurrency operations does not exceed your available balance.

  [Output Examples]
    Always provide the output in this JSON format:
    {
      "blockchain": "{Blockchain Name}",
      "operation": "{Operation Type}",
      "tokenName": "{Token Name}",
      "amount": "{Amount}"
    }

   Present these analyses clearly and provide the Execution Agent with the necessary transaction instructions.
`;

// System prompt for the DeFi assistant(AAVE & Uniswap & Lido & CoinGecko & EidgenLayer)
export const defiAssistantSystemPrompt = `
  You are the "Execution and Operation Manager" of the cryptocurrency investment team.
  You are connected to the wallet address: 0x17d84D6F175a093dAAFF55b3aCAD26E208Ad7c29

  Based on the asset status provided as a prompt, always determine and execute the optimal DeFi protocol operations.

  [Key Tools You Use]
   1. AAVE: Lending and borrowing platform
   2. Uniswap: Decentralized exchange
   3. Lido: Staking and liquid staking platform
   4. EigenLayer: Staking and restaking platform

  [Your Primary Responsibilities]
    Execute actual transactions on the blockchain based on buy/sell and operational instructions from the Analysis and Strategy Agent.
    Verify transaction results (Tx hash, gas fees, staking reward trends, etc.) and report them to the team.
    Update and share the current status of the portfolio, including holdings, staking amounts, and lending balances.

  [Specific Tasks]
    Execute swaps as instructed, such as "Swap ETH for â—‹â—‹ tokens on Uniswap," and report the results.
    Perform operations like "Stake ETH on Lido" or "Lend assets on Aave," and monitor reward rates and risk conditions.
    In case of transaction failures or errors, retry the operation, investigate the issue, and report it to the Analysis Agent.

  [Output Examples]
    Always provide the output in this format:
    - transactionStatus: {Success/Failure}
    - transactionHash: {Transaction Hash}


  Before executing any operation, ensure the correct network (Sepolia or Holesky or Arbitrum Sepolia) is selected.
  Use only the corresponding contract addresses based on the user's selected network.

  And before executing any transaction, ensure that the selected token and the network match. If there is a mismatch, halt the operation and notify the user.

  You have access to the only following tokens and their addresses:

  **Sepolia Network**:
    - USDC (USD Coin): 0x94a9D9AC8a22534E3FaCa9F4e7F2E2cf85d5E4C8
    - DAI (Dai Stablecoin): 0xFF34B3d4Aee8ddCd6F9AFFFB6Fe49bD371b8a357
    - WBTC (Wrapped Bitcoin): 0x29f2D40B0605204364af54EC677bD022dA425d03
    - USDT (Tether USD): 0xaA8E23Fb1079EA71e0a56F48a2aA51851D8433D0
    - GHO (GHO Token): 0xc4bF5CbDaBE595361438F8c6a187bDc330539c60
    - WETH (Wrapped Ether): 0xfff9976782d46cc05630d1f6ebab18b2324d6b14

  **Arbitrum Sepolia Network**:
    - USDC (USD Coin): 0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d
    - GHO (GHO Token): 0xb13Cfa6f8B2Eed2C37fB00fF0c1A59807C585810
    - WETH (Wrapped Ether): 0x1dF462e2712496373A347f8ad10802a5E95f053D

  **Holesky Network**:
    - stETH (Staking ETH): 0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034

  You can help users:
    1. Check their token balances of ONLY the above contracts. Let the user know what tokens are available.
    2. Lend their tokens to earn interest
    3. Borrow tokens against their collateral
    4. Swap tokens using Uniswap protocol
    5. Search for trending tokens on CoinGecko
    6. Staking ETH using Lido contract (Holesky)
    7. ReStaking stETH using EigenLayer contract (Holesky)

  In case of transaction failures, retry up to 3 times.
  If the issue persists, provide a detailed error report including the probable cause and suggested resolution.
`;
```

ç‰¹ã« DeFi ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™ AI Agent ã«å‰²ã‚Šå½“ã¦ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¯ã«ä½¿ãˆã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å®šç¾©ã—ãŸã‚Šã€å®Ÿè¡Œã§ãã‚‹å‡¦ç†å†…å®¹ã‚’ãã£ã¡ã‚Šæ›¸ã„ã¦ã‚ã’ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

### ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒã‚§ã‚¤ãƒ‹ãƒ³ã‚°ã®å®Ÿè£…å†…å®¹

æœ€å¾Œã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒã‚§ã‚¤ãƒ‹ãƒ³ã‚°ã®å®Ÿè£…ã«ã¤ã„ã¦å…±æœ‰ã—ã¾ã™ã€‚

ã“ã“ã¾ã§å…±æœ‰ã—ã¦ããŸ ãƒ„ãƒ¼ãƒ«ã€AI Agent ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åˆæœŸåŒ–ãƒ¡ã‚½ãƒƒãƒ‰ã€ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’çµ„ã¿åˆã‚ã›ã¦ 6 ã¤ã® AI Agent ã‚’é †ç•ªã«å®Ÿè¡Œã•ã›ã¦ã„ã¾ã™ã€‚

**CloudRun** ã¨ **Autonome** ã«ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã—ãŸ API ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

```ts
e.preventDefault();
if (!input.trim()) return;
setIsGenerating(true);

// â‘  Add the user's message to the conversation.
const userMessage = { role: "user", content: input };
setMessages((prev) => [...prev, userMessage]);
setInput("");

try {
  console.log("userMessage", userMessage.content);

  // â‘  Call Vertex AI Agent endpoints in sequence to social trend analysis.
  const responseA = await fetch(`${CLOUDRUN_API_ENDPOINT}/agentVertexAI`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      prompt: `
            The following content is input from the user.
            Based on this input, research the latest trends related to Web3, blockchain, and cryptocurrencies, and provide the results.

            #User Input:
              ${userMessage.content}

            Additionally, ensure the output is concise and formatted as shown below to be passed as input to the News and Fundamental Information Specialist AI Agent.

            #Output:
              Trend1: {}
              Trend2: {}
              Trend3: {}
          `,
      operation: "SocialTrend",
    }),
  });
  const textA = await responseA.json();
  console.log("textA", textA);
  const aiAMessage = { role: "assistant", content: textA.result };
  setMessages((prev) => [...prev, aiAMessage]);

  // â‘¡ Call Vertex AI Agent endpoint to NewsAndFundamentals analysis.
  const responseB = await fetch(
    `${CLOUDRUN_API_ENDPOINT}/runAnthropicAIAgent`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt: `
            The following content is output from the Social Trend Collection Specialist Agent.
            Based on this input, research the latest news related to Web3, blockchain, and cryptocurrencies, summarize it concisely, and present only the key points.

            #Input from the Social Trend Collection Specialist Agent:
              ${textA.result}

            Additionally, ensure the output is concise and formatted as shown below to be passed as input to the Risk Management AI Agent.

            #Output:
              News1: {}
              News2: {}
              News3: {}
          `,
        operation: "NewsAndFundamentals",
      }),
    }
  );
  const textB = await responseB.json();
  console.log("textB", textB);
  const aiBMessage = { role: "assistant", content: textB.result };
  setMessages((prev) => [...prev, aiBMessage]);

  // â‘¢ Call Vertex AI Agent endpoint to NewsAndFundamentals analysis.
  const responseC = await fetch(
    `${CLOUDRUN_API_ENDPOINT}/runCryptOpenAIAgent`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt: `
            The following content is input from the News and Fundamentals Agent.
            Based on this input and the balance status of your wallet, summarize the potential risks concisely.

            #Input from the News And Fundamentals Agent:
            ${textB.result}

            Additionally, ensure the output is concise and formatted as shown below to be passed as input to the Performance Monitoring AI Agent.

            #Output:
             riskFactor: {Description of the risk}
             suggestedMitigation: {Suggested risk mitigation measures}
             adjustment: {Proposed adjustment to the strategy}
          `,
        operation: "RiskManagement",
      }),
    }
  );
  const textC = await responseC.json();
  console.log("textC", textC);
  const aiCMessage = { role: "assistant", content: textC.result };
  setMessages((prev) => [...prev, aiCMessage]);

  // â‘£ Call Autonome CoinBase AI Agent endpoint to get token balance info
  const responseD = await fetch(`${AUTONOME_CDP_API_ENDPOINT}/runCdpChatMode`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Basic Y2RwYWdlbnQ6elhyZVVoV2xxUw==",
    },
    body: JSON.stringify({
      prompt: "What is my wallet's balance (ETH, EURC, USDC) now?",
    }),
  });

  console.log("responseD", responseD);

  const textD = await responseD.json();
  console.log("textD", textD);
  // const aiDMessage = { role: "assistant", content: textD.result[1] };
  // setMessages((prev) => [...prev, aiDMessage]);

  // concat the messages
  const newMessage = textC.result.concat(textD.result[1]);
  console.log("newMessage", newMessage);

  // â‘¤ call Anthropic Agent endpoint to AnalysisAndReasoning
  const responseF = await fetch(
    `${CLOUDRUN_API_ENDPOINT}/runAnthropicAIAgent`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt: `
              The following content is the analysis results from the News and Fundamentals Agent and the Risk Management Agent.
              Based on this information, decide on only one optimal DeFi operation.

              Input from News and Fundamentals Agent
              ${textB.result}

              Input from Risk Management Agent
              ${newMessage}

              Additionally, present the output in the following concise format:

              The blockchain name must be specified from one of the following: sepolia or arbitrum sepolia or base sepolia or holesky.

              Only one operation should be specified.

              â€»Importantâ€»
              Also, always ensure that the amount for cryptocurrency operations does not exceed your available balance.

              Output:
              blockchain: {blockchain Name}
              operation: {Operation Name}
              tokenName: {Token Name}
              amount: 0.1
            `,
        operation: "AnalysisAndReasoning",
      }),
    }
  );
  const textF = await responseF.json();
  console.log("textF", textF);
  const aiFMessage = { role: "assistant", content: textF.result };
  setMessages((prev) => [...prev, aiFMessage]);

  // check contain in the response "base sepolia"
  const containsKeywordFlg = textF.result
    .toLowerCase()
    .includes("base sepolia".toLowerCase());

  // â‘¥ call OpenAI Agent or Autonome endpoint to execute defi transaction
  if (containsKeywordFlg) {
    // Call Autonome CoinBase AI Agent endpoint to execute defi transaction
    const responseG = await fetch(
      `${AUTONOME_CDP_API_ENDPOINT}/runCdpChatMode`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Basic Y2RwYWdlbnQ6elhyZVVoV2xxUw==",
        },
        body: JSON.stringify({
          prompt: `
                The following content is the analysis result from the Analysis and Reasoning Agent.
                Based on this information, accurately execute the optimal DeFi operation.

                #Input from Analysis and Reasoning Agent
                  ${textF.result}

                Additionally, present the output in the following concise format:

                #Output:
                  Blockchain: {Blockchain Name}
                  Transaction Result: {Execution Result}
                  Transaction Hash: {Transaction Hash}
              `,
        }),
      }
    );

    console.log("responseG", responseG);

    const textG = await responseG.json();
    console.log("textG", textG);
    const aiGMessage = { role: "assistant", content: textG.result[1] };
    setMessages((prev) => [...prev, aiGMessage]);

    // â‘¤ call Groq Agent endpoint to PerformanceMonitoring
    const responseE = await fetch(
      `${CLOUDRUN_API_ENDPOINT}/runCryptOpenAIAgent`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: `
                The following content is input from the Execution and Operation Agent.
                Please provide a concise analysis based on the transaction results.

                #Input from the Execution and Operation Agent
                 ${newMessage}

                Additionally, please present the output in the following concise format:

                #Output:
                 KPI: {Profit margin, fees, lending rates, etc.}
                 suggestedImprovement: {Suggested improvements to the strategy}
              `,
          operation: "PerformanceMonitoring",
        }),
      }
    );
    const textE = await responseE.json();
    console.log("textE", textE);
    const aiEMessage = { role: "assistant", content: textE.result };
    setMessages((prev) => [...prev, aiEMessage]);
  } else {
    // Call ChatGPT AI Agent endpoint to execute defi transaction
    const responseH = await fetch(
      `${CLOUDRUN_API_ENDPOINT}/runCryptOpenAIAgent`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: `
                The following content is the analysis result from the Analysis and Reasoning Agent.
                Based on this information, accurately execute the optimal DeFi operation.

                #Input from Analysis and Reasoning Agent
                  ${textF.result}

                Additionally, present the output in the following concise format:

                #Output:
                  Blockchain: {Blockchain Name}
                  Transaction Result: {Execution Result}
                  Transaction Hash: {Transaction Hash}
              `,
        }),
      }
    );
    const textH = await responseH.json();
    console.log("textH", textH);
    const aiHMessage = { role: "assistant", content: textH.result };
    setMessages((prev) => [...prev, aiHMessage]);

    // â‘¤ call Groq Agent endpoint to PerformanceMonitoring
    const responseE = await fetch(
      `${CLOUDRUN_API_ENDPOINT}/runCryptOpenAIAgent`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: `
                The following content is input from the Execution and Operation Agent.
                Please provide a concise analysis based on the transaction results.

                #Input from the Execution and Operation Agent
                 ${newMessage}

                Additionally, please present the output in the following concise format:

                #Output:
                 KPI: {Profit margin, fees, lending rates, etc.}
                 suggestedImprovement: {Suggested improvements to the strategy}
              `,
          operation: "PerformanceMonitoring",
        }),
      }
    );
    const textE = await responseE.json();
    console.log("textE", textE);
    const aiEMessage = { role: "assistant", content: textE.result };
    setMessages((prev) => [...prev, aiEMessage]);
  }
} catch (error) {
  console.error("Error during conversation chain:", error);
} finally {
  setIsGenerating(false);
}
```

ã‹ãªã‚Šé•·ã„å®Ÿè£…å†…å®¹ã§ã™ãŒã€ã“ã‚Œã§ AI Agent åŒå£«ã«ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«è­°è«–ã•ã›ã¦ã„ã‚‹ã‚ˆã†ã«è¡¨ç¤ºã•ã›ã¦ã„ã¾ã™ã€‚

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«åŠ›ã«å…¥ã‚Œã™ãã¦ãƒ•ãƒ­ãƒ³ãƒˆã®å®Ÿè£…ãŒé©å½“ã«ãªã£ã¦ã—ã¾ã£ãŸã®ã¯åçœç‚¹ã§ã™ã€‚

æ™‚é–“ãŒç„¡ã‹ã£ãŸã¨ã¯ã„ãˆã€ã‹ãªã‚Šå¼·å¼•ã«å®Ÿè£…ã—ã¦ã—ã¾ã£ãŸãªããƒ»ãƒ»ã¨æ€ã£ã¦ã„ã¾ã™ã€‚

## Web3 âœ–ï¸ AI Agent ã¯ã©ã†ãªã£ã¦ã„ãï¼Ÿï¼Ÿ

æœ€çµ‚çš„ã« **Web3 âœ–ï¸ AI Agent** ã¯ **Intent(ã‚¤ãƒ³ãƒ†ãƒ³ãƒˆ)** ã«é›†ç´„ã•ã‚Œã¦ã„ãã®ã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

AI Agent ç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ç´°ã‹ã„å®Ÿè£…ãªã©ã¯ã€OSS ã‚„ä¸€éƒ¨ã®å¼·åŠ›ãªãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãŒå®Ÿè£…ã—ã¦ã„ãã“ã¨ã«ãªã‚‹ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ

å…ˆæ—¥ã€ **Ethereum Foundation** ã‹ã‚‰ã‚‚ Intent ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒç™ºè¡¨ã•ã‚Œå¤§ããªè©±é¡Œã‚’ç”Ÿã¿ã¾ã—ãŸã€‚  
ã“ã“ã‹ã‚‰ AI Agent ã®åŠ›ã‚’å€Ÿã‚Šã¦ã•ã‚‰ã«æ´—ç·´ã•ã‚Œã¦ã„ãã®ã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

https://github.com/BootNodeDev/intents-framework/tree/main

è‡ªç„¶è¨€èªã§ DeFi ã‚„ Web3 ã®å…¨ã¦ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒè¡Œãˆã‚‹ã‚ˆã†ã«ãªã£ãŸã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã¯çˆ†ç™ºçš„ã«è‰¯ããªã‚Šã¾ã™ã—ã€ãã‚Œã“ããŒ **Intent** ãŒç›®æŒ‡ã—ã¦ã„ã‚‹ä¸–ç•Œã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

ãã‚Œã‚‰ã® SDK ã‚„ã‚¤ãƒ³ãƒ•ãƒ©ãŒæ•´ã„ã€ã‚¢ãƒ—ãƒªé–‹ç™ºã®ãŸã‚ã®æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã¨ã—ã¦å½“ãŸã‚Šå‰ã«å–ã‚Šå…¥ã‚Œã‚‰ã‚Œå§‹ã‚ãŸæ™‚ã«å¤§ããªæ³¨ç›®ã‚’é›†ã‚ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

çµ¶å¯¾ã«ã“ã®æŠ€è¡“ã¯å¤–ã›ãªã„ã‚‚ã®ã«ãªã£ã¦ã„ãã¯ãšã§ã™ã€‚

## Web3 âœ–ï¸ AI Agent ã¯é¢ç™½ã„ï¼

ã“ã“ã¾ã§è‰²ã€…æ›¸ã„ã¦ãã¾ã—ãŸãŒã€æœ€å¾Œã«çš†ã•ã‚“ã«å…±æœ‰ã—ãŸã„ã®ã¯ã€ **Web3 âœ–ï¸ AI Agent** ã¯ã‚ã¡ã‚ƒãã¡ã‚ƒé¢ç™½ã„é ˜åŸŸã ã¨ã„ã†ã“ã¨ã§ã™ï¼ï¼

æŠ€è¡“çš„ã«ã‚‚ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦–ç‚¹ã§ã‚‚æœ€çµ‚çš„ã«ã©ã®ã‚ˆã†ãªçµæœãŒå©ãå‡ºã•ã‚Œã‚‹ã®ã‹ã‚ã‹ã‚‰ãªã„ã¨ã„ã†ãƒ¯ã‚¯ãƒ¯ã‚¯æ„ŸãŒå‡„ã¾ã˜ã„ã§ã™ã€‚

ãã—ã¦ã¾ã ç™ºå±•é€”ä¸Šãªæ®µéšã§ã‚ã‚‹ãŸã‚ã€ã•ã‚‰ãªã‚‹é€²åŒ–ãŒæƒ³å®šã•ã‚Œã¾ã™ã€‚

**Web3 âœ–ï¸ AI Agent** ãŒåŠå¹´å¾Œã€1 å¹´å¾Œã«ã©ã®ã‚ˆã†ãªå½¢ã«ãªã£ã¦ã„ã‚‹ã®ã‹éå¸¸ã«æ¥½ã—ã¿ã§ã™ï¼

## å‚è€ƒæ–‡çŒ®

ä»Šå›ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚’é–‹ç™ºã™ã‚‹ã«ã‚ãŸã‚Šã€å‚è€ƒã«ã—ãŸæ–‡çŒ®ã§ã™ã€‚

https://github.com/mashharuki/CryptoAIAgentRepo

https://github.com/mashharuki/GoogleCloud-Sample

https://codelabs.developers.google.com/codelabs/how-to-deploy-gemini-powered-chat-app-cloud-run?hl=ja#0

https://github.com/mashharuki/GoogleCloud-Sample/tree/main/cloudrun/hono-sample

https://zenn.dev/nft/scraps/849d9121e8a001

https://t.co/hmqPQnnsgv

https://zenn.dev/pharmax/articles/8796b892eed183

https://www.encode.club/mammothon

https://www.brianknows.org/

https://paragraph.xyz/@zkether.eth/aiagentcrypto

https://www.anthropic.com/research/building-effective-agents

https://zenn.dev/umi_mori/books/prompt-engineer/viewer/langchain_agents

https://e2b.dev/ai-agents

https://blog.futuresmart.ai/multi-agent-system-with-langgraph

https://www.youtube.com/watch?v=CzBBhytDzM4

https://github.com/openai/openai-realtime-agents

https://github.com/fa0311/twitter-openapi-typescript

https://zenn.dev/ttks/articles/75c2102fe4657e

https://github.com/collabland/AI-Agent-Starter-Kit

https://github.com/Layr-Labs/hello-world-avs

https://www.notion.so/13-Use-Cases-for-the-Zero-Employee-Enterprise-ZEE-18481e29202580bea9fdc99ab5c1da6e?pvs=21

https://ai16z.github.io/eliza/

https://github.com/ai16z/eliza/tree/main

https://zenn.dev/komlock_lab/articles/e6ec0e6f3e0699

https://note.com/skyland_aikawa/n/n7aa4e5da6717?magazine_key=mef9e84c7c078

https://ai16z.github.io/eliza/docs/quickstart/

https://x.com/luna_virtuals

https://www.youtube.com/watch?v=C-vky-tXpqw

https://github.com/ytakahashi2020/Eliza/tree/main/01_createAgentWithTwitter

https://zenn.dev/ttks/articles/75c2102fe4657e

https://prompt-engineering-toolkit-rho.vercel.app/

https://docs.altlayer.io/altlayer-documentation

https://apps.autono.meme/login

https://apps.autono.meme/autonome

https://www.gaianet.ai/

https://www.gaianet.ai/docs

https://docs.gaianet.ai/category/user-guide

https://github.com/GaiaNet-AI/workshops

https://github.com/GaiaNet-AI

https://github.com/coinbase/cdp-agentkit/tree/master

https://docs.gaianet.ai/tutorial/eliza

https://privy-io.notion.site/ethglobalserverwalletquickstart

https://wardenprotocol.org/

https://docs.wardenprotocol.org/

https://www.youtube.com/c/NodesGuru

https://github.com/nodesguru

https://testnet.warden.explorers.guru/

https://docs.wardenprotocol.org/build-an-app/introduction

https://docs.wardenprotocol.org/build-a-keychain/introduction

https://faucet.chiado.wardenprotocol.org/

https://spaceward.chiado.wardenprotocol.org/

https://github.com/warden-protocol/wardenprotocol/tree/main

https://docs.wardenprotocol.org/build-an-app/examples-of-oapps

https://www.npmjs.com/package/@wardenprotocol/wardenjs

https://docs.wardenprotocol.org/build-an-app/deploy-smart-contracts-on-warden/deploy-an-evm-contract
