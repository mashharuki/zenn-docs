---
title: "Amazon Bedrock AgentCoreã¨CDKã¨Mastraã¨x402ã§æ§‹ç¯‰ã™ã‚‹é‡‘èAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼"
emoji: "ğŸ¤–"
type: "tech" 
topics: ["Mastra", "TypeScript", "AWS", "ç”ŸæˆAI", "Web3"]
published: false
---

![](/images/x402_agentcore-1/0.jpeg)

# ã¯ã˜ã‚ã«

ã¿ãªã•ã‚“ã€ã“ã‚“ã«ã¡ã¯ï¼

ä»Šå›ç´¹ä»‹ã™ã‚‹AI Agentã¯å…ˆæ—¥é–‹å‚¬ã•ã‚ŒãŸ **AI Builders Day ãƒ—ãƒ¬ã‚¤ãƒ™ãƒ³ãƒˆ**ã§ãŠè©±ã—ã•ã›ã¦ã„ãŸã ã„ãŸAI Agentã‚’æ·±ãæ˜ã‚Šä¸‹ã’ã¦ã¿ãŸè¨˜äº‹ã«ãªã‚Šã¾ã™ï¼ï¼

> **ã‚¤ãƒ™ãƒ³ãƒˆãƒšãƒ¼ã‚¸**

https://jawsug.connpass.com/event/375739/

ãã“ã§ã¯è©±ã—ãã‚Œãªã‹ã£ãŸç´°ã‹ã„æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã®èª¬æ˜ã‚’è§£èª¬ã—ã¦ã„ãã¾ã™ã®ã§ãœã²æœ€å¾Œã¾ã§èª­ã‚“ã§ã„ã£ã¦ãã ã•ã„ï¼ï¼

> **ã‚¹ãƒ©ã‚¤ãƒ‰**

https://speakerdeck.com/mashharuki/amazon-bedrock-agentcore-x-aws-cdk-x-mastra-x-x402-deci-shi-dai-jin-rong-ai-agentwozuo-rou

> **ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‹•ç”»**

https://www.youtube.com/watch?v=ZkcUtJVnwKI&themeRefresh=1

# ã“ã®è¨˜äº‹ã®å¯¾è±¡èª­æ›¸

- x402ã«ã¤ã„ã¦çŸ¥ã‚ŠãŸã„äºº
- x402 MCPã‚µãƒ¼ãƒãƒ¼ã®å®Ÿè£…æ–¹æ³•ãŒçŸ¥ã‚ŠãŸã„äºº
- Mastraã‚’AgentCoreä¸Šã§å‹•ã‹ã™æ–¹æ³•ã‚’çŸ¥ã‚ŠãŸã„äºº
- CDKã§AgentCoreã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã¿ãŸã„äºº
- AgentCoreä¸Šã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸAI Agentã‚’ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰å‘¼ã³å‡ºã™æ–¹æ³•ã‚’çŸ¥ã‚ŠãŸã„äºº

# ä»Šå›ä½œã£ãŸã‚‚ã®

> **GitHub**

https://github.com/mashharuki/AgentCore-Mastra-x402

> **ã‚¤ãƒ¡ãƒ¼ã‚¸**

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã§ã™ï¼

![](/images/x402_agentcore-1/2.png)

å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã«å ´æ‰€ã‚’å…¥åŠ›ã™ã‚‹ã¨å¤©æ°—æƒ…å ±ãŒå–å¾—ã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼
â€» (ä»Šå›ã¯ãƒ€ãƒŸãƒ¼å€¤ã§å›ºå®š)

**Amazon Bedrock AgentCore Runtime**ä¸Šã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã¨å‹•ä½œç¢ºèªã®ãŸã‚ã«Sandboxç’°å¢ƒã§ã‚‚å‹•ã‹ã™ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ãŒã€ãã®å®Ÿè¡Œç”»é¢ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

![](/images/x402_agentcore-1/3.png)

æœ€çµ‚çš„ã«AI Agentã‹ã‚‰MCPãŒå‘¼ã³å‡ºã•ã‚Œã¦ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚³ã‚¤ãƒ³ã«ã‚ˆã‚‹æ±ºæ¸ˆãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™(ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã§ã‚ã‚‹**Base Sepolia**ã§è©¦ã—ã¦ã„ã¾ã™)ï¼

![](/images/x402_agentcore-1/4.png)

## ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆå›³

ä»Šå›ã®AI Agentã®ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆã¯ã“ã‚“ãªæ„Ÿã˜ã§ã™ï¼

![](/images/x402_agentcore-1/1.png)

å…¨ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’**CDK**ã§ãƒ‡ãƒ—ãƒ­ã‚¤ã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼ï¼

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

ä»Šå›æ¡ç”¨ã—ãŸæŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ä¸€è¦§ã§ã™ï¼ï¼

- **AWS**
  - CDK
    - AWSãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã¨ã—ã¦
  - Amazon Bedrock AgentCore
    - Runtime
      - AI Agentã®å®Ÿè¡Œç’°å¢ƒã¨ã—ã¦
  - ECR
    - ã‚³ãƒ³ãƒ†ãƒŠãƒªãƒã‚¸ãƒˆãƒªã¨ã—ã¦
  - ECS
    - Fargate
      - ã‚³ãƒ³ãƒ†ãƒŠã®å®Ÿè¡Œç’°å¢ƒã¨ã—ã¦
  - Lambda
    - MCPã‚µãƒ¼ãƒãƒ¼ã®å®Ÿè¡Œç’°å¢ƒã¨ã—ã¦
  - ALB
    - ECSãŒå¤–éƒ¨ã¨é€šä¿¡ã§ãã‚‹ã‚ˆã†ã«è¨­ç½®
- **Web3**
  - x402
    - ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚³ã‚¤ãƒ³
    - ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆ
      - Solidity
      - ERC20
      - Openzeppelin
      - USDC
      - Base Sepolia
- **AI Agent**
  - mastra
    - Next.js ã®ã‚µãƒ¼ãƒãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®éƒ¨åˆ†ã®ã¿ã‚’åˆ©ç”¨(Honoã¨ã‹ã®æ–¹ãŒã„ã„ã‹ã‚‚...)
  - MCP
    - AI Agentã¨å¤–éƒ¨ãƒ„ãƒ¼ãƒ«ã¨ã®æ¥ç¶šç”¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**
  - Next.js
    - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

# å®Ÿè£…ã§ãƒã‚¤ãƒ³ãƒˆã¨ãªã£ãŸç®‡æ‰€

ã“ã“ã‹ã‚‰ã¯é‡è¦ãªå®Ÿè£…ãƒã‚¤ãƒ³ãƒˆã‚’è§£èª¬ã—ã¦ã„ãã¾ã™ï¼

## AgentCoreä¸Šã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹AI Agentã®Dockerfile

ã¾ãšã¯AgentCore Runtimeã§å®Ÿè¡Œã™ã‚‹AI Agentç”¨ã®**Dockerfile**ã®è§£èª¬ã‹ã‚‰ï¼

::::details Dockerfileã®è§£èª¬

ä»Šå›ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªDockerfileã‚’ç”¨æ„ã—ã¾ã—ãŸï¼

**Next.js**ã‚¢ãƒ—ãƒªç”¨ã®Dockerfileã‚’ä½œã‚‹æ„Ÿã˜ã§è‰¯ã„ã®ã§ã™ãŒã€1ç‚¹ã ã‘æ³¨æ„ã™ã¹ãç‚¹ãŒã‚ã‚Šã¾ã™ï¼

ãã‚Œã¯ã€**Arm64**ã«å¯¾å¿œã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼

:::message
ãƒ“ãƒ«ãƒ‰æ™‚ã«ã¯`--platform linux/arm64`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ï¼

```bash
docker build --platform linux/arm64 -t mastra-agent:latest .
```
:::

**Amazon Bedrock AgentCore Runtime**ã®åˆ¶ç´„ã§Dockerã‚³ãƒ³ãƒ†ãƒŠãŒ**Arm64**ã«å¯¾å¿œã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ã“ã‚Œã‚’å¿˜ã‚Œã‚‹ã¨Dockerã‚³ãƒ³ãƒ†ãƒŠã®ãƒ“ãƒ«ãƒ‰ãŒæˆåŠŸã™ã‚‹ã«ãªãœã‹ã†ã¾ãå‹•ä½œã—ãªã„ã¨ã„ã†äº‹è±¡ãŒç™ºç”Ÿã—ã¾ã™ã€‚


```yaml
# ==============================================================================
# Multi-stage Dockerfile for Mastra AI Agent
# Optimized for Amazon Bedrock AgentCore Runtime (ARM64, Port 8080)
# ==============================================================================

# ------------------------------------------------------------------------------
# Stage 1: Dependencies
# ------------------------------------------------------------------------------
FROM --platform=linux/arm64 node:22-alpine AS deps

# Install pnpm
RUN corepack enable && corepack prepare pnpm@10.7.0 --activate

WORKDIR /app

# Copy package files
COPY package.json ./

# Install dependencies (without lockfile for monorepo compatibility)
# Use --shamefully-hoist to reduce duplication
RUN pnpm install --no-lockfile --shamefully-hoist

# ------------------------------------------------------------------------------
# Stage 2: Builder
# ------------------------------------------------------------------------------
FROM --platform=linux/arm64 node:22-alpine AS builder

# Install pnpm
RUN corepack enable && corepack prepare pnpm@10.7.0 --activate

WORKDIR /app

# Copy dependencies
COPY --from=deps /app/node_modules ./node_modules

# Copy source code
COPY . .

# Build TypeScript
ENV NODE_ENV=production
RUN pnpm build

# ------------------------------------------------------------------------------
# Stage 3: Runner - Production runtime
# ------------------------------------------------------------------------------
FROM --platform=linux/arm64 node:22-alpine AS runner

# Install dumb-init for proper signal handling (SIGTERM/SIGKILL)
RUN apk add --no-cache dumb-init

WORKDIR /app

# Set production environment
ENV NODE_ENV=production

# Create non-root user for security
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 agentuser

# Copy package.json and install ONLY production dependencies
COPY --from=builder /app/package.json ./package.json

# Install pnpm for production install
RUN corepack enable && corepack prepare pnpm@10.7.0 --activate

# Install only production dependencies
RUN pnpm install --prod --no-lockfile --shamefully-hoist && \
    pnpm store prune

# Copy built application
COPY --from=builder /app/dist ./dist

# Set proper ownership
RUN chown -R agentuser:nodejs /app

# Switch to non-root user
USER agentuser

# Expose port 8080 as required by AgentCore Runtime
EXPOSE 8080

# Set AgentCore Runtime required environment variables
ENV PORT=8080
ENV HOST=0.0.0.0
ENV NODE_ENV=production
# Use Bedrock models in production
ENV USE_GEMINI=true
# Default AWS region (can be overridden at runtime)
ENV AWS_REGION=ap-northeast-1
# MCP_SERVER_URL will be set at runtime through container environment variables
# or injected through a configuration mechanism

# Health check for /ping endpoint
HEALTHCHECK --interval=30s --timeout=5s --start-period=30s --retries=3 \
  CMD node -e "require('http').get('http://localhost:8080/ping', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

# Use dumb-init to handle signals properly
ENTRYPOINT ["dumb-init", "--"]

# Start the agent server
CMD ["node", "dist/server.js"]
```
::::

## Mastraã®å®Ÿè£…

æ¬¡ã«**Mastra**ã®å®Ÿè£…ã®è§£èª¬ã«ãªã‚Šã¾ã™ï¼

::::details Mastraã®å®Ÿè£…ã®è§£èª¬

ã¾ãšã¯**x402 MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ**ã®è¨­å®šéƒ¨åˆ†ã‹ã‚‰ã¿ã¦ã„ãã¾ã—ã‚‡ã†ï¼

```ts
import { ConsoleLogger } from "@mastra/core/logger";
import { MCPClient } from "@mastra/mcp";

/**
 * Create MCP Client for x402 MCP Server
 * @returns MCPClient instance
 */
export const createx402MCPClient = () => {
  // create MCPClient instance
  // this mcp has 3 tools
  const mcpClient = new MCPClient({
    id: "x402-tools",
    servers: {
      // ãƒªãƒ¢ãƒ¼ãƒˆã®å ´åˆ
      x402: {
        // sse: true,
        url: new URL(`${process.env.MCP_SERVER_URL}mcp`),
        // @ts-expect-error server is not a function
        log: new ConsoleLogger(),
      },
      // ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç”¨ã®å ´åˆã¯ä»¥ä¸‹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚¢ã‚¦ãƒˆã‚’å¤–ã™
      // "x402-mcp-server": {
      //   command: "node",
      //   args: [`${process.cwd()}/../mcp/dist/index.js`],
      //   env: {
      //     PRIVATE_KEY: process.env.PRIVATE_KEY as string,
      //     RESOURCE_SERVER_URL: process.env.RESOURCE_SERVER_URL as string,
      //     ENDPOINT_PATH: process.env.ENDPOINT_PATH as string,
      //   },
      //   timeout: 60000, // Timeout: 60 seconds,
      // },
    },
  });

  return mcpClient;
};

/**
 * Method to get only tools
 */
export const getx402MCPCTools = async () => {
  const x402MCPClient = createx402MCPClient();
  return await x402MCPClient.getTools();
};

/**
 * MCPæ¥ç¶šã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
 */
export const testMCPConnection = async () => {
  try {
    console.log("Testing MCP connection...");
    // MCPã‚µãƒ¼ãƒãƒ¼ã¯CDKã‚¹ã‚¿ãƒƒã‚¯ã§ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸæ™‚ã®Lambdaé–¢æ•°URLã®å€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‹
    console.log("MCP_SERVER_URL:", process.env.MCP_SERVER_URL);

    const x402MCPClient = createx402MCPClient();
    const tools = await x402MCPClient.getTools();

    console.log("MCP connection successful!");
    console.log("Available tools:", Object.keys(tools));

    return {
      success: true,
      tools: Object.keys(tools),
      serverUrl: process.env.MCP_SERVER_URL,
    };
  } catch (error) {
    console.error("MCP connection failed:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
      serverUrl: process.env.MCP_SERVER_URL,
    };
  }
};
```

ã‚ã¨ã¯ã“ã‚Œã‚’AgentåˆæœŸåŒ–ã®éš›ã«ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦è¨­å®šã™ã‚Œã°OKã§ã™ï¼

```ts
import { Agent } from "@mastra/core/agent";
import { bedrockModel, gemini } from "../models";
import { createx402MCPClient, testMCPConnection } from "../tools/x402";

/**
 * x402 Agent ã‚’ä½œæˆã™ã‚‹é–¢æ•°
 * @param useGemini - trueã®å ´åˆã¯Geminiãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: falseï¼‰
 */
export const createx402Agent = async (useGemini: boolean) => {
  try {
    console.log("Testing MCP connection...");
    const connectionTest = await testMCPConnection();

    if (!connectionTest.success) {
      throw new Error(`MCP connection failed: ${connectionTest.error}`);
    }

    console.log("Creating x402 MCP client...");
    // MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ã‚¦ãƒ³ã‚¹ã‚’åˆæœŸåŒ–
    const x402MCPClient = createx402MCPClient();

    console.log("Getting tools from MCP client...");
    // ãƒ„ãƒ¼ãƒ«ã‚’å–å¾—
    const tools = await x402MCPClient.getTools();
    console.log("Available tools:", tools);

    console.log("Creating x402 Agent with tools...");
    // ãƒ¢ãƒ‡ãƒ«ã‚’ç”¨æ„
    const selectedModel = useGemini ? gemini : bedrockModel;
    console.log(`Using model: ${useGemini ? "Gemini" : "Amazon Nova Lite"}`);

    return new Agent({
      name: "x402 Agent",
      instructions: `
        You are a helpful assistant that retrieves information from a resource server using available tools.

        IMPORTANT INSTRUCTIONS:
        1. When a user asks for weather information or any data from the resource server, you MUST use the "get-data-from-resource-server" tool.
        2. Always call the tool first before providing any response.
        3. After receiving the tool's response, format it in a user-friendly way in Japanese.
        4. The tool returns data in JSON format with properties like "weather" and "temperature".
        5. Convert temperature from Fahrenheit to Celsius if needed (Â°C = (Â°F - 32) Ã— 5/9).

        Example flow:
        User: "å¤©æ°—ã‚’æ•™ãˆã¦"
        You: [Call get-data-from-resource-server tool]
        Tool returns: {"weather": "sunny", "temperature": 70}
        You respond: "ç¾åœ¨ã®å¤©æ°—æƒ…å ±ã‚’ãŠçŸ¥ã‚‰ã›ã—ã¾ã™:\n\n- å¤©æ°—: æ™´ã‚Œ â˜€ï¸\n- æ°—æ¸©: 70Â°F (ç´„21Â°C)\n\nè‰¯ã„å¤©æ°—ã§ã™ã­ï¼"

        Never provide made-up information. Always use the tool to get real data.
      `,
      model: selectedModel, //ãƒ¢ãƒ‡ãƒ«ã®å‰²ã‚Šå½“ã¦
      tools: tools, // ãƒ„ãƒ¼ãƒ«ã®å‰²ã‚Šå½“ã¦
    });
  } catch (error) {
    console.error("Failed to create x402 Agent:", error);
    // Fallback: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ãƒ„ãƒ¼ãƒ«ãªã—ã§ä½œæˆ
    const fallbackModel = useGemini ? gemini : bedrockModel;
    console.log(
      `Fallback mode - using model: ${useGemini ? "Gemini" : "Amazon Nova Lite"}`,
    );
    return new Agent({
      name: "x402 Agent (fallback)",
      instructions: `
        You are a helpful x402 assistant. 
        However, there was an issue connecting to the MCP tools.
        Please inform the user that the weather service is currently unavailable.
      `,
      model: fallbackModel,
      tools: {},
    });
  }
};

/**
 * x402 Agent (å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚)
 * @deprecated Use createx402Agent() instead
 */
export let x402Agent: Agent;
```

**Mastra**ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åˆæœŸåŒ–ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```ts
import type { Agent } from "@mastra/core/agent";
import { createLogger } from "@mastra/core/logger";
import { Mastra } from "@mastra/core/mastra";
import "dotenv/config";

import { createx402Agent } from "./agents";

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªMastraã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
let _mastra: Mastra | null = null;
let _x402Agent: Agent | null = null;
let _currentModelType: "bedrock" | "gemini" = "bedrock";

/**
 * Mastraç”¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ï¼ˆé…å»¶åˆæœŸåŒ–ï¼‰
 * @param useGemini - trueã®å ´åˆã¯Geminiãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
 */
export const getMastra = async (useGemini: boolean): Promise<Mastra> => {
  const requestedModelType = useGemini ? "gemini" : "bedrock";

  // ãƒ¢ãƒ‡ãƒ«ãŒå¤‰ã‚ã‚‹å ´åˆã¯å†åˆæœŸåŒ–
  if (_mastra && requestedModelType !== _currentModelType) {
    console.log("Model preference changed, reinitializing Mastra...");
    _mastra = null;
    _x402Agent = null;
  }

  if (_mastra) {
    return _mastra;
  }

  console.log("Initializing Mastra instance...");

  // x402Agentã‚’éåŒæœŸã§ä½œæˆ
  _x402Agent = await createx402Agent(useGemini);
  _currentModelType = requestedModelType;

  _mastra = new Mastra({
    agents: { x402Agent: _x402Agent },
    logger: createLogger({
      name: "Mastra",
      level: "info",
    }),
  });

  console.log("Mastra instance created successfully");
  return _mastra;
};

/**
 * å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 * @deprecated Use getMastra() instead
 */
export const mastra = {
  async getAgent(name: string, useGemini: boolean) {
    const instance = await getMastra(useGemini);
    return instance.getAgent(name);
  },
};
```

ã‚µãƒ¼ãƒãƒ¼ã¨ã—ã¦å‘¼ã³å‡ºã™ãŸã‚å°‚ç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”¨æ„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™(ä»Šå›ã¯ã€`Express.js`ã‚’ãƒ™ãƒ¼ã‚¹ã«ä½œæˆã—ã¦ã„ã¾ã™)ã€‚

:::message
ãƒã‚¤ãƒ³ãƒˆã¯ä»¥ä¸‹ã®2ã¤ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã™ã€‚

1. `GET /ping` - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
2. `POST /invocations` - ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå‘¼ã³å‡ºã—ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

ã“ã‚Œã‚‰ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯Amazon Bedrock AgentCore Runtimesã®åˆ©ç”¨è¦ä»¶ã§å®šã‚ã‚‰ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…ã—ãªã„ã¨ã¡ã‚ƒã‚“ã¨å‘¼ã³å‡ºã™ã“ã¨ãŒã§ããªã„ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚
:::

ã‚ã¨ã€`Amazon Bedrock`ã«åŠ ãˆã¦`Gemini`ã«ä½¿ãˆã‚‹ã‚ˆã†ã«APIã‚­ãƒ¼ã®è¨­å®šã‚‚è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚

```ts
import dotenv from "dotenv";
// Load environment variables from .env file
dotenv.config();

import { GetParameterCommand, SSMClient } from "@aws-sdk/client-ssm";
import express, { type Request, type Response } from "express";
import { createx402Agent } from "./mastra/agents";

const app = express();
const PORT = process.env.PORT || 8080;
const HOST = "0.0.0.0";

/**
 * Load configuration from SSM Parameter Store if running in AWS
 * Falls back to environment variables for local development
 */
async function loadConfigFromSSM(): Promise<void> {
  // Check if we're running in AWS (AWS_REGION is set in AWS environments)
  const region = process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION;
  const isAws = !!region;

  console.log(`Environment check - AWS_REGION: ${region}, isAws: ${isAws}`);

  if (!isAws) {
    console.log("Not running in AWS - using environment variables");
    return;
  }

  // SSMã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–
  const ssmClient = new SSMClient({ region });

  // Load MCP_SERVER_URL
  if (!process.env.MCP_SERVER_URL) {
    const mcpServerUrlParam = "/agentcore/mastra/mcp-server-url";
    try {
      console.log(
        `Loading MCP_SERVER_URL from SSM Parameter Store: ${mcpServerUrlParam}`,
      );

      // MCPã‚µãƒ¼ãƒãƒ¼URLã®å€¤ã‚’å–å¾—
      const response = await ssmClient.send(
        new GetParameterCommand({
          Name: mcpServerUrlParam,
          WithDecryption: false,
        }),
      );

      const mcpServerUrl = response.Parameter?.Value;
      if (mcpServerUrl) {
        console.log(
          `âœ… Successfully loaded MCP_SERVER_URL from SSM: ${mcpServerUrl}`,
        );
        process.env.MCP_SERVER_URL = mcpServerUrl;
      } else {
        console.warn("âš ï¸  MCP_SERVER_URL parameter returned empty value");
      }
    } catch (error) {
      console.error("Failed to load MCP_SERVER_URL from SSM:");
      console.error(
        `  Error: ${(error as Error).name} - ${(error as Error).message}`,
      );
      console.error(`  Parameter: ${mcpServerUrlParam}`);
      console.error(`  Region: ${region}`);
      console.error("  Falling back to environment variable");
    }
  }

  // Load GOOGLE_GENERATIVE_AI_API_KEY
  if (!process.env.GOOGLE_GENERATIVE_AI_API_KEY) {
    const geminiApiKeyParam = "/agentcore/mastra/gemini-api-key";
    try {
      console.log(
        `Loading GOOGLE_GENERATIVE_AI_API_KEY from SSM Parameter Store: ${geminiApiKeyParam}`,
      );

      const response = await ssmClient.send(
        new GetParameterCommand({
          Name: geminiApiKeyParam,
          WithDecryption: true, // Decrypt SecureString
        }),
      );

      const apiKey = response.Parameter?.Value;
      if (apiKey) {
        console.log(
          "âœ… Successfully loaded GOOGLE_GENERATIVE_AI_API_KEY from SSM",
        );
        process.env.GOOGLE_GENERATIVE_AI_API_KEY = apiKey;
      } else {
        console.warn(
          "âš ï¸  GOOGLE_GENERATIVE_AI_API_KEY parameter returned empty value",
        );
      }
    } catch (error) {
      console.error("Failed to load GOOGLE_GENERATIVE_AI_API_KEY from SSM:");
      console.error(
        `  Error: ${(error as Error).name} - ${(error as Error).message}`,
      );
      console.error(`  Parameter: ${geminiApiKeyParam}`);
      console.error(`  Region: ${region}`);

      if (
        (error as Error).name === "ParameterNotFound" ||
        (error as Error).message?.includes("ParameterNotFound")
      ) {
        console.error("  ğŸ’¡ To create this parameter, run:");
        console.error(
          `     aws ssm put-parameter --name ${geminiApiKeyParam} --value "YOUR_API_KEY" --type SecureString --region ${region}`,
        );
      }

      console.error("  Falling back to environment variable");
    }
  }

  // Final validation
  if (!process.env.MCP_SERVER_URL) {
    console.warn(
      "âš ï¸  WARNING: MCP_SERVER_URL is not set. Agent functionality will be limited.",
    );
  }

  if (
    !process.env.GOOGLE_GENERATIVE_AI_API_KEY &&
    process.env.USE_GEMINI === "true"
  ) {
    console.warn(
      "âš ï¸  WARNING: GOOGLE_GENERATIVE_AI_API_KEY is not set but USE_GEMINI=true. Gemini model will fail.",
    );
  }
}

// Log environment variables for debugging
console.log("Environment variables loaded:");
console.log("- PORT:", PORT);
console.log("- USE_GEMINI:", process.env.USE_GEMINI);
console.log(
  "- GOOGLE_GENERATIVE_AI_API_KEY:",
  process.env.GOOGLE_GENERATIVE_AI_API_KEY ? "set (hidden)" : "not set",
);
console.log("- RESOURCE_SERVER_URL:", process.env.RESOURCE_SERVER_URL);
console.log("- ENDPOINT_PATH:", process.env.ENDPOINT_PATH);
console.log("- AWS_REGION:", process.env.AWS_REGION);

// JSON parsing middleware with raw body support for AgentCore Runtime
app.use(express.json({ limit: "100mb" }));
// Also support raw body parsing for binary payloads from AgentCore Runtime
app.use(express.raw({ type: "application/octet-stream", limit: "100mb" }));
app.use(express.text({ type: "text/plain", limit: "100mb" }));

// Logging middleware
app.use((req, _res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// Agent instance (lazy initialization)
let agentInstance: Awaited<ReturnType<typeof createx402Agent>> | null = null;
let agentInitError: Error | null = null;

/**
 * Initialize agent on startup
 */
async function initializeAgent() {
  try {
    console.log("Initializing x402 Agent...");
    const useGemini = process.env.USE_GEMINI === "true";
    agentInstance = await createx402Agent(useGemini);
    console.log(`Agent initialized with useGemini=${useGemini}`);
    console.log("Agent initialized successfully");
  } catch (error) {
    agentInitError = error as Error;
    console.error("Failed to initialize agent:", error);
  }
}

/**
 * Health check endpoint - Required by AgentCore Runtime
 * GET /ping
 *
 * Returns agent health status
 */
app.get("/ping", (_req: Request, res: Response) => {
  if (agentInstance) {
    res.status(200).json({
      status: "Healthy",
      time_of_last_update: Math.floor(Date.now() / 1000),
    });
  } else if (agentInitError) {
    res.status(503).json({
      status: "Unhealthy",
      error: agentInitError.message,
      time_of_last_update: Math.floor(Date.now() / 1000),
    });
  } else {
    res.status(503).json({
      status: "HealthyBusy",
      message: "Agent is initializing",
      time_of_last_update: Math.floor(Date.now() / 1000),
    });
  }
});

/**
 * Main invocation endpoint - Required by AgentCore Runtime
 * POST /invocations
 *
 * Processes user prompts through the AI agent
 */
app.post("/invocations", async (req: Request, res: Response) => {
  try {
    // Check if agent is initialized
    if (!agentInstance) {
      return res.status(503).json({
        error: "Agent not initialized",
        details: agentInitError?.message || "Agent is still initializing",
      });
    }

    // Log raw request for debugging
    console.log("Content-Type:", req.headers["content-type"]);
    console.log("Request body type:", typeof req.body);
    console.log(
      "Request body:",
      req.body instanceof Buffer
        ? `Buffer(${req.body.length} bytes)`
        : JSON.stringify(req.body, null, 2),
    );

    // Validate request body
    // AgentCore Runtime sends the payload as binary/JSON, so we need to handle both formats
    let prompt: string | undefined;
    let requestData: { prompt?: string; modelId?: string };

    // Handle Buffer (binary payload from AgentCore Runtime)
    if (req.body instanceof Buffer) {
      try {
        const textData = req.body.toString("utf-8");
        console.log("Decoded buffer:", textData);
        requestData = JSON.parse(textData);
      } catch (parseError) {
        // If JSON parsing fails, treat entire buffer as the prompt
        console.warn("Failed to parse buffer as JSON:", parseError);
        prompt = req.body.toString("utf-8");
        requestData = { prompt };
      }
    } else if (typeof req.body === "string") {
      // If body is a string, try to parse it
      try {
        requestData = JSON.parse(req.body);
      } catch {
        // If parsing fails, treat the entire body as the prompt
        prompt = req.body;
        requestData = { prompt };
      }
    } else if (typeof req.body === "object" && req.body !== null) {
      // Standard JSON object
      requestData = req.body;
    } else {
      return res.status(400).json({
        error: "Invalid request",
        details:
          "Request body must be a string, Buffer, or contain a 'prompt' string field",
        receivedBody: typeof req.body,
      });
    }

    // Extract prompt from requestData
    if (!prompt) {
      prompt = requestData.prompt || "";
    }

    if (!prompt || typeof prompt !== "string") {
      return res.status(400).json({
        error: "Invalid request",
        details: "Request must contain a valid 'prompt' string field",
        receivedData: requestData,
      });
    }

    console.log(`Processing prompt: ${prompt.substring(0, 100)}...`);

    // Check if streaming is requested
    const acceptHeader = req.headers.accept || "";
    const isStreaming = acceptHeader.includes("text/event-stream");

    if (isStreaming) {
      // Streaming response (SSE)
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");

      try {
        const result = await agentInstance.generate(prompt);

        // Simulate streaming for now (proper streaming requires different approach)
        const text = result.text;
        const chunks = text.split(" ");

        for (const chunk of chunks) {
          res.write(`data: ${JSON.stringify({ chunk: `${chunk} ` })}\n\n`);
        }

        res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
        res.end();
      } catch (streamError) {
        console.error("Streaming error:", streamError);
        res.write(
          `data: ${JSON.stringify({ error: "Streaming failed", details: (streamError as Error).message })}\n\n`,
        );
        res.end();
      }
    } else {
      // Non-streaming JSON response
      const result = await agentInstance.generate(prompt);

      res.status(200).json({
        response: result.text,
        status: "success",
        metadata: {
          model: "gemini-2.0-flash",
          tokens: result.usage?.totalTokens || 0,
        },
      });
    }
  } catch (error) {
    console.error("Invocation error:", error);
    res.status(500).json({
      error: "Internal server error",
      details: (error as Error).message,
    });
  }
});

/**
 * Root endpoint for basic connectivity test
 */
app.get("/", (_req: Request, res: Response) => {
  res.json({
    service: "Mastra x402 Agent",
    version: "0.1.0",
    status: agentInstance ? "ready" : "initializing",
    endpoints: {
      ping: "GET /ping",
      invocations: "POST /invocations",
    },
  });
});

/**
 * 404 handler
 */
app.use((_req: Request, res: Response) => {
  res.status(404).json({
    error: "Not found",
    message: "The requested endpoint does not exist",
  });
});

/**
 * Global error handler
 */
app.use(
  (
    err: Error,
    _req: Request,
    res: Response,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _next: express.NextFunction,
  ) => {
    console.error("Unhandled error:", err);
    res.status(500).json({
      error: "Internal server error",
      details: err.message,
    });
  },
);

/**
 * Start server
 */
async function startServer() {
  // Load configuration from SSM if in AWS environment
  await loadConfigFromSSM();

  console.log("Configuration loaded:");
  console.log("- MCP_SERVER_URL:", process.env.MCP_SERVER_URL || "not set");
  console.log(
    "- GOOGLE_GENERATIVE_AI_API_KEY:",
    process.env.GOOGLE_GENERATIVE_AI_API_KEY ? "set (hidden)" : "not set",
  );
  console.log("- USE_GEMINI:", process.env.USE_GEMINI);

  // Initialize agent before starting server
  await initializeAgent();

  app.listen(Number(PORT), HOST, () => {
    console.log(`ğŸš€ Mastra Agent Server running on http://${HOST}:${PORT}`);
    console.log(`ğŸ“ Health check: http://${HOST}:${PORT}/ping`);
    console.log(`ğŸ“ Invocations: http://${HOST}:${PORT}/invocations`);
    console.log(
      `ğŸ¤– Agent status: ${agentInstance ? "Ready" : "Failed to initialize"}`,
    );
  });
}

// Handle graceful shutdown
process.on("SIGTERM", () => {
  console.log("SIGTERM signal received: closing HTTP server");
  process.exit(0);
});

process.on("SIGINT", () => {
  console.log("SIGINT signal received: closing HTTP server");
  process.exit(0);
});

// Start the server
startServer().catch((error) => {
  console.error("Failed to start server:", error);
  process.exit(1);
});
```
::::

## x402 MCPã¨x402 Serverã®å®Ÿè£…

ã¾ãšã¯`x402 MCPã‚µãƒ¼ãƒãƒ¼`ã®å®Ÿè£…ã‹ã‚‰ï¼

::::details x402 MCPã®è§£èª¬

`Express.js`ã‚’ãƒ™ãƒ¼ã‚¹ã«MCP SDKã¨Viemã€x402ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼  

`Lambda`ä¸Šã§å‹•ã‹ã™ãŸã‚ã«`aws-lambda`ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚‚ä½¿ã£ã¦ã„ã¾ã™ã€‚

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import serverlessExpress from "@vendia/serverless-express";
import type {
  APIGatewayProxyEvent,
  APIGatewayProxyResult,
  Context,
} from "aws-lambda";
import axios from "axios";
import express from "express";
import type { Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { withPaymentInterceptor } from "x402-axios";

// Environment variables
const PORT = Number.parseInt(process.env.PORT || "8080", 10);
const RESOURCE_SERVER_URL = process.env.RESOURCE_SERVER_URL as string;

const privateKey = process.env.PRIVATE_KEY as Hex;
const baseURL = process.env.RESOURCE_SERVER_URL as string;
const endpointPath = process.env.ENDPOINT_PATH as string;

console.log("Lambda function started!");
console.log("Using RESOURCE_SERVER_URL:", RESOURCE_SERVER_URL);
console.log("Environment variables:", JSON.stringify(process.env, null, 2));

// ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚³ã‚¤ãƒ³ã‚’æ”¯æ‰•ã†ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
// â€» ä»Šå¾Œè¦æ”¹è‰¯ãƒã‚¤ãƒ³ãƒˆ
const account = privateKeyToAccount(privateKey);
// x402ã‚’é©ç”¨ã•ã›ã‚‹ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
const client = withPaymentInterceptor(axios.create({ baseURL }), account);

// Create an MCP server
const server = new McpServer({
  name: "x402 MCP Server",
  version: "1.0.0",
});

// Express app
const app = express();
app.use(express.json());

// ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚°ç”¨ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  console.log("Headers:", JSON.stringify(req.headers, null, 2));
  console.log("Body:", JSON.stringify(req.body, null, 2));
  next();
});

/**
 * get Weather date tool
 */
server.tool(
  "get-data-from-resource-server",
  "Get data from the resource server (in this example, the weather)",
  async () => {
    try {
      // ç’°å¢ƒå¤‰æ•°ã§æ¸¡ã•ã‚ŒãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¦APIã‚’å®Ÿè¡Œã™ã‚‹
      // ã“ã“ã§x402ã®æ”¯æ‰•ã„å‡¦ç†ãŒè‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹
      const res = await client.get(endpointPath);
      return {
        content: [{ type: "text", text: JSON.stringify(res.data) }],
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error("Failed to fetch data from resource server:", errorMessage);
      return {
        content: [
          {
            type: "text",
            text: `Error fetching data: ${errorMessage}`,
          },
        ],
        isError: true,
      };
    }
  },
);

// Create HTTP transport
const transport = new StreamableHTTPServerTransport({
  sessionIdGenerator: undefined, // Disable session management
});

// Routes
app.post("/mcp", async (req, res) => {
  console.log("MCP POST request received!");
  console.log("Request body:", JSON.stringify(req.body, null, 2));
  try {
    await transport.handleRequest(req, res, req.body);
  } catch (error) {
    console.error("MCP request handling error:", error);
    if (!res.headersSent) {
      res.status(500).json({
        jsonrpc: "2.0",
        error: {
          code: -32603,
          message: "Internal server error",
        },
        id: null,
      });
    }
  }
});

app.get("/mcp", async (req, res) => {
  res.writeHead(405).end(
    JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Method not allowed.",
      },
      id: null,
    }),
  );
});

app.delete("/mcp", async (req, res) => {
  res.writeHead(405).end(
    JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Method not allowed.",
      },
      id: null,
    }),
  );
});

// Health check endpoint
app.get("/health", (req, res) => {
  res.json({ status: "healthy", timestamp: new Date().toISOString() });
});

// For AWS Lambda
let serverConnected = false;
const ensureServerConnection = async () => {
  if (!serverConnected) {
    await server.connect(transport);
    serverConnected = true;
  }
};

/**
 * Lambda handler ãƒ¡ã‚½ãƒƒãƒ‰
 * @param event APIGatewayProxyEvent
 * @param context Context
 * @returns APIGatewayProxyResult
 */
export const handler = async (
  event: APIGatewayProxyEvent,
  context: Context,
): Promise<APIGatewayProxyResult> => {
  console.log("Lambda handler called!");
  console.log("Event:", JSON.stringify(event, null, 2));
  console.log("Context:", JSON.stringify(context, null, 2));

  try {
    await ensureServerConnection();
    const serverlessHandler = serverlessExpress({ app });
    return new Promise((resolve, reject) => {
      serverlessHandler(event, context, (error, result) => {
        if (error) {
          console.error("Serverless handler error:", error);
          reject(error);
        } else {
          console.log("Serverless handler success:", result);
          resolve(result as APIGatewayProxyResult);
        }
      });
    });
  } catch (error) {
    console.error("Lambda handler error:", error);
    throw error;
  }
};

server
  .connect(transport)
  .then(() => {
    app.listen(PORT, () => {
      console.log(`MCP server listening on port ${PORT}`);
    });
  })
  .catch((error) => {
    console.error("Server setup failed:", error);
    process.exit(1);
  });
```

ã‹ãªã‚Šã‚·ãƒ³ãƒ—ãƒ«ã§ã™ï¼

::::

æ¬¡ã«`x402ã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼`ã®è§£èª¬ã«ãªã‚Šã¾ã™ï¼

::::details x402 Serverã®è§£èª¬

`Hono`ã‚’ãƒ™ãƒ¼ã‚¹ã«ä½œæˆã—ã¦ã„ã¾ã™ï¼

`x402-hono`ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒæä¾›ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚’ä½¿ã†ã“ã¨ã§ã¨ã¦ã‚‚æ‰‹è»½ã«Honoã§ä½œã£ãŸAPIã‚’x402ã«å¯¾å¿œã•ã›ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ï¼ï¼

```ts
import { serve } from "@hono/node-server";
import { config } from "dotenv";
import { Hono } from "hono";
import { cors } from "hono/cors";
import type { Network, Resource } from "x402-hono";
import { paymentMiddleware } from "x402-hono";
// Import walrus functions from relative paths

config();

// ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ facilitatorUrlã¨æ”¯æ‰•ã„å…ˆã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã€ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚’èª­ã¿è¾¼ã‚€
const facilitatorUrl = process.env.FACILITATOR_URL as Resource;
const payTo = process.env.ADDRESS as `0x${string}`;
const network = process.env.NETWORK as Network;

if (!facilitatorUrl || !payTo || !network) {
  console.error("Missing required environment variables");
  process.exit(1);
}

const app = new Hono();

console.log("Server is running");

// CORS
app.use(
  cors({
    origin: ["*"],
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    exposeHeaders: ["Content-Length", "X-Requested-With"],
    maxAge: 600,
    credentials: true,
  }),
);

// Health check endpoint (before payment middleware)
app.get("/health", async (c) => {
  return c.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    port,
  });
});

app.use(
  // ã“ã®è¨­å®šã‚’åŠ ãˆã‚‹ã ã‘ã§x402ã«å¯¾å¿œã—ãŸãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã«ç”Ÿã¾ã‚Œå¤‰ã‚ã‚‹
  // /weather endpoint ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸæ™‚ã« requires paymentã‚’ç™ºå‹•ã•ã›ã‚‹
  paymentMiddleware(
    payTo,
    {
      "/weather": {
        price: "$0.001",
        network,
      },
    },
    {
      url: facilitatorUrl,
    },
  ),
);

// get weather report API
app.get("/weather", async (c) => {
  // ä»»æ„ã®å‡¦ç†ã‚’ã“ã“ã«å…¥ã‚Œã‚‹
  console.log("Payment received, processing weather report request...");
  // ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ã‚³ã‚¤ãƒ³ã‚’æ”¯æ‰•ã£ãŸçµæœã¨ã—ã¦ãƒ€ãƒŸãƒ¼ã®å¤©æ°—ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
  return c.json({
    report: {
      weather: "sunny",
      temperature: 70,
    },
  });
});

// Use PORT from environment variable for Cloud Run compatibility
const port = process.env.PORT ? Number.parseInt(process.env.PORT, 10) : 4021;

serve({
  fetch: app.fetch,
  port,
});

console.log(`Server is running on port ${port}`);
```
::::

## CDKã‚¹ã‚¿ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«

æœ€å¾Œã«CDKã‚¹ã‚¿ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£èª¬ã«ãªã‚Šã¾ã™ï¼

::::details CDKã‚¹ã‚¿ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£èª¬

CDKã‚¹ã‚¿ãƒƒã‚¯ã¯ã‹ãªã‚Šã®ã‚³ãƒ¼ãƒ‰é‡ã«ãªã£ã¦ã„ã¾ã™ï¼ï¼

```ts
import * as cdk from "aws-cdk-lib";
import * as agentcore from "aws-cdk-lib/aws-bedrockagentcore";
import * as ec2 from "aws-cdk-lib/aws-ec2";
import * as ecr from "aws-cdk-lib/aws-ecr";
import * as ecr_assets from "aws-cdk-lib/aws-ecr-assets";
import * as ecs from "aws-cdk-lib/aws-ecs";
import * as ecsPatterns from "aws-cdk-lib/aws-ecs-patterns";
import * as iam from "aws-cdk-lib/aws-iam";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as logs from "aws-cdk-lib/aws-logs";
import * as ssm from "aws-cdk-lib/aws-ssm";
import type { Construct } from "constructs";
import * as dotenv from "dotenv";
import { execSync } from "node:child_process";
import * as fs from "node:fs";
import { join } from "node:path";
dotenv.config();

// Lambdaé–¢æ•°ã‚„MCPã‚µãƒ¼ãƒãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‹ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã‚€
const { FACILITATOR_URL, ADDRESS, NETWORK, ENDPOINT_PATH, PRIVATE_KEY } =
  process.env;

/**
 * Amazon Bedrock AgentCore âœ–ï¸ Mastra âœ–ï¸ x402 MCP ã‚µãƒ¼ãƒãƒ¼ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ã‚¹ã‚¿ãƒƒã‚¯
 *
 * ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹
 * 1. Amazon Bedrock AgentCore
 * 2. Mastraè£½AI Agent
 * 3. x402 MCP ã‚µãƒ¼ãƒãƒ¼
 * 4. x402 ã«å¯¾å¿œã—ãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚µãƒ¼ãƒãƒ¼
 */
export class AgentCoreMastraX402Stack extends cdk.Stack {
  /**
   * ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼
   * @param scope
   * @param id
   * @param props
   */
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Create VPC for Fargate service
    const vpc = new ec2.Vpc(this, "AgentCoreMastraX402Vpc", {
      maxAzs: 2,
      natGateways: 1,
    });

    // ===========================================================================
    // Fargateã§x402ã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼(ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚µãƒ¼ãƒãƒ¼)ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
    // ã‚³ãƒ³ãƒ†ãƒŠãƒªãƒã‚¸ãƒˆãƒªã‚’ä½œæˆã—ã¦ã‚³ãƒ³ãƒ†ãƒŠã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
    //ã€€===========================================================================

    // Create ECR repository reference (assuming it already exists)
    const backendRepo = ecr.Repository.fromRepositoryName(
      this,
      "AgentCoreMastraX402BackendRepo",
      "x402-backend-api",
    );

    // Create ECS cluster
    const cluster = new ecs.Cluster(this, "AgentCoreMastraX402Cluster", {
      vpc,
      clusterName: "x402-cluster",
    });

    // Create Fargate service for backend API
    const backendService =
      new ecsPatterns.ApplicationLoadBalancedFargateService(
        this,
        "AgentCoreMastraX402BackendService",
        {
          cluster,
          serviceName: "x402-backend-api",
          cpu: 512,
          memoryLimitMiB: 1024,
          desiredCount: 1,
          taskImageOptions: {
            // ã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®æŒ‡å®š
            image: ecs.ContainerImage.fromEcrRepository(backendRepo, "latest"),
            containerPort: 4021,
            // ç’°å¢ƒå¤‰æ•°ã®å‰²ã‚Šå½“ã¦
            environment: {
              PORT: "4021",
              NODE_ENV: "production",
              // Add other environment variables as needed
              FACILITATOR_URL: FACILITATOR_URL as string,
              ADDRESS: ADDRESS as string,
              NETWORK: NETWORK as string,
            },
            logDriver: ecs.LogDrivers.awsLogs({
              streamPrefix: "x402-backend",
              logGroup: new logs.LogGroup(
                this,
                "AgentCoreMastraX402BackendLogGroup",
                {
                  logGroupName: "/aws/ecs/x402-backend",
                  retention: logs.RetentionDays.ONE_WEEK,
                  removalPolicy: cdk.RemovalPolicy.DESTROY,
                },
              ),
            }),
          },
          publicLoadBalancer: true,
          assignPublicIp: true,
          healthCheckGracePeriod: cdk.Duration.seconds(300),
        },
      );

    // Configure health check for the target group
    backendService.targetGroup.configureHealthCheck({
      path: "/health",
      healthyHttpCodes: "200",
      interval: cdk.Duration.seconds(30),
      timeout: cdk.Duration.seconds(5),
      healthyThresholdCount: 2,
      unhealthyThresholdCount: 5,
    });

    // ===========================================================================
    // Lambda Web Adapter ã‚’ä½¿ã£ã¦ã€€Lambdaä¸Šã«MCPã‚µãƒ¼ãƒãƒ¼ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
    //ã€€===========================================================================

    // Create Lambda function for MCP server (force rebuild v3 - bundle.js fix)
    const mcpLambdaFunction = new lambda.Function(
      this,
      "AgentCoreMastraX402MCPServerFunction",
      {
        runtime: lambda.Runtime.NODEJS_22_X,
        code: lambda.Code.fromAsset(join(__dirname, "../../mcp"), {
          bundling: {
            image: lambda.Runtime.NODEJS_22_X.bundlingImage,
            user: "root",
            command: ["echo", "local bundling"], // Dummy command - local bundling will be used
            local: {
              tryBundle(outputDir: string) {
                try {
                  const sourceDir = join(__dirname, "../../mcp");
                  console.log(
                    `Building MCP Lambda from: ${sourceDir} to: ${outputDir}`,
                  );

                  // Check if bundle.js exists in source directory
                  const sourceBundlePath = join(sourceDir, "bundle.js");
                  if (!fs.existsSync(sourceBundlePath)) {
                    console.error(
                      "bundle.js not found in source directory. Please run 'pnpm mcp build' first.",
                    );
                    throw new Error(
                      "bundle.js not found. Run 'pnpm mcp build' before deploying.",
                    );
                  }

                  // Copy only necessary files for Lambda deployment
                  const filesToCopy = ["bundle.js", "run.sh"];

                  for (const file of filesToCopy) {
                    const srcPath = join(sourceDir, file);
                    const destPath = join(outputDir, file);
                    if (fs.existsSync(srcPath)) {
                      console.log(`Copying: ${file}`);
                      execSync(`cp ${srcPath} ${destPath}`, {
                        stdio: "inherit",
                      });
                    } else {
                      throw new Error(`Required file not found: ${file}`);
                    }
                  }

                  // Make run.sh executable
                  const runShPath = join(outputDir, "run.sh");
                  execSync(`chmod +x ${runShPath}`, {
                    stdio: "inherit",
                  });

                  // Verify bundle.js exists
                  const bundlePath = join(outputDir, "bundle.js");
                  if (!fs.existsSync(bundlePath)) {
                    throw new Error("bundle.js was not copied successfully");
                  }

                  // Get bundle.js file size
                  const bundleStats = fs.statSync(bundlePath);
                  console.log(
                    `Bundle file size: ${(bundleStats.size / 1024 / 1024).toFixed(2)} MB`,
                  );

                  // List final contents
                  console.log("Final Lambda package contents:");
                  execSync(`ls -la ${outputDir}`, { stdio: "inherit" });

                  console.log("Local bundling completed successfully");
                  return true;
                } catch (error) {
                  console.error("Local bundling failed:", error);
                  return false;
                }
              },
            },
          },
        }),
        handler: "run.sh",
        // ç’°å¢ƒå¤‰æ•°ã®å‰²ã‚Šå½“ã¦
        environment: {
          AWS_LAMBDA_EXEC_WRAPPER: "/opt/bootstrap",
          AWS_LAMBDA_INVOKE_MODE: "response_stream",
          RUST_LOG: "info",
          ENDPOINT_PATH: ENDPOINT_PATH || "/weather",
          PRIVATE_KEY: PRIVATE_KEY || "",
          RESOURCE_SERVER_URL: `http://${backendService.loadBalancer.loadBalancerDnsName}`,
        },
        timeout: cdk.Duration.minutes(15), // Lambda maximum timeout is 15 minutes (900 seconds)
        memorySize: 1024,
        architecture: lambda.Architecture.X86_64,
        // LambdaWebAdapterã‚’ä½¿ã†ã®ã§ãã®è¨­å®šã‚’ Lambda Layerã«åŠ ãˆã‚‹
        layers: [
          lambda.LayerVersion.fromLayerVersionArn(
            this,
            "LambdaWebAdapterLayer",
            `arn:aws:lambda:${this.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
          ),
        ],
      },
    );

    // Create Function URL for the MCP server
    const mcpFunctionUrl = mcpLambdaFunction.addFunctionUrl({
      authType: lambda.FunctionUrlAuthType.NONE,
      cors: {
        allowCredentials: true,
        allowedHeaders: ["*"],
        allowedMethods: [lambda.HttpMethod.ALL],
        allowedOrigins: ["*"],
        maxAge: cdk.Duration.seconds(86400),
      },
    });

    // Store MCP Server URL in SSM Parameter Store for runtime access
    const mcpServerUrlParameter = new ssm.StringParameter(
      this,
      "McpServerUrlParameter",
      {
        parameterName: "/agentcore/mastra/mcp-server-url",
        stringValue: mcpFunctionUrl.url,
        description:
          "MCP Server Function URL for Mastra Agent runtime configuration",
        tier: ssm.ParameterTier.STANDARD,
      },
    );

    // Store Google Gemini API Key in SSM Parameter Store (SecureString)
    // Note: This should be set manually or via CDK context/secrets
    // For now, create a placeholder that needs to be updated manually
    const geminiApiKey = process.env.GOOGLE_GENERATIVE_AI_API_KEY;
    if (!geminiApiKey || geminiApiKey === "PLACEHOLDER_UPDATE_MANUALLY") {
      throw new Error(
        "GOOGLE_GENERATIVE_AI_API_KEY environment variable must be set with a valid API key",
      );
    }
    // Gemini APIã‚­ãƒ¼ã‚’SSMãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢ã®è¨­å®š
    const geminiApiKeyParameter = new ssm.StringParameter(
      this,
      "GeminiApiKeyParameter",
      {
        parameterName: "/agentcore/mastra/gemini-api-key",
        stringValue: geminiApiKey,
        description: "Google Gemini API Key for Mastra Agent",
      },
    );

    // ===========================================================================
    // Amazon Bedrock AgentCore Runtime 
    //ã€€===========================================================================

    // Build Docker image for AgentCore Runtime using ECR Assets
    // Note: Environment variables like MCP_SERVER_URL must be set at runtime
    // since they contain CDK tokens that are resolved during deployment
    const agentCoreDockerImage = new ecr_assets.DockerImageAsset(
      this,
      "AgentCoreDockerImage",
      {
        directory: join(__dirname, "../../mastra-agent"),
        file: "Dockerfile",
        platform: ecr_assets.Platform.LINUX_ARM64, // ARM64 for cost optimization
      },
    );

    // Create IAM role for AgentCore Runtime
    const agentCoreRole = new iam.Role(this, "BedrockAgentCoreRole", {
      assumedBy: new iam.ServicePrincipal("bedrock-agentcore.amazonaws.com"),
      description: "IAM role for Bedrock AgentCore Runtime",
    });

    const region = cdk.Stack.of(this).region;
    const accountId = cdk.Stack.of(this).account;

    // ECR permissions
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        sid: "ECRImageAccess",
        effect: iam.Effect.ALLOW,
        actions: ["ecr:BatchGetImage", "ecr:GetDownloadUrlForLayer"],
        resources: [`arn:aws:ecr:${region}:${accountId}:repository/*`],
      }),
    );
    // ãƒãƒªã‚·ãƒ¼ã‚’è¨­å®š
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        sid: "ECRTokenAccess",
        effect: iam.Effect.ALLOW,
        actions: ["ecr:GetAuthorizationToken"],
        resources: ["*"],
      }),
    );

    // CloudWatch Logs permissions
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: ["logs:DescribeLogStreams", "logs:CreateLogGroup"],
        resources: [
          `arn:aws:logs:${region}:${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*`,
        ],
      }),
    );

    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: ["logs:DescribeLogGroups"],
        resources: [`arn:aws:logs:${region}:${accountId}:log-group:*`],
      }),
    );

    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: ["logs:CreateLogStream", "logs:PutLogEvents"],
        resources: [
          `arn:aws:logs:${region}:${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*`,
        ],
      }),
    );

    // X-Ray and CloudWatch Metrics permissions
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          "xray:PutTraceSegments",
          "xray:PutTelemetryRecords",
          "xray:GetSamplingRules",
          "xray:GetSamplingTargets",
        ],
        resources: ["*"],
      }),
    );

    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: ["cloudwatch:PutMetricData"],
        resources: ["*"],
        conditions: {
          StringEquals: {
            "cloudwatch:namespace": "bedrock-agentcore",
          },
        },
      }),
    );

    // Bedrock model invocation permissions
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        sid: "BedrockModelInvocation",
        effect: iam.Effect.ALLOW,
        actions: [
          "bedrock:InvokeModel",
          "bedrock:InvokeModelWithResponseStream",
        ],
        resources: [
          "arn:aws:bedrock:*::foundation-model/*",
          `arn:aws:bedrock:${region}:${accountId}:*`,
        ],
      }),
    );

    // AgentCore workload identity permissions
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        sid: "GetAgentAccessToken",
        effect: iam.Effect.ALLOW,
        actions: [
          "bedrock-agentcore:GetWorkloadAccessToken",
          "bedrock-agentcore:GetWorkloadAccessTokenForJWT",
          "bedrock-agentcore:GetWorkloadAccessTokenForUserId",
        ],
        resources: [
          `arn:aws:bedrock-agentcore:${region}:${accountId}:workload-identity-directory/default`,
          `arn:aws:bedrock-agentcore:${region}:${accountId}:workload-identity-directory/default/workload-identity/agentName-*`,
        ],
      }),
    );

    // SSM Parameter Store read permissions for runtime configuration
    // Grant explicit read access to configuration parameters
    agentCoreRole.addToPolicy(
      new iam.PolicyStatement({
        sid: "ReadSSMParameters",
        effect: iam.Effect.ALLOW,
        actions: [
          "ssm:GetParameter",
          "ssm:GetParameters",
          "ssm:GetParametersByPath",
        ],
        resources: [
          // Specific parameters
          mcpServerUrlParameter.parameterArn,
          geminiApiKeyParameter.parameterArn,
          // Wildcard for all parameters under this path
          `arn:aws:ssm:${region}:${accountId}:parameter/agentcore/mastra/*`,
        ],
      }),
    );

    // Also grant read access via the Parameter resource directly
    mcpServerUrlParameter.grantRead(agentCoreRole);
    geminiApiKeyParameter.grantRead(agentCoreRole);

    // Create AgentCore Runtime
    // Note: CfnRuntime does not support direct environment variable configuration
    // The mastra-agent must:
    // 1. Use default/placeholder values for MCP_SERVER_URL during build
    // 2. Allow runtime configuration through external mechanisms (e.g., Parameter Store, Secrets Manager)
    // 3. Or implement a configuration service that reads from AWS resources
    //
    // For now, the MCP_SERVER_URL can be:
    // - Hardcoded if known in advance
    // - Retrieved from Parameter Store at container startup
    // - Passed through a custom runtime configuration endpoint
    //
    // The Dockerfile sets:
    // - PORT=8080 (required by AgentCore)
    // - NODE_ENV=production
    // - USE_GEMINI=true (for Bedrock models)
    const agentCoreRuntime = new agentcore.CfnRuntime(
      this,
      "MastraAgentCoreRuntime",
      {
        agentRuntimeName: "MastraAgentRuntime",
        agentRuntimeArtifact: {
          containerConfiguration: {
            containerUri: agentCoreDockerImage.imageUri,
          },
        },
        networkConfiguration: {
          networkMode: "PUBLIC",
        },
        roleArn: agentCoreRole.roleArn,
        protocolConfiguration: "HTTP",
      },
    );

    // Ensure proper dependency chain: Parameters -> Role -> Runtime
    agentCoreRuntime.node.addDependency(agentCoreRole);
    agentCoreRuntime.node.addDependency(mcpServerUrlParameter);
    agentCoreRuntime.node.addDependency(geminiApiKeyParameter);

    // Create AgentCore Runtime Endpoint
    const agentCoreEndpoint = new agentcore.CfnRuntimeEndpoint(
      this,
      "MastraAgentCoreEndpoint",
      {
        agentRuntimeId: agentCoreRuntime.attrAgentRuntimeId,
        agentRuntimeVersion: agentCoreRuntime.attrAgentRuntimeVersion,
        name: "MastraAgentRuntimeEndpoint",
      },
    );

    // ===========================================================================
    // Fargateã§ Next.js Frontend ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
    //ã€€===========================================================================

    // Create ECR repository reference for Frontend
    const frontendRepo = ecr.Repository.fromRepositoryName(
      this,
      "AgentCoreMastraFrontendRepo",
      "agentcore-mastra-frontend",
    );

    // Create Fargate service for Frontend
    const frontendService =
      new ecsPatterns.ApplicationLoadBalancedFargateService(
        this,
        "AgentCoreMastraFrontendService",
        {
          cluster,
          serviceName: "agentcore-frontend",
          cpu: 512,
          memoryLimitMiB: 1024,
          desiredCount: 1,
          taskImageOptions: {
            image: ecs.ContainerImage.fromEcrRepository(frontendRepo, "latest"),
            containerPort: 3000,
            environment: {
              PORT: "3000",
              NODE_ENV: "production",
              AWS_REGION: this.region,
              // AgentCore Runtime Endpoint ARN (æ­£ã—ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆARNã‚’ä½¿ç”¨)
              // CfnRuntimeEndpointã‹ã‚‰å–å¾—ã—ãŸæ­£å¼ãªARNã‚’æ¸¡ã™
              // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã®å‘¼ã³å‡ºã—æ™‚ã«å¿…è¦
              AGENTCORE_RUNTIME_ARN: agentCoreEndpoint.attrAgentRuntimeArn,
              AGENTCORE_RUNTIME_QUALIFIER: "MastraAgentRuntimeEndpoint",
            },
            logDriver: ecs.LogDrivers.awsLogs({
              streamPrefix: "agentcore-frontend",
              logGroup: new logs.LogGroup(
                this,
                "AgentCoreMastraFrontendLogGroup",
                {
                  logGroupName: "/aws/ecs/agentcore-frontend",
                  retention: logs.RetentionDays.ONE_WEEK,
                  removalPolicy: cdk.RemovalPolicy.DESTROY,
                },
              ),
            }),
          },
          publicLoadBalancer: true,
          assignPublicIp: true,
          healthCheckGracePeriod: cdk.Duration.seconds(300),
        },
      );

    // Configure health check for Frontend
    frontendService.targetGroup.configureHealthCheck({
      path: "/api/health",
      healthyHttpCodes: "200",
      interval: cdk.Duration.seconds(30),
      timeout: cdk.Duration.seconds(5),
      healthyThresholdCount: 2,
      unhealthyThresholdCount: 5,
    });

    // Grant Frontend task role permission to invoke AgentCore Runtime
    frontendService.taskDefinition.taskRole.addToPrincipalPolicy(
      new iam.PolicyStatement({
        sid: "InvokeAgentCoreRuntime",
        effect: iam.Effect.ALLOW,
        actions: [
          "bedrock-agentcore:InvokeAgentRuntime",
          "bedrock-agentcore:InvokeAgentRuntimeWithResponseStream",
        ],
        resources: [
          agentCoreRuntime.attrAgentRuntimeArn,
          `${agentCoreRuntime.attrAgentRuntimeArn}/*`,
        ],
      }),
    );

    // ===========================================================================
    // æˆæœç‰©
    //ã€€===========================================================================

    new cdk.CfnOutput(this, "AgentCoreMastraX402BackendApiUrl", {
      value: `http://${backendService.loadBalancer.loadBalancerDnsName}`,
      description: "x402 Backend API Load Balancer URL",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraX402MCPServerUrl", {
      value: mcpFunctionUrl.url,
      description: "MCP Server Function URL",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraX402MCPServerUrlParameter", {
      value: mcpServerUrlParameter.parameterName,
      description:
        "SSM Parameter Store name for MCP Server URL (used by AgentCore Runtime)",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraX402MCPServerUrlParameterArn", {
      value: mcpServerUrlParameter.parameterArn,
      description: "SSM Parameter ARN (for IAM permissions verification)",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraX402GeminiApiKeyParameter", {
      value: geminiApiKeyParameter.parameterName,
      description:
        "SSM Parameter Store name for Gemini API Key (update manually if needed)",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraRuntimeArn", {
      value: agentCoreRuntime.attrAgentRuntimeArn,
      description: "Amazon Bedrock AgentCore Runtime ARN",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraRuntimeRegion", {
      value: region,
      description: "AWS Region for runtime resources",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraRuntimeId", {
      value: agentCoreRuntime.attrAgentRuntimeId,
      description: "Amazon Bedrock AgentCore Runtime ID",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraEndpointArn", {
      value: agentCoreEndpoint.attrAgentRuntimeEndpointArn,
      description: "Amazon Bedrock AgentCore Runtime Endpoint ARN",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraFrontendUrl", {
      value: `http://${frontendService.loadBalancer.loadBalancerDnsName}`,
      description: "Frontend Application Load Balancer URL",
    });

    new cdk.CfnOutput(this, "AgentCoreMastraX402VpcId", {
      value: vpc.vpcId,
      description: "VPC ID",
    });
  }
}
```
::::

é•·ã‹ã£ãŸã§ã™ãŒã€å®Ÿè£…ã®æ™‚ã«ãƒã‚¤ãƒ³ãƒˆã«ãªã£ãŸç‚¹ã®è§£èª¬ã¯ä»¥ä¸Šã«ãªã‚Šã¾ã™ï¼ï¼ï¼

# å‹•ã‹ã—æ–¹

æœ€å¾Œã«å‹•ã‹ã—æ–¹ã«ã¤ã„ã¦è§£èª¬ã—ã¾ã™ï¼

## ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

ã¾ãšGitHubãƒªãƒã‚¸ãƒˆãƒªã‚’è‡ªåˆ†ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ•ã‚©ãƒ¼ã‚¯ã—ã¦ãã¦ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ãã¾ã™ã€‚

```bash
git clone https://github.com/<your_account_id>/AgentCore-Mastra-x402.git
```

ãã—ã¦ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

```bash
pnpm install
```

æ¬¡ã«ç’°å¢ƒå¤‰æ•°ç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚

```txt
cp pkgs/cdk/.env.example pkgs/cdk/.env
```

ä»¥ä¸‹ã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```txt
FACILITATOR_URL=https://x402.org/facilitator
NETWORK=base-sepolia
# é€é‡‘å…ˆã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®š
ADDRESS=
ENDPOINT_PATH=/weather
# é€é‡‘å…ƒã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®š
PRIVATE_KEY=
GOOGLE_GENERATIVE_AI_API_KEY=
```

## ã‚³ãƒãƒ³ãƒ‰ç³»

### AgentCoreç”¨ã®Dockerã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®ç™»éŒ²

ã¾ãšã¯Amazon ECRã«`Mastra AgentCore Runtime`ç”¨ã®Dockerã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç™»éŒ²ã—ã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’é †ç•ªã«å®Ÿè¡Œã—ã¦ECRã®ä½œæˆã€œã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®ç™»éŒ²ã‚’è¡Œã„ã¾ã™ã€‚

```bash
# ECRãƒªãƒã‚¸ãƒˆãƒªã‚’ä½œæˆ
aws ecr create-repository --repository-name agentcore-mastra-agent
# pkgs/mastra-agenté…ä¸‹ã§å®Ÿè¡Œ
docker build --platform linux/arm64 -t mastra-agent:latest .

export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

# ECRãƒ­ã‚°ã‚¤ãƒ³
aws ecr get-login-password --region ap-northeast-1 | \
  docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.ap-northeast-1.amazonaws.com

# ã‚¿ã‚°ä»˜ã‘
docker tag mastra-agent:latest $AWS_ACCOUNT_ID.dkr.ecr.ap-northeast-1.amazonaws.com/agentcore-mastra-agent:latest

# ãƒ—ãƒƒã‚·ãƒ¥
docker push $AWS_ACCOUNT_ID.dkr.ecr.ap-northeast-1.amazonaws.com/agentcore-mastra-agent:latest
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç”¨ã®Dockerã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®ç™»éŒ²

æ¬¡ã«Amazon ECRã«`ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰`ç”¨ã®Dockerã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç™»éŒ²ã—ã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’é †ç•ªã«å®Ÿè¡Œã—ã¦ECRã®ä½œæˆã€œã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®ç™»éŒ²ã‚’è¡Œã„ã¾ã™ã€‚

```bash
# ECRãƒªãƒã‚¸ãƒˆãƒªã‚’ä½œæˆ
aws ecr create-repository --repository-name agentcore-mastra-frontend
export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

# ECRãƒ­ã‚°ã‚¤ãƒ³
aws ecr get-login-password --region ap-northeast-1 | \
  docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.ap-northeast-1.amazonaws.com

# linux/amd64ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å‘ã‘ã«ãƒ“ãƒ«ãƒ‰ (Fargate x86_64ç”¨)
cd pkgs/frontend
docker buildx build --platform linux/amd64 \
  -t $AWS_ACCOUNT_ID.dkr.ecr.ap-northeast-1.amazonaws.com/agentcore-mastra-frontend:latest \
  --push .
```

### Lambdaé–¢æ•°ç”¨ã®ãƒ“ãƒ«ãƒ‰ã‚’è¡Œã†

ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§MCPç”¨ã®Lambdaé–¢æ•°ã®ãƒ“ãƒ«ãƒ‰ã‚’è¡Œã„ã¾ã™ã€‚

```bash
pnpm mcp build
```

ã“ã“ã¾ã§ã§ããŸã‚‰æº–å‚™OKã§ã™ï¼

### CDKã‚¹ã‚¿ãƒƒã‚¯ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤

ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¸¸ã”ã¨ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™ï¼ï¼

```bash
pnpm cdk run deploy 'AgentCoreMastraX402Stack'
```

### CDKã‚¹ã‚¿ãƒƒã‚¯ãƒªã‚½ãƒ¼ã‚¹ã‚’å–ã‚Šé™¤ã

æ¤œè¨¼ãŒçµ‚ã‚ã£ãŸã‚‰å¿˜ã‚Œãšã«ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãƒªã‚½ãƒ¼ã‚¹ã‚’å‰Šé™¤ã—ã¾ã—ã‚‡ã†ï¼

```bash
pnpm cdk run destroy 'AgentCoreMastraX402Stack' --force
```

:::message
ECRãƒªãƒã‚¸ãƒˆãƒªã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢ã¯æ‰‹å‹•ã§å‰Šé™¤ãŒå¿…è¦ã«ãªã‚Šã¾ã™ï¼
:::

# ã¾ã¨ã‚

**Amazon Bedrock AgentCore**ã‚’ä½¿ã£ã¦ã¿ã‚ˆã†ã¨ã„ã†ã“ã¨ã§ä»Šå›ã¯x402ã‚’çµ„ã¿åˆã‚ã›ã¦ã¿ã¾ã—ãŸï¼

https://aws.amazon.com/jp/bedrock/agentcore/

**Strands Agent**ã®TypeScript SDKãŒå‡ºãŸã®ã§ä»Šåº¦ã¯ãã‚Œã‚’ä½¿ã£ã¦ã¿ã¦ã‚‚ã„ã„ãªã¨æ€ã£ã¦ã„ã¾ã™ã€‚

https://strandsagents.com/latest/

https://github.com/strands-agents/sdk-typescript

MCPã®å®Ÿè£…ã¯ä»Šã®ã¾ã¾ã ã¨ã‚»ã‚­ãƒ¥ã‚¢ã¨ã¯è¨€ãˆãªã„ã®ã§ãã®éƒ¨åˆ†ã‚’æ”¹å–„ã—ãŸã„ã®ã¨ã€ç§˜å¯†éµã‚‚ç’°å¢ƒå¤‰æ•°ã¨ã—ã¦è¨­å®šã—ã¦ãŠã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ãŒã§ããªã„çŠ¶æ…‹ãªã®ã§ã“ã“ã‚‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«**KMS**ã¨**DynamoDB**ã‚’çµ„ã¿åˆã‚ã›ã¦ã¿ãŸã„ãªã¨æ€ã£ã¦ã„ã¾ã™ï¼

ã“ã“ã¾ã§èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼ï¼ï¼